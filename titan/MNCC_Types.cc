// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R5A
// The generation of user and time information were disabled by the -D flag.

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "MNCC_Types.hh"

namespace MNCC__Types {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const OCTETSTRING os_0(0, NULL);
static const CHARSTRING cs_0(0, NULL);
static const unsigned char module_checksum[] = { 0x60, 0x7c, 0x6c, 0x42, 0xf2, 0x2c, 0x6e, 0x33, 0x86, 0x38, 0xfe, 0x94, 0x73, 0xe3, 0x52, 0x85 };

/* Global variable definitions */

const TTCN_RAWdescriptor_t int__raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       int__xer_ = { {"int>\n", "int>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t int__descr_ = { "@MNCC_Types.int", &INTEGER_ber_, &int__raw_, &INTEGER_text_, &int__xer_, &INTEGER_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING int__default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__ra_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__ra
const TTCN_Typedescriptor_t GSM48__bcap__ra_descr_ = { "@MNCC_Types.GSM48_bcap_ra", NULL, &GSM48__bcap__ra_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__ra_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__sig__access_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__sig__access
const TTCN_Typedescriptor_t GSM48__bcap__sig__access_descr_ = { "@MNCC_Types.GSM48_bcap_sig_access", NULL, &GSM48__bcap__sig__access_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__sig__access_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__user__rate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__user__rate
const TTCN_Typedescriptor_t GSM48__bcap__user__rate_descr_ = { "@MNCC_Types.GSM48_bcap_user_rate", NULL, &GSM48__bcap__user__rate_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__user__rate_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__parity_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__parity
const TTCN_Typedescriptor_t GSM48__bcap__parity_descr_ = { "@MNCC_Types.GSM48_bcap_parity", NULL, &GSM48__bcap__parity_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__parity_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__interm__rate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__interm__rate
const TTCN_Typedescriptor_t GSM48__bcap__interm__rate_descr_ = { "@MNCC_Types.GSM48_bcap_interm_rate", NULL, &GSM48__bcap__interm__rate_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__interm__rate_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__transp_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__transp
const TTCN_Typedescriptor_t GSM48__bcap__transp_descr_ = { "@MNCC_Types.GSM48_bcap_transp", NULL, &GSM48__bcap__transp_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__transp_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__bcap__modem__type_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__bcap__modem__type
const TTCN_Typedescriptor_t GSM48__bcap__modem__type_descr_ = { "@MNCC_Types.GSM48_bcap_modem_type", NULL, &GSM48__bcap__modem__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__bcap__modem__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__MsgType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgType
const TTCN_Typedescriptor_t MNCC__MsgType_descr_ = { "@MNCC_Types.MNCC_MsgType", NULL, &MNCC__MsgType_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__MsgType_default_coding("RAW");
static INTEGER const_GSM__MAX__FACILITY;
const INTEGER& GSM__MAX__FACILITY = const_GSM__MAX__FACILITY;
static INTEGER const_GSM__MAX__SSVERSION;
const INTEGER& GSM__MAX__SSVERSION = const_GSM__MAX__SSVERSION;
static INTEGER const_GSM__MAX__USERUSER;
const INTEGER& GSM__MAX__USERUSER = const_GSM__MAX__USERUSER;
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_rate__adaptation_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_rate__adaptation
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_rate__adaptation_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.rate_adaptation", NULL, &MNCC__bearer__cap__data_rate__adaptation_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_rate__adaptation_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_sig__access_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_sig__access
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_sig__access_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.sig_access", NULL, &MNCC__bearer__cap__data_sig__access_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_sig__access_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_async_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap__data_async_xer_ = { {"async>\n", "async>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap__data_async_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_async_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.async", &INTEGER_ber_, &MNCC__bearer__cap__data_async_raw_, &INTEGER_text_, &MNCC__bearer__cap__data_async_xer_, &INTEGER_json_, &MNCC__bearer__cap__data_async_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_async_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap__data_nr__stop__bits_xer_ = { {"nr_stop_bits>\n", "nr_stop_bits>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_nr__stop__bits_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.nr_stop_bits", &INTEGER_ber_, &MNCC__bearer__cap__data_nr__stop__bits_raw_, &INTEGER_text_, &MNCC__bearer__cap__data_nr__stop__bits_xer_, &INTEGER_json_, &MNCC__bearer__cap__data_nr__stop__bits_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_nr__stop__bits_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_nr__data__bits_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap__data_nr__data__bits_xer_ = { {"nr_data_bits>\n", "nr_data_bits>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap__data_nr__data__bits_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_nr__data__bits_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.nr_data_bits", &INTEGER_ber_, &MNCC__bearer__cap__data_nr__data__bits_raw_, &INTEGER_text_, &MNCC__bearer__cap__data_nr__data__bits_xer_, &INTEGER_json_, &MNCC__bearer__cap__data_nr__data__bits_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_nr__data__bits_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_user__rate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_user__rate
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_user__rate_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.user_rate", NULL, &MNCC__bearer__cap__data_user__rate_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_user__rate_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_parity_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_parity
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_parity_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.parity", NULL, &MNCC__bearer__cap__data_parity_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_parity_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_interm__rate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_interm__rate
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_interm__rate_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.interm_rate", NULL, &MNCC__bearer__cap__data_interm__rate_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_interm__rate_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_transp_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_transp
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_transp_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.transp", NULL, &MNCC__bearer__cap__data_transp_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_transp_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_modem__type_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data_modem__type
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_modem__type_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data.modem_type", NULL, &MNCC__bearer__cap__data_modem__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_modem__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap__data
const TTCN_Typedescriptor_t MNCC__bearer__cap__data_descr_ = { "@MNCC_Types.MNCC_bearer_cap_data", NULL, &MNCC__bearer__cap__data_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__speech__vers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__speech__vers
const TTCN_Typedescriptor_t MNCC__speech__vers_descr_ = { "@MNCC_Types.MNCC_speech_vers", NULL, &MNCC__speech__vers_raw_, NULL, NULL, NULL, NULL, &MNCC__speech__vers_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t MNCC__speech__vers_0_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__speech__vers_0_xer_ = { {"int>\n", "int>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__speech__vers_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__speech__vers_0_descr_ = { "@MNCC_Types.MNCC_speech_vers.<oftype>", &INTEGER_ber_, &MNCC__speech__vers_0_raw_, &INTEGER_text_, &MNCC__speech__vers_0_xer_, &INTEGER_json_, &MNCC__speech__vers_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__speech__vers_0_default_coding("RAW");
UNIVERSAL_CHARSTRING MNCC__speech__vers_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_transfer_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap_transfer_xer_ = { {"transfer>\n", "transfer>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap_transfer_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap_transfer_descr_ = { "@MNCC_Types.MNCC_bearer_cap.transfer", &INTEGER_ber_, &MNCC__bearer__cap_transfer_raw_, &INTEGER_text_, &MNCC__bearer__cap_transfer_xer_, &INTEGER_json_, &MNCC__bearer__cap_transfer_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_transfer_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_mode_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap_mode_xer_ = { {"mode>\n", "mode>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap_mode_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap_mode_descr_ = { "@MNCC_Types.MNCC_bearer_cap.mode", &INTEGER_ber_, &MNCC__bearer__cap_mode_raw_, &INTEGER_text_, &MNCC__bearer__cap_mode_xer_, &INTEGER_json_, &MNCC__bearer__cap_mode_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_mode_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_coding_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap_coding_xer_ = { {"coding>\n", "coding>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap_coding_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap_coding_descr_ = { "@MNCC_Types.MNCC_bearer_cap.coding", &INTEGER_ber_, &MNCC__bearer__cap_coding_raw_, &INTEGER_text_, &MNCC__bearer__cap_coding_xer_, &INTEGER_json_, &MNCC__bearer__cap_coding_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_coding_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_radio_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap_radio_xer_ = { {"radio>\n", "radio>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap_radio_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap_radio_descr_ = { "@MNCC_Types.MNCC_bearer_cap.radio", &INTEGER_ber_, &MNCC__bearer__cap_radio_raw_, &INTEGER_text_, &MNCC__bearer__cap_radio_xer_, &INTEGER_json_, &MNCC__bearer__cap_radio_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_radio_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_speech__ctm_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__bearer__cap_speech__ctm_xer_ = { {"speech_ctm>\n", "speech_ctm>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__bearer__cap_speech__ctm_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__bearer__cap_speech__ctm_descr_ = { "@MNCC_Types.MNCC_bearer_cap.speech_ctm", &INTEGER_ber_, &MNCC__bearer__cap_speech__ctm_raw_, &INTEGER_text_, &MNCC__bearer__cap_speech__ctm_xer_, &INTEGER_json_, &MNCC__bearer__cap_speech__ctm_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_speech__ctm_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_speech__ver_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap_speech__ver
const TTCN_Typedescriptor_t MNCC__bearer__cap_speech__ver_descr_ = { "@MNCC_Types.MNCC_bearer_cap.speech_ver", NULL, &MNCC__bearer__cap_speech__ver_raw_, NULL, NULL, NULL, NULL, &MNCC__speech__vers_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_speech__ver_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bearer__cap_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap
const TTCN_Typedescriptor_t MNCC__bearer__cap_descr_ = { "@MNCC_Types.MNCC_bearer_cap", NULL, &MNCC__bearer__cap_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t MNCC__bearer__cap_data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bearer__cap_data
const TTCN_Typedescriptor_t MNCC__bearer__cap_data_descr_ = { "@MNCC_Types.MNCC_bearer_cap.data", NULL, &MNCC__bearer__cap_data_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bearer__cap_data_default_coding("RAW");
UNIVERSAL_CHARSTRING MNCC__bearer__cap_default_coding("RAW");
static MNCC__bearer__cap_template template_ts__MNCC__bcap__voice;
const MNCC__bearer__cap_template& ts__MNCC__bcap__voice = template_ts__MNCC__bcap__voice;
const TTCN_RAWdescriptor_t GSM48__type__of__number_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__type__of__number
const TTCN_Typedescriptor_t GSM48__type__of__number_descr_ = { "@MNCC_Types.GSM48_type_of_number", NULL, &GSM48__type__of__number_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__type__of__number_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_number__type_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__number_number__type
const TTCN_Typedescriptor_t MNCC__number_number__type_descr_ = { "@MNCC_Types.MNCC_number.number_type", NULL, &MNCC__number_number__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_number__type_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__num__plan__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__num__plan__ind
const TTCN_Typedescriptor_t GSM48__num__plan__ind_descr_ = { "@MNCC_Types.GSM48_num_plan_ind", NULL, &GSM48__num__plan__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__num__plan__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_plan_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__number_plan
const TTCN_Typedescriptor_t MNCC__number_plan_descr_ = { "@MNCC_Types.MNCC_number.plan", NULL, &MNCC__number_plan_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_plan_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__present__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__present__ind
const TTCN_Typedescriptor_t GSM48__present__ind_descr_ = { "@MNCC_Types.GSM48_present_ind", NULL, &GSM48__present__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__present__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_presence_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__number_presence
const TTCN_Typedescriptor_t MNCC__number_presence_descr_ = { "@MNCC_Types.MNCC_number.presence", NULL, &MNCC__number_presence_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_presence_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__screening__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__screening__ind
const TTCN_Typedescriptor_t GSM48__screening__ind_descr_ = { "@MNCC_Types.GSM48_screening_ind", NULL, &GSM48__screening__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__screening__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_screen_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__number_screen
const TTCN_Typedescriptor_t MNCC__number_screen_descr_ = { "@MNCC_Types.MNCC_number.screen", NULL, &MNCC__number_screen_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_screen_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_number_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__number_number_xer_ = { {"number>\n", "number>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__number_number_descr_ = { "@MNCC_Types.MNCC_number.number", NULL, &MNCC__number_number_raw_, &CHARSTRING_text_, &MNCC__number_number_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_number_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__number_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__number
const TTCN_Typedescriptor_t MNCC__number_descr_ = { "@MNCC_Types.MNCC_number", NULL, &MNCC__number_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__number_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__cause__coding_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__cause__coding
const TTCN_Typedescriptor_t GSM48__cause__coding_descr_ = { "@MNCC_Types.GSM48_cause_coding", NULL, &GSM48__cause__coding_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__cause__coding_default_coding("RAW");
const TTCN_RAWdescriptor_t GSM48__cause__loc_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for GSM48__cause__loc
const TTCN_Typedescriptor_t GSM48__cause__loc_descr_ = { "@MNCC_Types.GSM48_cause_loc", NULL, &GSM48__cause__loc_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING GSM48__cause__loc_default_coding("RAW");
static GSM48__type__of__number const_ts__MNCC__number_ton_defval;
const GSM48__type__of__number& ts__MNCC__number_ton_defval = const_ts__MNCC__number_ton_defval;
static GSM48__num__plan__ind const_ts__MNCC__number_npi_defval;
const GSM48__num__plan__ind& ts__MNCC__number_npi_defval = const_ts__MNCC__number_npi_defval;
static GSM48__present__ind const_ts__MNCC__number_pres_defval;
const GSM48__present__ind& ts__MNCC__number_pres_defval = const_ts__MNCC__number_pres_defval;
static GSM48__screening__ind const_ts__MNCC__number_screen_defval;
const GSM48__screening__ind& ts__MNCC__number_screen_defval = const_ts__MNCC__number_screen_defval;
static GSM48__type__of__number_template template_tr__MNCC__number_ton_defval;
const GSM48__type__of__number_template& tr__MNCC__number_ton_defval = template_tr__MNCC__number_ton_defval;
static GSM48__num__plan__ind_template template_tr__MNCC__number_npi_defval;
const GSM48__num__plan__ind_template& tr__MNCC__number_npi_defval = template_tr__MNCC__number_npi_defval;
static GSM48__present__ind_template template_tr__MNCC__number_pres_defval;
const GSM48__present__ind_template& tr__MNCC__number_pres_defval = template_tr__MNCC__number_pres_defval;
static GSM48__screening__ind_template template_tr__MNCC__number_screen_defval;
const GSM48__screening__ind_template& tr__MNCC__number_screen_defval = template_tr__MNCC__number_screen_defval;
const TTCN_RAWdescriptor_t MNCC__cause_location_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__cause_location
const TTCN_Typedescriptor_t MNCC__cause_location_descr_ = { "@MNCC_Types.MNCC_cause.location", NULL, &MNCC__cause_location_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_location_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_coding_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__cause_coding
const TTCN_Typedescriptor_t MNCC__cause_coding_descr_ = { "@MNCC_Types.MNCC_cause.coding", NULL, &MNCC__cause_coding_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_coding_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_rec_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cause_rec_xer_ = { {"rec>\n", "rec>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__cause_rec_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__cause_rec_descr_ = { "@MNCC_Types.MNCC_cause.rec", &INTEGER_ber_, &MNCC__cause_rec_raw_, &INTEGER_text_, &MNCC__cause_rec_xer_, &INTEGER_json_, &MNCC__cause_rec_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_rec_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_rec__val_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cause_rec__val_xer_ = { {"rec_val>\n", "rec_val>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__cause_rec__val_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__cause_rec__val_descr_ = { "@MNCC_Types.MNCC_cause.rec_val", &INTEGER_ber_, &MNCC__cause_rec__val_raw_, &INTEGER_text_, &MNCC__cause_rec__val_xer_, &INTEGER_json_, &MNCC__cause_rec__val_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_rec__val_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_val_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cause_val_xer_ = { {"val>\n", "val>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__cause_val_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__cause_val_descr_ = { "@MNCC_Types.MNCC_cause.val", &INTEGER_ber_, &MNCC__cause_val_raw_, &INTEGER_text_, &MNCC__cause_val_xer_, &INTEGER_json_, &MNCC__cause_val_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_val_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_diag_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cause_diag_xer_ = { {"diag>\n", "diag>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int MNCC__cause_diag_oer_ext_arr_[0] = {};
const int MNCC__cause_diag_oer_p_[0] = {};
const TTCN_OERdescriptor_t MNCC__cause_diag_oer_ = { -1, TRUE, -1, FALSE, 0, 0, MNCC__cause_diag_oer_ext_arr_, 0, MNCC__cause_diag_oer_p_};
const TTCN_Typedescriptor_t MNCC__cause_diag_descr_ = { "@MNCC_Types.MNCC_cause.diag", &OCTETSTRING_ber_, &MNCC__cause_diag_raw_, &OCTETSTRING_text_, &MNCC__cause_diag_xer_, &OCTETSTRING_json_, &MNCC__cause_diag_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_diag_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cause_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__cause
const TTCN_Typedescriptor_t MNCC__cause_descr_ = { "@MNCC_Types.MNCC_cause", NULL, &MNCC__cause_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cause_default_coding("RAW");
static GSM48__cause__loc const_ts__MNCC__cause_loc_defval;
const GSM48__cause__loc& ts__MNCC__cause_loc_defval = const_ts__MNCC__cause_loc_defval;
static GSM48__cause__coding const_ts__MNCC__cause_coding_defval;
const GSM48__cause__coding& ts__MNCC__cause_coding_defval = const_ts__MNCC__cause_coding_defval;
static OCTETSTRING const_ts__MNCC__cause_diag_defval;
const OCTETSTRING& ts__MNCC__cause_diag_defval = const_ts__MNCC__cause_diag_defval;
const TTCN_RAWdescriptor_t MNCC__useruser_proto_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__useruser_proto_xer_ = { {"proto>\n", "proto>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__useruser_proto_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__useruser_proto_descr_ = { "@MNCC_Types.MNCC_useruser.proto", &INTEGER_ber_, &MNCC__useruser_proto_raw_, &INTEGER_text_, &MNCC__useruser_proto_xer_, &INTEGER_json_, &MNCC__useruser_proto_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__useruser_proto_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__useruser_info_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__useruser_info_xer_ = { {"info>\n", "info>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__useruser_info_descr_ = { "@MNCC_Types.MNCC_useruser.info", NULL, &MNCC__useruser_info_raw_, &CHARSTRING_text_, &MNCC__useruser_info_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__useruser_info_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__useruser_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__useruser
const TTCN_Typedescriptor_t MNCC__useruser_descr_ = { "@MNCC_Types.MNCC_useruser", NULL, &MNCC__useruser_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__useruser_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__progress_coding_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__progress_coding_xer_ = { {"coding>\n", "coding>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__progress_coding_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__progress_coding_descr_ = { "@MNCC_Types.MNCC_progress.coding", &INTEGER_ber_, &MNCC__progress_coding_raw_, &INTEGER_text_, &MNCC__progress_coding_xer_, &INTEGER_json_, &MNCC__progress_coding_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__progress_coding_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__progress_location_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__progress_location_xer_ = { {"location>\n", "location>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__progress_location_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__progress_location_descr_ = { "@MNCC_Types.MNCC_progress.location", &INTEGER_ber_, &MNCC__progress_location_raw_, &INTEGER_text_, &MNCC__progress_location_xer_, &INTEGER_json_, &MNCC__progress_location_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__progress_location_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__progress_descr_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__progress_descr_xer_ = { {"descr>\n", "descr>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__progress_descr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__progress_descr_descr_ = { "@MNCC_Types.MNCC_progress.descr", &INTEGER_ber_, &MNCC__progress_descr_raw_, &INTEGER_text_, &MNCC__progress_descr_xer_, &INTEGER_json_, &MNCC__progress_descr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__progress_descr_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__progress_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__progress
const TTCN_Typedescriptor_t MNCC__progress_descr_ = { "@MNCC_Types.MNCC_progress", NULL, &MNCC__progress_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__progress_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cccap_dtmf_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cccap_dtmf_xer_ = { {"dtmf>\n", "dtmf>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__cccap_dtmf_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__cccap_dtmf_descr_ = { "@MNCC_Types.MNCC_cccap.dtmf", &INTEGER_ber_, &MNCC__cccap_dtmf_raw_, &INTEGER_text_, &MNCC__cccap_dtmf_xer_, &INTEGER_json_, &MNCC__cccap_dtmf_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cccap_dtmf_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cccap_pcp_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__cccap_pcp_xer_ = { {"pcp>\n", "pcp>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__cccap_pcp_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__cccap_pcp_descr_ = { "@MNCC_Types.MNCC_cccap.pcp", &INTEGER_ber_, &MNCC__cccap_pcp_raw_, &INTEGER_text_, &MNCC__cccap_pcp_xer_, &INTEGER_json_, &MNCC__cccap_pcp_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cccap_pcp_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__cccap_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__cccap
const TTCN_Typedescriptor_t MNCC__cccap_descr_ = { "@MNCC_Types.MNCC_cccap", NULL, &MNCC__cccap_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__cccap_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__notify_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__notify_xer_ = { {"MNCC_notify>\n", "MNCC_notify>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__notify_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__notify_descr_ = { "@MNCC_Types.MNCC_notify", &INTEGER_ber_, &MNCC__notify_raw_, &INTEGER_text_, &MNCC__notify_xer_, &INTEGER_json_, &MNCC__notify_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__notify_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__keypad_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__keypad_xer_ = { {"MNCC_keypad>\n", "MNCC_keypad>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__keypad_descr_ = { "@MNCC_Types.MNCC_keypad", NULL, &MNCC__keypad_raw_, &CHARSTRING_text_, &MNCC__keypad_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__keypad_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__bcap_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__bcap
const TTCN_Typedescriptor_t MNCC__bcap_descr_ = { "@MNCC_Types.MNCC_bcap", NULL, &MNCC__bcap_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__bcap_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_callref_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_callref_xer_ = { {"callref>\n", "callref>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_callref_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_callref_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.callref", &INTEGER_ber_, &MNCC__PDU__Signal_callref_raw_, &INTEGER_text_, &MNCC__PDU__Signal_callref_xer_, &INTEGER_json_, &MNCC__PDU__Signal_callref_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_callref_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_clir__sup_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_clir__sup_xer_ = { {"clir_sup>\n", "clir_sup>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_clir__sup_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_clir__sup_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.clir_sup", &INTEGER_ber_, &MNCC__PDU__Signal_clir__sup_raw_, &INTEGER_text_, &MNCC__PDU__Signal_clir__sup_xer_, &INTEGER_json_, &MNCC__PDU__Signal_clir__sup_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_clir__sup_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_clir__inv_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_clir__inv_xer_ = { {"clir_inv>\n", "clir_inv>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_clir__inv_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_clir__inv_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.clir_inv", &INTEGER_ber_, &MNCC__PDU__Signal_clir__inv_raw_, &INTEGER_text_, &MNCC__PDU__Signal_clir__inv_xer_, &INTEGER_json_, &MNCC__PDU__Signal_clir__inv_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_clir__inv_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_more_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_more_xer_ = { {"more>\n", "more>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_more_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_more_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.more", &INTEGER_ber_, &MNCC__PDU__Signal_more_raw_, &INTEGER_text_, &MNCC__PDU__Signal_more_xer_, &INTEGER_json_, &MNCC__PDU__Signal_more_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_more_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_notify_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_notify_xer_ = { {"notify>\n", "notify>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_notify_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_notify_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.notify", &INTEGER_ber_, &MNCC__PDU__Signal_notify_raw_, &INTEGER_text_, &MNCC__PDU__Signal_notify_xer_, &INTEGER_json_, &MNCC__PDU__Signal_notify_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_notify_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_imsi_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_imsi_xer_ = { {"imsi>\n", "imsi>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_imsi_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.imsi", NULL, &MNCC__PDU__Signal_imsi_raw_, &CHARSTRING_text_, &MNCC__PDU__Signal_imsi_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_imsi_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_lchan__type_raw_ = {8,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_lchan__type_xer_ = { {"lchan_type>\n", "lchan_type>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_lchan__type_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_lchan__type_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.lchan_type", &INTEGER_ber_, &MNCC__PDU__Signal_lchan__type_raw_, &INTEGER_text_, &MNCC__PDU__Signal_lchan__type_xer_, &INTEGER_json_, &MNCC__PDU__Signal_lchan__type_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_lchan__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_lchan__mode_raw_ = {8,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_lchan__mode_xer_ = { {"lchan_mode>\n", "lchan_mode>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_lchan__mode_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_lchan__mode_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.lchan_mode", &INTEGER_ber_, &MNCC__PDU__Signal_lchan__mode_raw_, &INTEGER_text_, &MNCC__PDU__Signal_lchan__mode_xer_, &INTEGER_json_, &MNCC__PDU__Signal_lchan__mode_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_lchan__mode_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal
const TTCN_Typedescriptor_t MNCC__PDU__Signal_descr_ = { "@MNCC_Types.MNCC_PDU_Signal", NULL, &MNCC__PDU__Signal_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_bearer__cap_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_bearer__cap
const TTCN_Typedescriptor_t MNCC__PDU__Signal_bearer__cap_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.bearer_cap", NULL, &MNCC__PDU__Signal_bearer__cap_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_bearer__cap_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_called_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_called
const TTCN_Typedescriptor_t MNCC__PDU__Signal_called_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.called", NULL, &MNCC__PDU__Signal_called_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_called_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_calling_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_calling
const TTCN_Typedescriptor_t MNCC__PDU__Signal_calling_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.calling", NULL, &MNCC__PDU__Signal_calling_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_calling_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_redirecting_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_redirecting
const TTCN_Typedescriptor_t MNCC__PDU__Signal_redirecting_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.redirecting", NULL, &MNCC__PDU__Signal_redirecting_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_redirecting_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_connected_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_connected
const TTCN_Typedescriptor_t MNCC__PDU__Signal_connected_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.connected", NULL, &MNCC__PDU__Signal_connected_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_connected_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_cause_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_cause
const TTCN_Typedescriptor_t MNCC__PDU__Signal_cause_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.cause", NULL, &MNCC__PDU__Signal_cause_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_cause_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_progress_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_progress
const TTCN_Typedescriptor_t MNCC__PDU__Signal_progress_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.progress", NULL, &MNCC__PDU__Signal_progress_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_progress_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_useruser_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_useruser
const TTCN_Typedescriptor_t MNCC__PDU__Signal_useruser_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.useruser", NULL, &MNCC__PDU__Signal_useruser_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_useruser_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_facility_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_facility_xer_ = { {"facility>\n", "facility>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_facility_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.facility", NULL, &MNCC__PDU__Signal_facility_raw_, &CHARSTRING_text_, &MNCC__PDU__Signal_facility_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_facility_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_cccap_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Signal_cccap
const TTCN_Typedescriptor_t MNCC__PDU__Signal_cccap_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.cccap", NULL, &MNCC__PDU__Signal_cccap_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_cccap_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_ssversion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_ssversion_xer_ = { {"ssversion>\n", "ssversion>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_ssversion_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.ssversion", NULL, &MNCC__PDU__Signal_ssversion_raw_, &CHARSTRING_text_, &MNCC__PDU__Signal_ssversion_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_ssversion_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_signal_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_signal_xer_ = { {"signal>\n", "signal>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_signal_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_signal_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.signal", &INTEGER_ber_, &MNCC__PDU__Signal_signal_raw_, &INTEGER_text_, &MNCC__PDU__Signal_signal_xer_, &INTEGER_json_, &MNCC__PDU__Signal_signal_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_signal_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_keypad_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_keypad_xer_ = { {"keypad>\n", "keypad>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_keypad_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.keypad", NULL, &MNCC__PDU__Signal_keypad_raw_, &CHARSTRING_text_, &MNCC__PDU__Signal_keypad_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_keypad_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Signal_emergency_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Signal_emergency_xer_ = { {"emergency>\n", "emergency>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Signal_emergency_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Signal_emergency_descr_ = { "@MNCC_Types.MNCC_PDU_Signal.emergency", &INTEGER_ber_, &MNCC__PDU__Signal_emergency_raw_, &INTEGER_text_, &MNCC__PDU__Signal_emergency_xer_, &INTEGER_json_, &MNCC__PDU__Signal_emergency_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_emergency_default_coding("RAW");
UNIVERSAL_CHARSTRING MNCC__PDU__Signal_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Data_callref_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Data_callref_xer_ = { {"callref>\n", "callref>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Data_callref_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Data_callref_descr_ = { "@MNCC_Types.MNCC_PDU_Data.callref", &INTEGER_ber_, &MNCC__PDU__Data_callref_raw_, &INTEGER_text_, &MNCC__PDU__Data_callref_xer_, &INTEGER_json_, &MNCC__PDU__Data_callref_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Data_callref_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Data_data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Data_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int MNCC__PDU__Data_data_oer_ext_arr_[0] = {};
const int MNCC__PDU__Data_data_oer_p_[0] = {};
const TTCN_OERdescriptor_t MNCC__PDU__Data_data_oer_ = { -1, TRUE, -1, FALSE, 0, 0, MNCC__PDU__Data_data_oer_ext_arr_, 0, MNCC__PDU__Data_data_oer_p_};
const TTCN_Typedescriptor_t MNCC__PDU__Data_data_descr_ = { "@MNCC_Types.MNCC_PDU_Data.data", &OCTETSTRING_ber_, &MNCC__PDU__Data_data_raw_, &OCTETSTRING_text_, &MNCC__PDU__Data_data_xer_, &OCTETSTRING_json_, &MNCC__PDU__Data_data_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Data_data_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Data
const TTCN_Typedescriptor_t MNCC__PDU__Data_descr_ = { "@MNCC_Types.MNCC_PDU_Data", NULL, &MNCC__PDU__Data_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Data_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_callref_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Rtp_callref_xer_ = { {"callref>\n", "callref>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Rtp_callref_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_callref_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp.callref", &INTEGER_ber_, &MNCC__PDU__Rtp_callref_raw_, &INTEGER_text_, &MNCC__PDU__Rtp_callref_xer_, &INTEGER_json_, &MNCC__PDU__Rtp_callref_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_callref_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_ip_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Rtp_ip_xer_ = { {"ip>\n", "ip>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Rtp_ip_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_ip_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp.ip", &INTEGER_ber_, &MNCC__PDU__Rtp_ip_raw_, &INTEGER_text_, &MNCC__PDU__Rtp_ip_xer_, &INTEGER_json_, &MNCC__PDU__Rtp_ip_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_ip_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_rtp__port_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Rtp_rtp__port_xer_ = { {"rtp_port>\n", "rtp_port>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Rtp_rtp__port_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_rtp__port_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp.rtp_port", &INTEGER_ber_, &MNCC__PDU__Rtp_rtp__port_raw_, &INTEGER_text_, &MNCC__PDU__Rtp_rtp__port_xer_, &INTEGER_json_, &MNCC__PDU__Rtp_rtp__port_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_rtp__port_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_payload__type_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Rtp_payload__type_xer_ = { {"payload_type>\n", "payload_type>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Rtp_payload__type_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_payload__type_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp.payload_type", &INTEGER_ber_, &MNCC__PDU__Rtp_payload__type_raw_, &INTEGER_text_, &MNCC__PDU__Rtp_payload__type_xer_, &INTEGER_json_, &MNCC__PDU__Rtp_payload__type_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_payload__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_payload__msg__type_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Rtp_payload__msg__type_xer_ = { {"payload_msg_type>\n", "payload_msg_type>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Rtp_payload__msg__type_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_payload__msg__type_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp.payload_msg_type", &INTEGER_ber_, &MNCC__PDU__Rtp_payload__msg__type_raw_, &INTEGER_text_, &MNCC__PDU__Rtp_payload__msg__type_xer_, &INTEGER_json_, &MNCC__PDU__Rtp_payload__msg__type_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_payload__msg__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Rtp
const TTCN_Typedescriptor_t MNCC__PDU__Rtp_descr_ = { "@MNCC_Types.MNCC_PDU_Rtp", NULL, &MNCC__PDU__Rtp_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_version_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_version_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_version_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.version", &INTEGER_ber_, &MNCC__PDU__Hello_version_raw_, &INTEGER_text_, &MNCC__PDU__Hello_version_xer_, &INTEGER_json_, &MNCC__PDU__Hello_version_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_version_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_mncc__size_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_mncc__size_xer_ = { {"mncc_size>\n", "mncc_size>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_mncc__size_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_mncc__size_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.mncc_size", &INTEGER_ber_, &MNCC__PDU__Hello_mncc__size_raw_, &INTEGER_text_, &MNCC__PDU__Hello_mncc__size_xer_, &INTEGER_json_, &MNCC__PDU__Hello_mncc__size_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_mncc__size_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_data__frame__size_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_data__frame__size_xer_ = { {"data_frame_size>\n", "data_frame_size>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_data__frame__size_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_data__frame__size_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.data_frame_size", &INTEGER_ber_, &MNCC__PDU__Hello_data__frame__size_raw_, &INTEGER_text_, &MNCC__PDU__Hello_data__frame__size_xer_, &INTEGER_json_, &MNCC__PDU__Hello_data__frame__size_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_data__frame__size_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_called__offset_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_called__offset_xer_ = { {"called_offset>\n", "called_offset>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_called__offset_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_called__offset_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.called_offset", &INTEGER_ber_, &MNCC__PDU__Hello_called__offset_raw_, &INTEGER_text_, &MNCC__PDU__Hello_called__offset_xer_, &INTEGER_json_, &MNCC__PDU__Hello_called__offset_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_called__offset_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_signal__offset_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_signal__offset_xer_ = { {"signal_offset>\n", "signal_offset>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_signal__offset_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_signal__offset_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.signal_offset", &INTEGER_ber_, &MNCC__PDU__Hello_signal__offset_raw_, &INTEGER_text_, &MNCC__PDU__Hello_signal__offset_xer_, &INTEGER_json_, &MNCC__PDU__Hello_signal__offset_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_signal__offset_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_emergency__offset_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_emergency__offset_xer_ = { {"emergency_offset>\n", "emergency_offset>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_emergency__offset_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_emergency__offset_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.emergency_offset", &INTEGER_ber_, &MNCC__PDU__Hello_emergency__offset_raw_, &INTEGER_text_, &MNCC__PDU__Hello_emergency__offset_xer_, &INTEGER_json_, &MNCC__PDU__Hello_emergency__offset_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_emergency__offset_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_lchan__type__offset_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       MNCC__PDU__Hello_lchan__type__offset_xer_ = { {"lchan_type_offset>\n", "lchan_type_offset>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t MNCC__PDU__Hello_lchan__type__offset_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t MNCC__PDU__Hello_lchan__type__offset_descr_ = { "@MNCC_Types.MNCC_PDU_Hello.lchan_type_offset", &INTEGER_ber_, &MNCC__PDU__Hello_lchan__type__offset_raw_, &INTEGER_text_, &MNCC__PDU__Hello_lchan__type__offset_xer_, &INTEGER_json_, &MNCC__PDU__Hello_lchan__type__offset_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_lchan__type__offset_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU__Hello_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU__Hello
const TTCN_Typedescriptor_t MNCC__PDU__Hello_descr_ = { "@MNCC_Types.MNCC_PDU_Hello", NULL, &MNCC__PDU__Hello_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU__Hello_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__MsgUnion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgUnion
const TTCN_Typedescriptor_t MNCC__MsgUnion_descr_ = { "@MNCC_Types.MNCC_MsgUnion", NULL, &MNCC__MsgUnion_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t MNCC__MsgUnion_signal_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgUnion_signal
const TTCN_Typedescriptor_t MNCC__MsgUnion_signal_descr_ = { "@MNCC_Types.MNCC_MsgUnion.signal", NULL, &MNCC__MsgUnion_signal_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__MsgUnion_signal_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__MsgUnion_data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgUnion_data
const TTCN_Typedescriptor_t MNCC__MsgUnion_data_descr_ = { "@MNCC_Types.MNCC_MsgUnion.data", NULL, &MNCC__MsgUnion_data_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__MsgUnion_data_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__MsgUnion_rtp_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgUnion_rtp
const TTCN_Typedescriptor_t MNCC__MsgUnion_rtp_descr_ = { "@MNCC_Types.MNCC_MsgUnion.rtp", NULL, &MNCC__MsgUnion_rtp_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__MsgUnion_rtp_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__MsgUnion_hello_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__MsgUnion_hello
const TTCN_Typedescriptor_t MNCC__MsgUnion_hello_descr_ = { "@MNCC_Types.MNCC_MsgUnion.hello", NULL, &MNCC__MsgUnion_hello_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__MsgUnion_hello_default_coding("RAW");
UNIVERSAL_CHARSTRING MNCC__MsgUnion_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU_msg__type_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU_msg__type
const TTCN_Typedescriptor_t MNCC__PDU_msg__type_descr_ = { "@MNCC_Types.MNCC_PDU.msg_type", NULL, &MNCC__PDU_msg__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU_msg__type_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU_u_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU_u
const TTCN_Typedescriptor_t MNCC__PDU_u_descr_ = { "@MNCC_Types.MNCC_PDU.u", NULL, &MNCC__PDU_u_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU_u_default_coding("RAW");
const TTCN_RAWdescriptor_t MNCC__PDU_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for MNCC__PDU
const TTCN_Typedescriptor_t MNCC__PDU_descr_ = { "@MNCC_Types.MNCC_PDU", NULL, &MNCC__PDU_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING MNCC__PDU_default_coding("RAW");
static INTEGER const_ts__MNCC__HELLO_version_defval;
const INTEGER& ts__MNCC__HELLO_version_defval = const_ts__MNCC__HELLO_version_defval;
static CHARSTRING const_ts__MNCC__SETUP__req_imsi_defval;
const CHARSTRING& ts__MNCC__SETUP__req_imsi_defval = const_ts__MNCC__SETUP__req_imsi_defval;
static INTEGER_template template_tr__MNCC__SETUP__req_call__id_defval;
const INTEGER_template& tr__MNCC__SETUP__req_call__id_defval = template_tr__MNCC__SETUP__req_call__id_defval;
static CHARSTRING_template template_tr__MNCC__SETUP__req_called_defval;
const CHARSTRING_template& tr__MNCC__SETUP__req_called_defval = template_tr__MNCC__SETUP__req_called_defval;
static CHARSTRING_template template_tr__MNCC__SETUP__req_calling_defval;
const CHARSTRING_template& tr__MNCC__SETUP__req_calling_defval = template_tr__MNCC__SETUP__req_calling_defval;
static CHARSTRING_template template_tr__MNCC__SETUP__req_imsi_defval;
const CHARSTRING_template& tr__MNCC__SETUP__req_imsi_defval = template_tr__MNCC__SETUP__req_imsi_defval;
static CHARSTRING const_ts__MNCC__SETUP__rsp_imsi_defval;
const CHARSTRING& ts__MNCC__SETUP__rsp_imsi_defval = const_ts__MNCC__SETUP__rsp_imsi_defval;
static MNCC__number_template template_ts__MNCC__SETUP__rsp_connected_defval;
const MNCC__number_template& ts__MNCC__SETUP__rsp_connected_defval = template_ts__MNCC__SETUP__rsp_connected_defval;
static CHARSTRING_template template_tr__MNCC__SETUP__rsp_imsi_defval;
const CHARSTRING_template& tr__MNCC__SETUP__rsp_imsi_defval = template_tr__MNCC__SETUP__rsp_imsi_defval;
static MNCC__number_template template_tr__MNCC__SETUP__rsp_connected_defval;
const MNCC__number_template& tr__MNCC__SETUP__rsp_connected_defval = template_tr__MNCC__SETUP__rsp_connected_defval;
static INTEGER_template template_tr__MNCC__SETUP__ind_call__id_defval;
const INTEGER_template& tr__MNCC__SETUP__ind_call__id_defval = template_tr__MNCC__SETUP__ind_call__id_defval;
static MNCC__number_template template_tr__MNCC__SETUP__ind_called_defval;
const MNCC__number_template& tr__MNCC__SETUP__ind_called_defval = template_tr__MNCC__SETUP__ind_called_defval;
static MNCC__number_template template_tr__MNCC__SETUP__ind_calling_defval;
const MNCC__number_template& tr__MNCC__SETUP__ind_calling_defval = template_tr__MNCC__SETUP__ind_calling_defval;
static CHARSTRING_template template_tr__MNCC__SETUP__ind_imsi_defval;
const CHARSTRING_template& tr__MNCC__SETUP__ind_imsi_defval = template_tr__MNCC__SETUP__ind_imsi_defval;
static MNCC__number_template template_ts__MNCC__SETUP__ind_calling_defval;
const MNCC__number_template& ts__MNCC__SETUP__ind_calling_defval = template_ts__MNCC__SETUP__ind_calling_defval;
static CHARSTRING_template template_ts__MNCC__SETUP__ind_imsi_defval;
const CHARSTRING_template& ts__MNCC__SETUP__ind_imsi_defval = template_ts__MNCC__SETUP__ind_imsi_defval;
static MNCC__bearer__cap_template template_ts__MNCC__SETUP__ind_bcap_defval;
const MNCC__bearer__cap_template& ts__MNCC__SETUP__ind_bcap_defval = template_ts__MNCC__SETUP__ind_bcap_defval;
static MNCC__number_template template_ts__MNCC__SETUP__CNF_connected_defval;
const MNCC__number_template& ts__MNCC__SETUP__CNF_connected_defval = template_ts__MNCC__SETUP__CNF_connected_defval;
static MNCC__number_template template_tr__MNCC__SETUP__cnf_connected_defval;
const MNCC__number_template& tr__MNCC__SETUP__cnf_connected_defval = template_tr__MNCC__SETUP__cnf_connected_defval;
static INTEGER_template template_tr__MNCC__SETUP__COMPL__ind_call__id_defval;
const INTEGER_template& tr__MNCC__SETUP__COMPL__ind_call__id_defval = template_tr__MNCC__SETUP__COMPL__ind_call__id_defval;
static MNCC__cause_template template_tr__MNCC__REJ__req_cause_defval;
const MNCC__cause_template& tr__MNCC__REJ__req_cause_defval = template_tr__MNCC__REJ__req_cause_defval;
static MNCC__cause_template template_ts__MNCC__REJ__ind_cause_defval;
const MNCC__cause_template& ts__MNCC__REJ__ind_cause_defval = template_ts__MNCC__REJ__ind_cause_defval;
static MNCC__bearer__cap_template template_tr__MNCC__CALL__CONF__ind_bcap_defval;
const MNCC__bearer__cap_template& tr__MNCC__CALL__CONF__ind_bcap_defval = template_tr__MNCC__CALL__CONF__ind_bcap_defval;
static MNCC__cause_template template_tr__MNCC__CALL__CONF__ind_cause_defval;
const MNCC__cause_template& tr__MNCC__CALL__CONF__ind_cause_defval = template_tr__MNCC__CALL__CONF__ind_cause_defval;
static MNCC__cccap_template template_tr__MNCC__CALL__CONF__ind_cccap_defval;
const MNCC__cccap_template& tr__MNCC__CALL__CONF__ind_cccap_defval = template_tr__MNCC__CALL__CONF__ind_cccap_defval;
static MNCC__bearer__cap_template template_ts__MNCC__CALL__CONF__ind_bcap_defval;
const MNCC__bearer__cap_template& ts__MNCC__CALL__CONF__ind_bcap_defval = template_ts__MNCC__CALL__CONF__ind_bcap_defval;
static MNCC__cause_template template_ts__MNCC__CALL__CONF__ind_cause_defval;
const MNCC__cause_template& ts__MNCC__CALL__CONF__ind_cause_defval = template_ts__MNCC__CALL__CONF__ind_cause_defval;
static MNCC__cccap_template template_ts__MNCC__CALL__CONF__ind_cccap_defval;
const MNCC__cccap_template& ts__MNCC__CALL__CONF__ind_cccap_defval = template_ts__MNCC__CALL__CONF__ind_cccap_defval;
static MNCC__bearer__cap_template template_ts__MNCC__CALL__PROC__req_bcap_defval;
const MNCC__bearer__cap_template& ts__MNCC__CALL__PROC__req_bcap_defval = template_ts__MNCC__CALL__PROC__req_bcap_defval;
static MNCC__progress_template template_ts__MNCC__CALL__PROC__req_prog_defval;
const MNCC__progress_template& ts__MNCC__CALL__PROC__req_prog_defval = template_ts__MNCC__CALL__PROC__req_prog_defval;
static CHARSTRING_template template_ts__MNCC__CALL__PROC__req_fac_defval;
const CHARSTRING_template& ts__MNCC__CALL__PROC__req_fac_defval = template_ts__MNCC__CALL__PROC__req_fac_defval;
static MNCC__cccap_template template_ts__MNCC__CALL__PROC__req_cccap_defval;
const MNCC__cccap_template& ts__MNCC__CALL__PROC__req_cccap_defval = template_ts__MNCC__CALL__PROC__req_cccap_defval;
static MNCC__bearer__cap_template template_tr__MNCC__CALL__PROC__req_bcap_defval;
const MNCC__bearer__cap_template& tr__MNCC__CALL__PROC__req_bcap_defval = template_tr__MNCC__CALL__PROC__req_bcap_defval;
static MNCC__progress_template template_tr__MNCC__CALL__PROC__req_prog_defval;
const MNCC__progress_template& tr__MNCC__CALL__PROC__req_prog_defval = template_tr__MNCC__CALL__PROC__req_prog_defval;
static CHARSTRING_template template_tr__MNCC__CALL__PROC__req_fac_defval;
const CHARSTRING_template& tr__MNCC__CALL__PROC__req_fac_defval = template_tr__MNCC__CALL__PROC__req_fac_defval;
static MNCC__cccap_template template_tr__MNCC__CALL__PROC__req_cccap_defval;
const MNCC__cccap_template& tr__MNCC__CALL__PROC__req_cccap_defval = template_tr__MNCC__CALL__PROC__req_cccap_defval;
static MNCC__useruser_template template_ts__MNCC__PROGRESS__req_uu_defval;
const MNCC__useruser_template& ts__MNCC__PROGRESS__req_uu_defval = template_ts__MNCC__PROGRESS__req_uu_defval;
static MNCC__progress_template template_ts__MNCC__ALERT__req_prog_defval;
const MNCC__progress_template& ts__MNCC__ALERT__req_prog_defval = template_ts__MNCC__ALERT__req_prog_defval;
static CHARSTRING_template template_ts__MNCC__ALERT__req_fac_defval;
const CHARSTRING_template& ts__MNCC__ALERT__req_fac_defval = template_ts__MNCC__ALERT__req_fac_defval;
static MNCC__useruser_template template_ts__MNCC__ALERT__req_uu_defval;
const MNCC__useruser_template& ts__MNCC__ALERT__req_uu_defval = template_ts__MNCC__ALERT__req_uu_defval;
static MNCC__progress_template template_tr__MNCC__ALERT__req_prog_defval;
const MNCC__progress_template& tr__MNCC__ALERT__req_prog_defval = template_tr__MNCC__ALERT__req_prog_defval;
static CHARSTRING_template template_tr__MNCC__ALERT__req_fac_defval;
const CHARSTRING_template& tr__MNCC__ALERT__req_fac_defval = template_tr__MNCC__ALERT__req_fac_defval;
static MNCC__useruser_template template_tr__MNCC__ALERT__req_uu_defval;
const MNCC__useruser_template& tr__MNCC__ALERT__req_uu_defval = template_tr__MNCC__ALERT__req_uu_defval;
static MNCC__progress_template template_tr__MNCC__ALERT__ind_prog_defval;
const MNCC__progress_template& tr__MNCC__ALERT__ind_prog_defval = template_tr__MNCC__ALERT__ind_prog_defval;
static CHARSTRING_template template_tr__MNCC__ALERT__ind_fac_defval;
const CHARSTRING_template& tr__MNCC__ALERT__ind_fac_defval = template_tr__MNCC__ALERT__ind_fac_defval;
static MNCC__useruser_template template_tr__MNCC__ALERT__ind_uu_defval;
const MNCC__useruser_template& tr__MNCC__ALERT__ind_uu_defval = template_tr__MNCC__ALERT__ind_uu_defval;
static MNCC__progress_template template_ts__MNCC__ALERT__ind_prog_defval;
const MNCC__progress_template& ts__MNCC__ALERT__ind_prog_defval = template_ts__MNCC__ALERT__ind_prog_defval;
static CHARSTRING_template template_ts__MNCC__ALERT__ind_fac_defval;
const CHARSTRING_template& ts__MNCC__ALERT__ind_fac_defval = template_ts__MNCC__ALERT__ind_fac_defval;
static MNCC__useruser_template template_ts__MNCC__ALERT__ind_uu_defval;
const MNCC__useruser_template& ts__MNCC__ALERT__ind_uu_defval = template_ts__MNCC__ALERT__ind_uu_defval;
static INTEGER_template template_tr__MNCC__DISC__ind_call__id_defval;
const INTEGER_template& tr__MNCC__DISC__ind_call__id_defval = template_tr__MNCC__DISC__ind_call__id_defval;
static MNCC__cause_template template_tr__MNCC__DISC__ind_cause_defval;
const MNCC__cause_template& tr__MNCC__DISC__ind_cause_defval = template_tr__MNCC__DISC__ind_cause_defval;
static MNCC__progress_template template_tr__MNCC__DISC__ind_prog_defval;
const MNCC__progress_template& tr__MNCC__DISC__ind_prog_defval = template_tr__MNCC__DISC__ind_prog_defval;
static CHARSTRING_template template_tr__MNCC__DISC__ind_fac_defval;
const CHARSTRING_template& tr__MNCC__DISC__ind_fac_defval = template_tr__MNCC__DISC__ind_fac_defval;
static MNCC__useruser_template template_tr__MNCC__DISC__ind_uu_defval;
const MNCC__useruser_template& tr__MNCC__DISC__ind_uu_defval = template_tr__MNCC__DISC__ind_uu_defval;
static MNCC__progress_template template_ts__MNCC__DISC__ind_prog_defval;
const MNCC__progress_template& ts__MNCC__DISC__ind_prog_defval = template_ts__MNCC__DISC__ind_prog_defval;
static CHARSTRING_template template_ts__MNCC__DISC__ind_fac_defval;
const CHARSTRING_template& ts__MNCC__DISC__ind_fac_defval = template_ts__MNCC__DISC__ind_fac_defval;
static MNCC__useruser_template template_ts__MNCC__DISC__ind_uu_defval;
const MNCC__useruser_template& ts__MNCC__DISC__ind_uu_defval = template_ts__MNCC__DISC__ind_uu_defval;
static MNCC__progress_template template_ts__MNCC__DISC__req_prog_defval;
const MNCC__progress_template& ts__MNCC__DISC__req_prog_defval = template_ts__MNCC__DISC__req_prog_defval;
static CHARSTRING_template template_ts__MNCC__DISC__req_fac_defval;
const CHARSTRING_template& ts__MNCC__DISC__req_fac_defval = template_ts__MNCC__DISC__req_fac_defval;
static MNCC__useruser_template template_ts__MNCC__DISC__req_uu_defval;
const MNCC__useruser_template& ts__MNCC__DISC__req_uu_defval = template_ts__MNCC__DISC__req_uu_defval;
static MNCC__cause_template template_tr__MNCC__DISC__req_cause_defval;
const MNCC__cause_template& tr__MNCC__DISC__req_cause_defval = template_tr__MNCC__DISC__req_cause_defval;
static MNCC__progress_template template_tr__MNCC__DISC__req_prog_defval;
const MNCC__progress_template& tr__MNCC__DISC__req_prog_defval = template_tr__MNCC__DISC__req_prog_defval;
static CHARSTRING_template template_tr__MNCC__DISC__req_fac_defval;
const CHARSTRING_template& tr__MNCC__DISC__req_fac_defval = template_tr__MNCC__DISC__req_fac_defval;
static MNCC__useruser_template template_tr__MNCC__DISC__req_uu_defval;
const MNCC__useruser_template& tr__MNCC__DISC__req_uu_defval = template_tr__MNCC__DISC__req_uu_defval;
static INTEGER_template template_tr__MNCC__REL__ind_call__id_defval;
const INTEGER_template& tr__MNCC__REL__ind_call__id_defval = template_tr__MNCC__REL__ind_call__id_defval;
static MNCC__cause_template template_tr__MNCC__REL__ind_cause_defval;
const MNCC__cause_template& tr__MNCC__REL__ind_cause_defval = template_tr__MNCC__REL__ind_cause_defval;
static CHARSTRING_template template_tr__MNCC__REL__ind_fac_defval;
const CHARSTRING_template& tr__MNCC__REL__ind_fac_defval = template_tr__MNCC__REL__ind_fac_defval;
static MNCC__useruser_template template_tr__MNCC__REL__ind_uu_defval;
const MNCC__useruser_template& tr__MNCC__REL__ind_uu_defval = template_tr__MNCC__REL__ind_uu_defval;
static CHARSTRING_template template_ts__MNCC__REL__ind_fac_defval;
const CHARSTRING_template& ts__MNCC__REL__ind_fac_defval = template_ts__MNCC__REL__ind_fac_defval;
static MNCC__useruser_template template_ts__MNCC__REL__ind_uu_defval;
const MNCC__useruser_template& ts__MNCC__REL__ind_uu_defval = template_ts__MNCC__REL__ind_uu_defval;
static CHARSTRING_template template_ts__MNCC__REL__req_fac_defval;
const CHARSTRING_template& ts__MNCC__REL__req_fac_defval = template_ts__MNCC__REL__req_fac_defval;
static MNCC__useruser_template template_ts__MNCC__REL__req_uu_defval;
const MNCC__useruser_template& ts__MNCC__REL__req_uu_defval = template_ts__MNCC__REL__req_uu_defval;
static MNCC__cause_template template_tr__MNCC__REL__req_cause_defval;
const MNCC__cause_template& tr__MNCC__REL__req_cause_defval = template_tr__MNCC__REL__req_cause_defval;
static CHARSTRING_template template_tr__MNCC__REL__req_fac_defval;
const CHARSTRING_template& tr__MNCC__REL__req_fac_defval = template_tr__MNCC__REL__req_fac_defval;
static MNCC__useruser_template template_tr__MNCC__REL__req_uu_defval;
const MNCC__useruser_template& tr__MNCC__REL__req_uu_defval = template_tr__MNCC__REL__req_uu_defval;
static INTEGER_template template_tr__MNCC__REL__cnf_call__id_defval;
const INTEGER_template& tr__MNCC__REL__cnf_call__id_defval = template_tr__MNCC__REL__cnf_call__id_defval;
static MNCC__cause_template template_tr__MNCC__REL__cnf_cause_defval;
const MNCC__cause_template& tr__MNCC__REL__cnf_cause_defval = template_tr__MNCC__REL__cnf_cause_defval;
static CHARSTRING_template template_tr__MNCC__REL__cnf_fac_defval;
const CHARSTRING_template& tr__MNCC__REL__cnf_fac_defval = template_tr__MNCC__REL__cnf_fac_defval;
static MNCC__useruser_template template_tr__MNCC__REL__cnf_uu_defval;
const MNCC__useruser_template& tr__MNCC__REL__cnf_uu_defval = template_tr__MNCC__REL__cnf_uu_defval;
static CHARSTRING_template template_ts__MNCC__REL__cnf_fac_defval;
const CHARSTRING_template& ts__MNCC__REL__cnf_fac_defval = template_ts__MNCC__REL__cnf_fac_defval;
static MNCC__useruser_template template_ts__MNCC__REL__cnf_uu_defval;
const MNCC__useruser_template& ts__MNCC__REL__cnf_uu_defval = template_ts__MNCC__REL__cnf_uu_defval;
static INTEGER_template template_tr__MNCC__FACILITY__ind_call__id_defval;
const INTEGER_template& tr__MNCC__FACILITY__ind_call__id_defval = template_tr__MNCC__FACILITY__ind_call__id_defval;
static CHARSTRING_template template_tr__MNCC__FACILITY__ind_fac_defval;
const CHARSTRING_template& tr__MNCC__FACILITY__ind_fac_defval = template_tr__MNCC__FACILITY__ind_fac_defval;
static INTEGER_template template_tr__MNCC__START__DTMF__ind_call__id_defval;
const INTEGER_template& tr__MNCC__START__DTMF__ind_call__id_defval = template_tr__MNCC__START__DTMF__ind_call__id_defval;
static CHARSTRING_template template_tr__MNCC__START__DTMF__ind_keypad_defval;
const CHARSTRING_template& tr__MNCC__START__DTMF__ind_keypad_defval = template_tr__MNCC__START__DTMF__ind_keypad_defval;
static INTEGER_template template_tr__MNCC__STOP__DTMF__ind_call__id_defval;
const INTEGER_template& tr__MNCC__STOP__DTMF__ind_call__id_defval = template_tr__MNCC__STOP__DTMF__ind_call__id_defval;
static INTEGER_template template_tr__MNCC__MODIFY__ind_call__id_defval;
const INTEGER_template& tr__MNCC__MODIFY__ind_call__id_defval = template_tr__MNCC__MODIFY__ind_call__id_defval;
static MNCC__bearer__cap_template template_tr__MNCC__MODIFY__ind_bcap_defval;
const MNCC__bearer__cap_template& tr__MNCC__MODIFY__ind_bcap_defval = template_tr__MNCC__MODIFY__ind_bcap_defval;
static INTEGER_template template_tr__MNCC__MODIFY__cnf_call__id_defval;
const INTEGER_template& tr__MNCC__MODIFY__cnf_call__id_defval = template_tr__MNCC__MODIFY__cnf_call__id_defval;
static MNCC__bearer__cap_template template_tr__MNCC__MODIFY__cnf_bcap_defval;
const MNCC__bearer__cap_template& tr__MNCC__MODIFY__cnf_bcap_defval = template_tr__MNCC__MODIFY__cnf_bcap_defval;
static INTEGER_template template_tr__MNCC__USERINFO__ind_call__id_defval;
const INTEGER_template& tr__MNCC__USERINFO__ind_call__id_defval = template_tr__MNCC__USERINFO__ind_call__id_defval;
static MNCC__useruser_template template_tr__MNCC__USERINFO__ind_uu_defval;
const MNCC__useruser_template& tr__MNCC__USERINFO__ind_uu_defval = template_tr__MNCC__USERINFO__ind_uu_defval;
static INTEGER_template template_tr__MNCC__HOLD__ind_call__id_defval;
const INTEGER_template& tr__MNCC__HOLD__ind_call__id_defval = template_tr__MNCC__HOLD__ind_call__id_defval;
static INTEGER_template template_tr__MNCC__RETRIEVE__ind_call__id_defval;
const INTEGER_template& tr__MNCC__RETRIEVE__ind_call__id_defval = template_tr__MNCC__RETRIEVE__ind_call__id_defval;
static INTEGER_template template_tr__MNCC__RTP__CREATE_call__id_defval;
const INTEGER_template& tr__MNCC__RTP__CREATE_call__id_defval = template_tr__MNCC__RTP__CREATE_call__id_defval;
static INTEGER_template template_tr__MNCC__RTP__CONNECT_ip_defval;
const INTEGER_template& tr__MNCC__RTP__CONNECT_ip_defval = template_tr__MNCC__RTP__CONNECT_ip_defval;
static INTEGER_template template_tr__MNCC__RTP__CONNECT_rtp__port_defval;
const INTEGER_template& tr__MNCC__RTP__CONNECT_rtp__port_defval = template_tr__MNCC__RTP__CONNECT_rtp__port_defval;
static INTEGER_template template_tr__MNCC__RTP__CONNECT_pt_defval;
const INTEGER_template& tr__MNCC__RTP__CONNECT_pt_defval = template_tr__MNCC__RTP__CONNECT_pt_defval;
TTCN_Module module_object("MNCC_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_5,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

GSM48__bcap__ra::GSM48__bcap__ra()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__ra::GSM48__bcap__ra(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_ra with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__ra::GSM48__bcap__ra(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__ra::GSM48__bcap__ra(const GSM48__bcap__ra& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
enum_value = other_value.enum_value;
}

GSM48__bcap__ra& GSM48__bcap__ra::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_ra.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__ra& GSM48__bcap__ra::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__ra& GSM48__bcap__ra::operator=(const GSM48__bcap__ra& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__ra::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value == other_value;
}

boolean GSM48__bcap__ra::operator==(const GSM48__bcap__ra& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__ra::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value < other_value;
}

boolean GSM48__bcap__ra::operator<(const GSM48__bcap__ra& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__ra::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value > other_value;
}

boolean GSM48__bcap__ra::operator>(const GSM48__bcap__ra& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__ra::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__RA__NONE: return "GSM48_BCAP_RA_NONE";
case GSM48__BCAP__RA__V110__X30: return "GSM48_BCAP_RA_V110_X30";
case GSM48__BCAP__RA__X31: return "GSM48_BCAP_RA_X31";
case GSM48__BCAP__RA__OTHER: return "GSM48_BCAP_RA_OTHER";
default: return "<unknown>";
}
}

GSM48__bcap__ra::enum_type GSM48__bcap__ra::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_RA_NONE")) return GSM48__BCAP__RA__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_RA_V110_X30")) return GSM48__BCAP__RA__V110__X30;
else if (!strcmp(str_par, "GSM48_BCAP_RA_X31")) return GSM48__BCAP__RA__X31;
else if (!strcmp(str_par, "GSM48_BCAP_RA_OTHER")) return GSM48__BCAP__RA__OTHER;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__ra::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__ra::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_ra.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__ra::enum2int(const GSM48__bcap__ra& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_ra.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__ra::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_ra.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__ra::operator GSM48__bcap__ra::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return enum_value;
}

void GSM48__bcap__ra::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__ra::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_ra");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_ra.");
  }
}

void GSM48__bcap__ra::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__ra::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_ra.", enum_value);
}

void GSM48__bcap__ra::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__ra::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__ra::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__ra::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__bcap__ra_template::copy_template(const GSM48__bcap__ra_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__ra_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
}
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template()
{
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__ra::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_ra with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__ra::enum_type)other_value;
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(GSM48__bcap__ra::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(const GSM48__bcap__ra& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__ra::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra.");
single_value = other_value.enum_value;
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(const OPTIONAL<GSM48__bcap__ra>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__ra::enum_type)(const GSM48__bcap__ra&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_ra from an unbound optional field.");
}
}

GSM48__bcap__ra_template::GSM48__bcap__ra_template(const GSM48__bcap__ra_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__ra_template::~GSM48__bcap__ra_template()
{
clean_up();
}

boolean GSM48__bcap__ra_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__ra_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__ra::UNBOUND_VALUE;
}

void GSM48__bcap__ra_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(int other_value)
{
if (!GSM48__bcap__ra::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_ra.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__ra::enum_type)other_value;
return *this;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(GSM48__bcap__ra::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(const GSM48__bcap__ra& other_value)
{
if (other_value.enum_value == GSM48__bcap__ra::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_ra to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(const OPTIONAL<GSM48__bcap__ra>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__ra::enum_type)(const GSM48__bcap__ra&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
}
return *this;
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::operator=(const GSM48__bcap__ra_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__ra_template::match(GSM48__bcap__ra::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
}
return FALSE;
}

boolean GSM48__bcap__ra_template::match(const GSM48__bcap__ra& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__ra::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_ra with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__ra::enum_type GSM48__bcap__ra_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return single_value;
}

void GSM48__bcap__ra_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__ra_template[list_length];
}

GSM48__bcap__ra_template& GSM48__bcap__ra_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
return value_list.list_value[list_index];
}

void GSM48__bcap__ra_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__ra::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__ra_template::log_match(const GSM48__bcap__ra& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__ra_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
}
}

void GSM48__bcap__ra_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__ra::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__ra::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_ra.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__ra_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_ra.");
}
}

boolean GSM48__bcap__ra_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__ra_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__ra_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__ra_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__ra::enum_type enum_val = GSM48__bcap__ra::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__ra::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_ra.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_ra");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__ra_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_ra");
}

GSM48__bcap__sig__access::GSM48__bcap__sig__access()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__sig__access::GSM48__bcap__sig__access(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_sig_access with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__sig__access::GSM48__bcap__sig__access(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__sig__access::GSM48__bcap__sig__access(const GSM48__bcap__sig__access& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
enum_value = other_value.enum_value;
}

GSM48__bcap__sig__access& GSM48__bcap__sig__access::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__sig__access& GSM48__bcap__sig__access::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__sig__access& GSM48__bcap__sig__access::operator=(const GSM48__bcap__sig__access& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__sig__access::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value == other_value;
}

boolean GSM48__bcap__sig__access::operator==(const GSM48__bcap__sig__access& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__sig__access::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value < other_value;
}

boolean GSM48__bcap__sig__access::operator<(const GSM48__bcap__sig__access& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__sig__access::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value > other_value;
}

boolean GSM48__bcap__sig__access::operator>(const GSM48__bcap__sig__access& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__sig__access::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__SA__NONE: return "GSM48_BCAP_SA_NONE";
case GSM48__BCAP__SA__I440__I450: return "GSM48_BCAP_SA_I440_I450";
case GSM48__BCAP__SA__X21: return "GSM48_BCAP_SA_X21";
case GSM48__BCAP__SA__X28__DP__IN: return "GSM48_BCAP_SA_X28_DP_IN";
case GSM48__BCAP__SA__X28__DP__UN: return "GSM48_BCAP_SA_X28_DP_UN";
case GSM48__BCAP__SA__X28__NDP: return "GSM48_BCAP_SA_X28_NDP";
case GSM48__BCAP__SA__X32: return "GSM48_BCAP_SA_X32";
default: return "<unknown>";
}
}

GSM48__bcap__sig__access::enum_type GSM48__bcap__sig__access::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_SA_NONE")) return GSM48__BCAP__SA__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_SA_I440_I450")) return GSM48__BCAP__SA__I440__I450;
else if (!strcmp(str_par, "GSM48_BCAP_SA_X21")) return GSM48__BCAP__SA__X21;
else if (!strcmp(str_par, "GSM48_BCAP_SA_X28_DP_IN")) return GSM48__BCAP__SA__X28__DP__IN;
else if (!strcmp(str_par, "GSM48_BCAP_SA_X28_DP_UN")) return GSM48__BCAP__SA__X28__DP__UN;
else if (!strcmp(str_par, "GSM48_BCAP_SA_X28_NDP")) return GSM48__BCAP__SA__X28__NDP;
else if (!strcmp(str_par, "GSM48_BCAP_SA_X32")) return GSM48__BCAP__SA__X32;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__sig__access::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__sig__access::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__sig__access::enum2int(const GSM48__bcap__sig__access& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__sig__access::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__sig__access::operator GSM48__bcap__sig__access::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return enum_value;
}

void GSM48__bcap__sig__access::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__sig__access::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_sig_access");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_sig_access.");
  }
}

void GSM48__bcap__sig__access::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__sig__access::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_sig_access.", enum_value);
}

void GSM48__bcap__sig__access::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__sig__access::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__sig__access::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__sig__access::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__bcap__sig__access_template::copy_template(const GSM48__bcap__sig__access_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__sig__access_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
}
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template()
{
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__sig__access::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__sig__access::enum_type)other_value;
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(GSM48__bcap__sig__access::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(const GSM48__bcap__sig__access& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__sig__access::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
single_value = other_value.enum_value;
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(const OPTIONAL<GSM48__bcap__sig__access>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__sig__access::enum_type)(const GSM48__bcap__sig__access&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access from an unbound optional field.");
}
}

GSM48__bcap__sig__access_template::GSM48__bcap__sig__access_template(const GSM48__bcap__sig__access_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__sig__access_template::~GSM48__bcap__sig__access_template()
{
clean_up();
}

boolean GSM48__bcap__sig__access_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__sig__access_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__sig__access::UNBOUND_VALUE;
}

void GSM48__bcap__sig__access_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(int other_value)
{
if (!GSM48__bcap__sig__access::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__sig__access::enum_type)other_value;
return *this;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(GSM48__bcap__sig__access::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(const GSM48__bcap__sig__access& other_value)
{
if (other_value.enum_value == GSM48__bcap__sig__access::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_sig_access to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(const OPTIONAL<GSM48__bcap__sig__access>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__sig__access::enum_type)(const GSM48__bcap__sig__access&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
}
return *this;
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::operator=(const GSM48__bcap__sig__access_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__sig__access_template::match(GSM48__bcap__sig__access::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
}
return FALSE;
}

boolean GSM48__bcap__sig__access_template::match(const GSM48__bcap__sig__access& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__sig__access::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__sig__access::enum_type GSM48__bcap__sig__access_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return single_value;
}

void GSM48__bcap__sig__access_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__sig__access_template[list_length];
}

GSM48__bcap__sig__access_template& GSM48__bcap__sig__access_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
return value_list.list_value[list_index];
}

void GSM48__bcap__sig__access_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__sig__access::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__sig__access_template::log_match(const GSM48__bcap__sig__access& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__sig__access_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
}
}

void GSM48__bcap__sig__access_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__sig__access::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__sig__access::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__sig__access_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_sig_access.");
}
}

boolean GSM48__bcap__sig__access_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__sig__access_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__sig__access_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__sig__access_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__sig__access::enum_type enum_val = GSM48__bcap__sig__access::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__sig__access::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_sig_access.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_sig_access");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__sig__access_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_sig_access");
}

GSM48__bcap__user__rate::GSM48__bcap__user__rate()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__user__rate::GSM48__bcap__user__rate(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_user_rate with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__user__rate::GSM48__bcap__user__rate(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__user__rate::GSM48__bcap__user__rate(const GSM48__bcap__user__rate& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
enum_value = other_value.enum_value;
}

GSM48__bcap__user__rate& GSM48__bcap__user__rate::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__user__rate& GSM48__bcap__user__rate::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__user__rate& GSM48__bcap__user__rate::operator=(const GSM48__bcap__user__rate& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__user__rate::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value == other_value;
}

boolean GSM48__bcap__user__rate::operator==(const GSM48__bcap__user__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__user__rate::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value < other_value;
}

boolean GSM48__bcap__user__rate::operator<(const GSM48__bcap__user__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__user__rate::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value > other_value;
}

boolean GSM48__bcap__user__rate::operator>(const GSM48__bcap__user__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__user__rate::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__UR__NONE: return "GSM48_BCAP_UR_NONE";
case GSM48__BCAP__UR__300: return "GSM48_BCAP_UR_300";
case GSM48__BCAP__UR__1200: return "GSM48_BCAP_UR_1200";
case GSM48__BCAP__UR__2400: return "GSM48_BCAP_UR_2400";
case GSM48__BCAP__UR__4800: return "GSM48_BCAP_UR_4800";
case GSM48__BCAP__UR__9600: return "GSM48_BCAP_UR_9600";
case GSM48__BCAP__UR__12000: return "GSM48_BCAP_UR_12000";
case GSM48__BCAP__UR__1200__75: return "GSM48_BCAP_UR_1200_75";
default: return "<unknown>";
}
}

GSM48__bcap__user__rate::enum_type GSM48__bcap__user__rate::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_UR_NONE")) return GSM48__BCAP__UR__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_UR_300")) return GSM48__BCAP__UR__300;
else if (!strcmp(str_par, "GSM48_BCAP_UR_1200")) return GSM48__BCAP__UR__1200;
else if (!strcmp(str_par, "GSM48_BCAP_UR_2400")) return GSM48__BCAP__UR__2400;
else if (!strcmp(str_par, "GSM48_BCAP_UR_4800")) return GSM48__BCAP__UR__4800;
else if (!strcmp(str_par, "GSM48_BCAP_UR_9600")) return GSM48__BCAP__UR__9600;
else if (!strcmp(str_par, "GSM48_BCAP_UR_12000")) return GSM48__BCAP__UR__12000;
else if (!strcmp(str_par, "GSM48_BCAP_UR_1200_75")) return GSM48__BCAP__UR__1200__75;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__user__rate::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__user__rate::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__user__rate::enum2int(const GSM48__bcap__user__rate& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__user__rate::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__user__rate::operator GSM48__bcap__user__rate::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return enum_value;
}

void GSM48__bcap__user__rate::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__user__rate::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_user_rate");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_user_rate.");
  }
}

void GSM48__bcap__user__rate::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__user__rate::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_user_rate.", enum_value);
}

void GSM48__bcap__user__rate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__user__rate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__user__rate::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__user__rate::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

void GSM48__bcap__user__rate_template::copy_template(const GSM48__bcap__user__rate_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__user__rate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
}
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template()
{
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__user__rate::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__user__rate::enum_type)other_value;
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(GSM48__bcap__user__rate::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(const GSM48__bcap__user__rate& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__user__rate::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
single_value = other_value.enum_value;
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(const OPTIONAL<GSM48__bcap__user__rate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__user__rate::enum_type)(const GSM48__bcap__user__rate&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate from an unbound optional field.");
}
}

GSM48__bcap__user__rate_template::GSM48__bcap__user__rate_template(const GSM48__bcap__user__rate_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__user__rate_template::~GSM48__bcap__user__rate_template()
{
clean_up();
}

boolean GSM48__bcap__user__rate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__user__rate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__user__rate::UNBOUND_VALUE;
}

void GSM48__bcap__user__rate_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(int other_value)
{
if (!GSM48__bcap__user__rate::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__user__rate::enum_type)other_value;
return *this;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(GSM48__bcap__user__rate::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(const GSM48__bcap__user__rate& other_value)
{
if (other_value.enum_value == GSM48__bcap__user__rate::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_user_rate to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(const OPTIONAL<GSM48__bcap__user__rate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__user__rate::enum_type)(const GSM48__bcap__user__rate&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
}
return *this;
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::operator=(const GSM48__bcap__user__rate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__user__rate_template::match(GSM48__bcap__user__rate::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
}
return FALSE;
}

boolean GSM48__bcap__user__rate_template::match(const GSM48__bcap__user__rate& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__user__rate::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__user__rate::enum_type GSM48__bcap__user__rate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return single_value;
}

void GSM48__bcap__user__rate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__user__rate_template[list_length];
}

GSM48__bcap__user__rate_template& GSM48__bcap__user__rate_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
return value_list.list_value[list_index];
}

void GSM48__bcap__user__rate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__user__rate::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__user__rate_template::log_match(const GSM48__bcap__user__rate& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__user__rate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
}
}

void GSM48__bcap__user__rate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__user__rate::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__user__rate::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__user__rate_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_user_rate.");
}
}

boolean GSM48__bcap__user__rate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__user__rate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__user__rate_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__user__rate_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__user__rate::enum_type enum_val = GSM48__bcap__user__rate::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__user__rate::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_user_rate.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_user_rate");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__user__rate_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_user_rate");
}

GSM48__bcap__parity::GSM48__bcap__parity()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__parity::GSM48__bcap__parity(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_parity with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__parity::GSM48__bcap__parity(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__parity::GSM48__bcap__parity(const GSM48__bcap__parity& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
enum_value = other_value.enum_value;
}

GSM48__bcap__parity& GSM48__bcap__parity::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_parity.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__parity& GSM48__bcap__parity::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__parity& GSM48__bcap__parity::operator=(const GSM48__bcap__parity& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__parity::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value == other_value;
}

boolean GSM48__bcap__parity::operator==(const GSM48__bcap__parity& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__parity::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value < other_value;
}

boolean GSM48__bcap__parity::operator<(const GSM48__bcap__parity& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__parity::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value > other_value;
}

boolean GSM48__bcap__parity::operator>(const GSM48__bcap__parity& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__parity::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__PAR__ODD: return "GSM48_BCAP_PAR_ODD";
case GSM48__BCAP__PAR__EVEN: return "GSM48_BCAP_PAR_EVEN";
case GSM48__BCAP__PAR__NONE: return "GSM48_BCAP_PAR_NONE";
case GSM48__BCAP__PAR__ZERO: return "GSM48_BCAP_PAR_ZERO";
case GSM48__BCAP__PAR__ONE: return "GSM48_BCAP_PAR_ONE";
default: return "<unknown>";
}
}

GSM48__bcap__parity::enum_type GSM48__bcap__parity::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_PAR_ODD")) return GSM48__BCAP__PAR__ODD;
else if (!strcmp(str_par, "GSM48_BCAP_PAR_EVEN")) return GSM48__BCAP__PAR__EVEN;
else if (!strcmp(str_par, "GSM48_BCAP_PAR_NONE")) return GSM48__BCAP__PAR__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_PAR_ZERO")) return GSM48__BCAP__PAR__ZERO;
else if (!strcmp(str_par, "GSM48_BCAP_PAR_ONE")) return GSM48__BCAP__PAR__ONE;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__parity::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 2:
case 3:
case 4:
case 5:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__parity::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_parity.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__parity::enum2int(const GSM48__bcap__parity& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_parity.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__parity::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_parity.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__parity::operator GSM48__bcap__parity::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return enum_value;
}

void GSM48__bcap__parity::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__parity::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_parity");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_parity.");
  }
}

void GSM48__bcap__parity::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__parity::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_parity.", enum_value);
}

void GSM48__bcap__parity::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__parity::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__parity::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__parity::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__bcap__parity_template::copy_template(const GSM48__bcap__parity_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__parity_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
}
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template()
{
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__parity::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_parity with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__parity::enum_type)other_value;
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(GSM48__bcap__parity::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(const GSM48__bcap__parity& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__parity::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity.");
single_value = other_value.enum_value;
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(const OPTIONAL<GSM48__bcap__parity>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__parity::enum_type)(const GSM48__bcap__parity&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_parity from an unbound optional field.");
}
}

GSM48__bcap__parity_template::GSM48__bcap__parity_template(const GSM48__bcap__parity_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__parity_template::~GSM48__bcap__parity_template()
{
clean_up();
}

boolean GSM48__bcap__parity_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__parity_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__parity::UNBOUND_VALUE;
}

void GSM48__bcap__parity_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(int other_value)
{
if (!GSM48__bcap__parity::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_parity.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__parity::enum_type)other_value;
return *this;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(GSM48__bcap__parity::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(const GSM48__bcap__parity& other_value)
{
if (other_value.enum_value == GSM48__bcap__parity::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_parity to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(const OPTIONAL<GSM48__bcap__parity>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__parity::enum_type)(const GSM48__bcap__parity&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
}
return *this;
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::operator=(const GSM48__bcap__parity_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__parity_template::match(GSM48__bcap__parity::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
}
return FALSE;
}

boolean GSM48__bcap__parity_template::match(const GSM48__bcap__parity& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__parity::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_parity with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__parity::enum_type GSM48__bcap__parity_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return single_value;
}

void GSM48__bcap__parity_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__parity_template[list_length];
}

GSM48__bcap__parity_template& GSM48__bcap__parity_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
return value_list.list_value[list_index];
}

void GSM48__bcap__parity_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__parity::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__parity_template::log_match(const GSM48__bcap__parity& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__parity_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
}
}

void GSM48__bcap__parity_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__parity::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__parity::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_parity.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__parity_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_parity.");
}
}

boolean GSM48__bcap__parity_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__parity_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__parity_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__parity_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__parity::enum_type enum_val = GSM48__bcap__parity::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__parity::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_parity.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_parity");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__parity_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_parity");
}

GSM48__bcap__interm__rate::GSM48__bcap__interm__rate()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__interm__rate::GSM48__bcap__interm__rate(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_interm_rate with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__interm__rate::GSM48__bcap__interm__rate(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__interm__rate::GSM48__bcap__interm__rate(const GSM48__bcap__interm__rate& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
enum_value = other_value.enum_value;
}

GSM48__bcap__interm__rate& GSM48__bcap__interm__rate::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__interm__rate& GSM48__bcap__interm__rate::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__interm__rate& GSM48__bcap__interm__rate::operator=(const GSM48__bcap__interm__rate& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__interm__rate::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value == other_value;
}

boolean GSM48__bcap__interm__rate::operator==(const GSM48__bcap__interm__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__interm__rate::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value < other_value;
}

boolean GSM48__bcap__interm__rate::operator<(const GSM48__bcap__interm__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__interm__rate::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value > other_value;
}

boolean GSM48__bcap__interm__rate::operator>(const GSM48__bcap__interm__rate& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__interm__rate::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__IR__NONE: return "GSM48_BCAP_IR_NONE";
case GSM48__BCAP__IR__8k: return "GSM48_BCAP_IR_8k";
case GSM48__BCAP__IR__16k: return "GSM48_BCAP_IR_16k";
default: return "<unknown>";
}
}

GSM48__bcap__interm__rate::enum_type GSM48__bcap__interm__rate::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_IR_NONE")) return GSM48__BCAP__IR__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_IR_8k")) return GSM48__BCAP__IR__8k;
else if (!strcmp(str_par, "GSM48_BCAP_IR_16k")) return GSM48__BCAP__IR__16k;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__interm__rate::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__interm__rate::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__interm__rate::enum2int(const GSM48__bcap__interm__rate& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__interm__rate::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__interm__rate::operator GSM48__bcap__interm__rate::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return enum_value;
}

void GSM48__bcap__interm__rate::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__interm__rate::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_interm_rate");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_interm_rate.");
  }
}

void GSM48__bcap__interm__rate::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__interm__rate::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", enum_value);
}

void GSM48__bcap__interm__rate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__interm__rate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__interm__rate::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__interm__rate::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

void GSM48__bcap__interm__rate_template::copy_template(const GSM48__bcap__interm__rate_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__interm__rate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
}
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template()
{
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__interm__rate::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__interm__rate::enum_type)other_value;
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(GSM48__bcap__interm__rate::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(const GSM48__bcap__interm__rate& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__interm__rate::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
single_value = other_value.enum_value;
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(const OPTIONAL<GSM48__bcap__interm__rate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__interm__rate::enum_type)(const GSM48__bcap__interm__rate&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate from an unbound optional field.");
}
}

GSM48__bcap__interm__rate_template::GSM48__bcap__interm__rate_template(const GSM48__bcap__interm__rate_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__interm__rate_template::~GSM48__bcap__interm__rate_template()
{
clean_up();
}

boolean GSM48__bcap__interm__rate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__interm__rate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__interm__rate::UNBOUND_VALUE;
}

void GSM48__bcap__interm__rate_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(int other_value)
{
if (!GSM48__bcap__interm__rate::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__interm__rate::enum_type)other_value;
return *this;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(GSM48__bcap__interm__rate::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(const GSM48__bcap__interm__rate& other_value)
{
if (other_value.enum_value == GSM48__bcap__interm__rate::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_interm_rate to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(const OPTIONAL<GSM48__bcap__interm__rate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__interm__rate::enum_type)(const GSM48__bcap__interm__rate&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
}
return *this;
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::operator=(const GSM48__bcap__interm__rate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__interm__rate_template::match(GSM48__bcap__interm__rate::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
}
return FALSE;
}

boolean GSM48__bcap__interm__rate_template::match(const GSM48__bcap__interm__rate& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__interm__rate::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__interm__rate::enum_type GSM48__bcap__interm__rate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return single_value;
}

void GSM48__bcap__interm__rate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__interm__rate_template[list_length];
}

GSM48__bcap__interm__rate_template& GSM48__bcap__interm__rate_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
return value_list.list_value[list_index];
}

void GSM48__bcap__interm__rate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__interm__rate::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__interm__rate_template::log_match(const GSM48__bcap__interm__rate& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__interm__rate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
}
}

void GSM48__bcap__interm__rate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__interm__rate::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__interm__rate::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__interm__rate_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_interm_rate.");
}
}

boolean GSM48__bcap__interm__rate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__interm__rate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__interm__rate_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__interm__rate_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__interm__rate::enum_type enum_val = GSM48__bcap__interm__rate::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__interm__rate::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_interm_rate.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_interm_rate");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__interm__rate_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_interm_rate");
}

GSM48__bcap__transp::GSM48__bcap__transp()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__transp::GSM48__bcap__transp(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_transp with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__transp::GSM48__bcap__transp(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__transp::GSM48__bcap__transp(const GSM48__bcap__transp& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
enum_value = other_value.enum_value;
}

GSM48__bcap__transp& GSM48__bcap__transp::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_transp.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__transp& GSM48__bcap__transp::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__transp& GSM48__bcap__transp::operator=(const GSM48__bcap__transp& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__transp::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value == other_value;
}

boolean GSM48__bcap__transp::operator==(const GSM48__bcap__transp& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__transp::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value < other_value;
}

boolean GSM48__bcap__transp::operator<(const GSM48__bcap__transp& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__transp::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value > other_value;
}

boolean GSM48__bcap__transp::operator>(const GSM48__bcap__transp& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__transp::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__TR__TRANSP: return "GSM48_BCAP_TR_TRANSP";
case GSM48__BCAP__TR__RLP: return "GSM48_BCAP_TR_RLP";
case GSM48__BCAP__TR__TR__PREF: return "GSM48_BCAP_TR_TR_PREF";
case GSM48__BCAP__TR__RLP__PREF: return "GSM48_BCAP_TR_RLP_PREF";
default: return "<unknown>";
}
}

GSM48__bcap__transp::enum_type GSM48__bcap__transp::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_TR_TRANSP")) return GSM48__BCAP__TR__TRANSP;
else if (!strcmp(str_par, "GSM48_BCAP_TR_RLP")) return GSM48__BCAP__TR__RLP;
else if (!strcmp(str_par, "GSM48_BCAP_TR_TR_PREF")) return GSM48__BCAP__TR__TR__PREF;
else if (!strcmp(str_par, "GSM48_BCAP_TR_RLP_PREF")) return GSM48__BCAP__TR__RLP__PREF;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__transp::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__transp::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_transp.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__transp::enum2int(const GSM48__bcap__transp& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_transp.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__transp::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_transp.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__transp::operator GSM48__bcap__transp::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return enum_value;
}

void GSM48__bcap__transp::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__transp::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_transp");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_transp.");
  }
}

void GSM48__bcap__transp::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__transp::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_transp.", enum_value);
}

void GSM48__bcap__transp::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__transp::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__transp::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__transp::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__bcap__transp_template::copy_template(const GSM48__bcap__transp_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__transp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
}
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template()
{
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__transp::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_transp with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__transp::enum_type)other_value;
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(GSM48__bcap__transp::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(const GSM48__bcap__transp& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__transp::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp.");
single_value = other_value.enum_value;
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(const OPTIONAL<GSM48__bcap__transp>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__transp::enum_type)(const GSM48__bcap__transp&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_transp from an unbound optional field.");
}
}

GSM48__bcap__transp_template::GSM48__bcap__transp_template(const GSM48__bcap__transp_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__transp_template::~GSM48__bcap__transp_template()
{
clean_up();
}

boolean GSM48__bcap__transp_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__transp_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__transp::UNBOUND_VALUE;
}

void GSM48__bcap__transp_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(int other_value)
{
if (!GSM48__bcap__transp::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_transp.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__transp::enum_type)other_value;
return *this;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(GSM48__bcap__transp::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(const GSM48__bcap__transp& other_value)
{
if (other_value.enum_value == GSM48__bcap__transp::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_transp to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(const OPTIONAL<GSM48__bcap__transp>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__transp::enum_type)(const GSM48__bcap__transp&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
}
return *this;
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::operator=(const GSM48__bcap__transp_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__transp_template::match(GSM48__bcap__transp::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
}
return FALSE;
}

boolean GSM48__bcap__transp_template::match(const GSM48__bcap__transp& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__transp::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_transp with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__transp::enum_type GSM48__bcap__transp_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return single_value;
}

void GSM48__bcap__transp_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__transp_template[list_length];
}

GSM48__bcap__transp_template& GSM48__bcap__transp_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
return value_list.list_value[list_index];
}

void GSM48__bcap__transp_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__transp::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__transp_template::log_match(const GSM48__bcap__transp& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__transp_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
}
}

void GSM48__bcap__transp_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__transp::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__transp::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_transp.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__transp_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_transp.");
}
}

boolean GSM48__bcap__transp_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__transp_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__transp_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__transp_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__transp::enum_type enum_val = GSM48__bcap__transp::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__transp::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_transp.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_transp");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__transp_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_transp");
}

GSM48__bcap__modem__type::GSM48__bcap__modem__type()
{
enum_value = UNBOUND_VALUE;
}

GSM48__bcap__modem__type::GSM48__bcap__modem__type(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_bcap_modem_type with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__bcap__modem__type::GSM48__bcap__modem__type(enum_type other_value)
{
enum_value = other_value;
}

GSM48__bcap__modem__type::GSM48__bcap__modem__type(const GSM48__bcap__modem__type& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
enum_value = other_value.enum_value;
}

GSM48__bcap__modem__type& GSM48__bcap__modem__type::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__bcap__modem__type& GSM48__bcap__modem__type::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__bcap__modem__type& GSM48__bcap__modem__type::operator=(const GSM48__bcap__modem__type& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__bcap__modem__type::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value == other_value;
}

boolean GSM48__bcap__modem__type::operator==(const GSM48__bcap__modem__type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value == other_value.enum_value;
}

boolean GSM48__bcap__modem__type::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value < other_value;
}

boolean GSM48__bcap__modem__type::operator<(const GSM48__bcap__modem__type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value < other_value.enum_value;
}

boolean GSM48__bcap__modem__type::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value > other_value;
}

boolean GSM48__bcap__modem__type::operator>(const GSM48__bcap__modem__type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value > other_value.enum_value;
}

const char *GSM48__bcap__modem__type::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__BCAP__MT__NONE: return "GSM48_BCAP_MT_NONE";
case GSM48__BCAP__MT__V21: return "GSM48_BCAP_MT_V21";
case GSM48__BCAP__MT__V22: return "GSM48_BCAP_MT_V22";
case GSM48__BCAP__MT__V22bis: return "GSM48_BCAP_MT_V22bis";
case GSM48__BCAP__MT__V23: return "GSM48_BCAP_MT_V23";
case GSM48__BCAP__MT__V26ter: return "GSM48_BCAP_MT_V26ter";
case GSM48__BCAP__MT__V32: return "GSM48_BCAP_MT_V32";
case GSM48__BCAP__MT__UNDEF: return "GSM48_BCAP_MT_UNDEF";
case GSM48__BCAP__MT__AUTO__1: return "GSM48_BCAP_MT_AUTO_1";
default: return "<unknown>";
}
}

GSM48__bcap__modem__type::enum_type GSM48__bcap__modem__type::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_BCAP_MT_NONE")) return GSM48__BCAP__MT__NONE;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V21")) return GSM48__BCAP__MT__V21;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V22")) return GSM48__BCAP__MT__V22;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V22bis")) return GSM48__BCAP__MT__V22bis;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V23")) return GSM48__BCAP__MT__V23;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V26ter")) return GSM48__BCAP__MT__V26ter;
else if (!strcmp(str_par, "GSM48_BCAP_MT_V32")) return GSM48__BCAP__MT__V32;
else if (!strcmp(str_par, "GSM48_BCAP_MT_UNDEF")) return GSM48__BCAP__MT__UNDEF;
else if (!strcmp(str_par, "GSM48_BCAP_MT_AUTO_1")) return GSM48__BCAP__MT__AUTO__1;
else return UNKNOWN_VALUE;
}

boolean GSM48__bcap__modem__type::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
return TRUE;
default:
return FALSE;
}
}

int GSM48__bcap__modem__type::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__bcap__modem__type::enum2int(const GSM48__bcap__modem__type& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__bcap__modem__type::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__bcap__modem__type::operator GSM48__bcap__modem__type::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return enum_value;
}

void GSM48__bcap__modem__type::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__bcap__modem__type::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_bcap_modem_type");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_modem_type.");
  }
}

void GSM48__bcap__modem__type::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
text_buf.push_int(enum_value);
}

void GSM48__bcap__modem__type::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_bcap_modem_type.", enum_value);
}

void GSM48__bcap__modem__type::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__bcap__modem__type::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__bcap__modem__type::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__bcap__modem__type::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

void GSM48__bcap__modem__type_template::copy_template(const GSM48__bcap__modem__type_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__bcap__modem__type_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
}
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template()
{
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__bcap__modem__type::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type with unknown numeric value %d.", other_value);
single_value = (GSM48__bcap__modem__type::enum_type)other_value;
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(GSM48__bcap__modem__type::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(const GSM48__bcap__modem__type& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__bcap__modem__type::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
single_value = other_value.enum_value;
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(const OPTIONAL<GSM48__bcap__modem__type>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__modem__type::enum_type)(const GSM48__bcap__modem__type&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type from an unbound optional field.");
}
}

GSM48__bcap__modem__type_template::GSM48__bcap__modem__type_template(const GSM48__bcap__modem__type_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__bcap__modem__type_template::~GSM48__bcap__modem__type_template()
{
clean_up();
}

boolean GSM48__bcap__modem__type_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__bcap__modem__type_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__bcap__modem__type::UNBOUND_VALUE;
}

void GSM48__bcap__modem__type_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(int other_value)
{
if (!GSM48__bcap__modem__type::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__modem__type::enum_type)other_value;
return *this;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(GSM48__bcap__modem__type::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(const GSM48__bcap__modem__type& other_value)
{
if (other_value.enum_value == GSM48__bcap__modem__type::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_bcap_modem_type to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(const OPTIONAL<GSM48__bcap__modem__type>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__bcap__modem__type::enum_type)(const GSM48__bcap__modem__type&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
}
return *this;
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::operator=(const GSM48__bcap__modem__type_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__bcap__modem__type_template::match(GSM48__bcap__modem__type::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
}
return FALSE;
}

boolean GSM48__bcap__modem__type_template::match(const GSM48__bcap__modem__type& other_value, boolean) const
{
if (other_value.enum_value == GSM48__bcap__modem__type::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type with an unbound value.");
return match(other_value.enum_value);
}

GSM48__bcap__modem__type::enum_type GSM48__bcap__modem__type_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return single_value;
}

void GSM48__bcap__modem__type_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__bcap__modem__type_template[list_length];
}

GSM48__bcap__modem__type_template& GSM48__bcap__modem__type_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
return value_list.list_value[list_index];
}

void GSM48__bcap__modem__type_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__bcap__modem__type::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__bcap__modem__type_template::log_match(const GSM48__bcap__modem__type& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__bcap__modem__type_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
}
}

void GSM48__bcap__modem__type_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__bcap__modem__type::enum_type)text_buf.pull_int().get_val();
if (!GSM48__bcap__modem__type::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__bcap__modem__type_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_bcap_modem_type.");
}
}

boolean GSM48__bcap__modem__type_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__bcap__modem__type_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__bcap__modem__type_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__bcap__modem__type_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__bcap__modem__type::enum_type enum_val = GSM48__bcap__modem__type::str_to_enum(m_p->get_enumerated());
    if (!GSM48__bcap__modem__type::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_bcap_modem_type.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_bcap_modem_type");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__bcap__modem__type_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_bcap_modem_type");
}

MNCC__MsgType::MNCC__MsgType()
{
enum_value = UNBOUND_VALUE;
}

MNCC__MsgType::MNCC__MsgType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.MNCC_MsgType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

MNCC__MsgType::MNCC__MsgType(enum_type other_value)
{
enum_value = other_value;
}

MNCC__MsgType::MNCC__MsgType(const MNCC__MsgType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
enum_value = other_value.enum_value;
}

MNCC__MsgType& MNCC__MsgType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.MNCC_MsgType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

MNCC__MsgType& MNCC__MsgType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

MNCC__MsgType& MNCC__MsgType::operator=(const MNCC__MsgType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
enum_value = other_value.enum_value;
return *this;
}

boolean MNCC__MsgType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value == other_value;
}

boolean MNCC__MsgType::operator==(const MNCC__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value == other_value.enum_value;
}

boolean MNCC__MsgType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value < other_value;
}

boolean MNCC__MsgType::operator<(const MNCC__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value < other_value.enum_value;
}

boolean MNCC__MsgType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value > other_value;
}

boolean MNCC__MsgType::operator>(const MNCC__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value > other_value.enum_value;
}

const char *MNCC__MsgType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case MNCC__SETUP__REQ: return "MNCC_SETUP_REQ";
case MNCC__SETUP__IND: return "MNCC_SETUP_IND";
case MNCC__SETUP__RSP: return "MNCC_SETUP_RSP";
case MNCC__SETUP__CNF: return "MNCC_SETUP_CNF";
case MNCC__SETUP__COMPL__REQ: return "MNCC_SETUP_COMPL_REQ";
case MNCC__SETUP__COMPL__IND: return "MNCC_SETUP_COMPL_IND";
case MNCC__CALL__CONF__IND: return "MNCC_CALL_CONF_IND";
case MNCC__CALL__PROC__REQ: return "MNCC_CALL_PROC_REQ";
case MNCC__PROGRESS__REQ: return "MNCC_PROGRESS_REQ";
case MNCC__ALERT__REQ: return "MNCC_ALERT_REQ";
case MNCC__ALERT__IND: return "MNCC_ALERT_IND";
case MNCC__NOTIFY__REQ: return "MNCC_NOTIFY_REQ";
case MNCC__NOTIFY__IND: return "MNCC_NOTIFY_IND";
case MNCC__DISC__REQ: return "MNCC_DISC_REQ";
case MNCC__DISC__IND: return "MNCC_DISC_IND";
case MNCC__REL__REQ: return "MNCC_REL_REQ";
case MNCC__REL__IND: return "MNCC_REL_IND";
case MNCC__REL__CNF: return "MNCC_REL_CNF";
case MNCC__FACILITY__REQ: return "MNCC_FACILITY_REQ";
case MNCC__FACILITY__IND: return "MNCC_FACILITY_IND";
case MNCC__START__DTMF__IND: return "MNCC_START_DTMF_IND";
case MNCC__START__DTMF__RSP: return "MNCC_START_DTMF_RSP";
case MNCC__START__DTMF__REJ: return "MNCC_START_DTMF_REJ";
case MNCC__STOP__DTMF__IND: return "MNCC_STOP_DTMF_IND";
case MNCC__STOP__DTMF__RSP: return "MNCC_STOP_DTMF_RSP";
case MNCC__MODIFY__REQ: return "MNCC_MODIFY_REQ";
case MNCC__MODIFY__IND: return "MNCC_MODIFY_IND";
case MNCC__MODIFY__RSP: return "MNCC_MODIFY_RSP";
case MNCC__MODIFY__CNF: return "MNCC_MODIFY_CNF";
case MNCC__MODIFY__REJ: return "MNCC_MODIFY_REJ";
case MNCC__HOLD__IND: return "MNCC_HOLD_IND";
case MNCC__HOLD__CNF: return "MNCC_HOLD_CNF";
case MNCC__HOLD__REJ: return "MNCC_HOLD_REJ";
case MNCC__RETRIEVE__IND: return "MNCC_RETRIEVE_IND";
case MNCC__RETRIEVE__CNF: return "MNCC_RETRIEVE_CNF";
case MNCC__RETRIEVE__REJ: return "MNCC_RETRIEVE_REJ";
case MNCC__USERINFO__REQ: return "MNCC_USERINFO_REQ";
case MNCC__USERINFO__IND: return "MNCC_USERINFO_IND";
case MNCC__REJ__REQ: return "MNCC_REJ_REQ";
case MNCC__REJ__IND: return "MNCC_REJ_IND";
case MNCC__PROGRESS__IND: return "MNCC_PROGRESS_IND";
case MNCC__CALL__PROC__IND: return "MNCC_CALL_PROC_IND";
case MNCC__CALL__CONF__REQ: return "MNCC_CALL_CONF_REQ";
case MNCC__START__DTMF__REQ: return "MNCC_START_DTMF_REQ";
case MNCC__STOP__DTMF__REQ: return "MNCC_STOP_DTMF_REQ";
case MNCC__HOLD__REQ: return "MNCC_HOLD_REQ";
case MNCC__RETRIEVE__REQ: return "MNCC_RETRIEVE_REQ";
case MNCC__BRIDGE: return "MNCC_BRIDGE";
case MNCC__FRAME__RECV: return "MNCC_FRAME_RECV";
case MNCC__FRAME__DROP: return "MNCC_FRAME_DROP";
case MNCC__LCHAN__MODIFY: return "MNCC_LCHAN_MODIFY";
case MNCC__RTP__CREATE: return "MNCC_RTP_CREATE";
case MNCC__RTP__CONNECT: return "MNCC_RTP_CONNECT";
case MNCC__RTP__FREE: return "MNCC_RTP_FREE";
case GSM__TCHF__FRAME: return "GSM_TCHF_FRAME";
case GSM__TCHF__FRAME__EFR: return "GSM_TCHF_FRAME_EFR";
case GSM__TCHH__FRAME: return "GSM_TCHH_FRAME";
case GSM__TCH__FRAME__AMR: return "GSM_TCH_FRAME_AMR";
case GSM__BAD__FRAME: return "GSM_BAD_FRAME";
case MNCC__SOCKET__HELLO: return "MNCC_SOCKET_HELLO";
default: return "<unknown>";
}
}

MNCC__MsgType::enum_type MNCC__MsgType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "MNCC_SETUP_REQ")) return MNCC__SETUP__REQ;
else if (!strcmp(str_par, "MNCC_SETUP_IND")) return MNCC__SETUP__IND;
else if (!strcmp(str_par, "MNCC_SETUP_RSP")) return MNCC__SETUP__RSP;
else if (!strcmp(str_par, "MNCC_SETUP_CNF")) return MNCC__SETUP__CNF;
else if (!strcmp(str_par, "MNCC_SETUP_COMPL_REQ")) return MNCC__SETUP__COMPL__REQ;
else if (!strcmp(str_par, "MNCC_SETUP_COMPL_IND")) return MNCC__SETUP__COMPL__IND;
else if (!strcmp(str_par, "MNCC_CALL_CONF_IND")) return MNCC__CALL__CONF__IND;
else if (!strcmp(str_par, "MNCC_CALL_PROC_REQ")) return MNCC__CALL__PROC__REQ;
else if (!strcmp(str_par, "MNCC_PROGRESS_REQ")) return MNCC__PROGRESS__REQ;
else if (!strcmp(str_par, "MNCC_ALERT_REQ")) return MNCC__ALERT__REQ;
else if (!strcmp(str_par, "MNCC_ALERT_IND")) return MNCC__ALERT__IND;
else if (!strcmp(str_par, "MNCC_NOTIFY_REQ")) return MNCC__NOTIFY__REQ;
else if (!strcmp(str_par, "MNCC_NOTIFY_IND")) return MNCC__NOTIFY__IND;
else if (!strcmp(str_par, "MNCC_DISC_REQ")) return MNCC__DISC__REQ;
else if (!strcmp(str_par, "MNCC_DISC_IND")) return MNCC__DISC__IND;
else if (!strcmp(str_par, "MNCC_REL_REQ")) return MNCC__REL__REQ;
else if (!strcmp(str_par, "MNCC_REL_IND")) return MNCC__REL__IND;
else if (!strcmp(str_par, "MNCC_REL_CNF")) return MNCC__REL__CNF;
else if (!strcmp(str_par, "MNCC_FACILITY_REQ")) return MNCC__FACILITY__REQ;
else if (!strcmp(str_par, "MNCC_FACILITY_IND")) return MNCC__FACILITY__IND;
else if (!strcmp(str_par, "MNCC_START_DTMF_IND")) return MNCC__START__DTMF__IND;
else if (!strcmp(str_par, "MNCC_START_DTMF_RSP")) return MNCC__START__DTMF__RSP;
else if (!strcmp(str_par, "MNCC_START_DTMF_REJ")) return MNCC__START__DTMF__REJ;
else if (!strcmp(str_par, "MNCC_STOP_DTMF_IND")) return MNCC__STOP__DTMF__IND;
else if (!strcmp(str_par, "MNCC_STOP_DTMF_RSP")) return MNCC__STOP__DTMF__RSP;
else if (!strcmp(str_par, "MNCC_MODIFY_REQ")) return MNCC__MODIFY__REQ;
else if (!strcmp(str_par, "MNCC_MODIFY_IND")) return MNCC__MODIFY__IND;
else if (!strcmp(str_par, "MNCC_MODIFY_RSP")) return MNCC__MODIFY__RSP;
else if (!strcmp(str_par, "MNCC_MODIFY_CNF")) return MNCC__MODIFY__CNF;
else if (!strcmp(str_par, "MNCC_MODIFY_REJ")) return MNCC__MODIFY__REJ;
else if (!strcmp(str_par, "MNCC_HOLD_IND")) return MNCC__HOLD__IND;
else if (!strcmp(str_par, "MNCC_HOLD_CNF")) return MNCC__HOLD__CNF;
else if (!strcmp(str_par, "MNCC_HOLD_REJ")) return MNCC__HOLD__REJ;
else if (!strcmp(str_par, "MNCC_RETRIEVE_IND")) return MNCC__RETRIEVE__IND;
else if (!strcmp(str_par, "MNCC_RETRIEVE_CNF")) return MNCC__RETRIEVE__CNF;
else if (!strcmp(str_par, "MNCC_RETRIEVE_REJ")) return MNCC__RETRIEVE__REJ;
else if (!strcmp(str_par, "MNCC_USERINFO_REQ")) return MNCC__USERINFO__REQ;
else if (!strcmp(str_par, "MNCC_USERINFO_IND")) return MNCC__USERINFO__IND;
else if (!strcmp(str_par, "MNCC_REJ_REQ")) return MNCC__REJ__REQ;
else if (!strcmp(str_par, "MNCC_REJ_IND")) return MNCC__REJ__IND;
else if (!strcmp(str_par, "MNCC_PROGRESS_IND")) return MNCC__PROGRESS__IND;
else if (!strcmp(str_par, "MNCC_CALL_PROC_IND")) return MNCC__CALL__PROC__IND;
else if (!strcmp(str_par, "MNCC_CALL_CONF_REQ")) return MNCC__CALL__CONF__REQ;
else if (!strcmp(str_par, "MNCC_START_DTMF_REQ")) return MNCC__START__DTMF__REQ;
else if (!strcmp(str_par, "MNCC_STOP_DTMF_REQ")) return MNCC__STOP__DTMF__REQ;
else if (!strcmp(str_par, "MNCC_HOLD_REQ")) return MNCC__HOLD__REQ;
else if (!strcmp(str_par, "MNCC_RETRIEVE_REQ")) return MNCC__RETRIEVE__REQ;
else if (!strcmp(str_par, "MNCC_BRIDGE")) return MNCC__BRIDGE;
else if (!strcmp(str_par, "MNCC_FRAME_RECV")) return MNCC__FRAME__RECV;
else if (!strcmp(str_par, "MNCC_FRAME_DROP")) return MNCC__FRAME__DROP;
else if (!strcmp(str_par, "MNCC_LCHAN_MODIFY")) return MNCC__LCHAN__MODIFY;
else if (!strcmp(str_par, "MNCC_RTP_CREATE")) return MNCC__RTP__CREATE;
else if (!strcmp(str_par, "MNCC_RTP_CONNECT")) return MNCC__RTP__CONNECT;
else if (!strcmp(str_par, "MNCC_RTP_FREE")) return MNCC__RTP__FREE;
else if (!strcmp(str_par, "GSM_TCHF_FRAME")) return GSM__TCHF__FRAME;
else if (!strcmp(str_par, "GSM_TCHF_FRAME_EFR")) return GSM__TCHF__FRAME__EFR;
else if (!strcmp(str_par, "GSM_TCHH_FRAME")) return GSM__TCHH__FRAME;
else if (!strcmp(str_par, "GSM_TCH_FRAME_AMR")) return GSM__TCH__FRAME__AMR;
else if (!strcmp(str_par, "GSM_BAD_FRAME")) return GSM__BAD__FRAME;
else if (!strcmp(str_par, "MNCC_SOCKET_HELLO")) return MNCC__SOCKET__HELLO;
else return UNKNOWN_VALUE;
}

boolean MNCC__MsgType::is_valid_enum(int int_par)
{
switch (int_par) {
case 257:
case 258:
case 259:
case 260:
case 261:
case 262:
case 263:
case 264:
case 265:
case 266:
case 267:
case 268:
case 269:
case 270:
case 271:
case 272:
case 273:
case 274:
case 275:
case 276:
case 277:
case 278:
case 279:
case 280:
case 281:
case 282:
case 283:
case 284:
case 285:
case 286:
case 287:
case 288:
case 289:
case 290:
case 291:
case 292:
case 293:
case 294:
case 295:
case 296:
case 297:
case 298:
case 299:
case 300:
case 301:
case 302:
case 303:
case 512:
case 513:
case 514:
case 515:
case 516:
case 517:
case 518:
case 768:
case 769:
case 770:
case 771:
case 1023:
case 1024:
return TRUE;
default:
return FALSE;
}
}

int MNCC__MsgType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.MNCC_MsgType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int MNCC__MsgType::enum2int(const MNCC__MsgType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.MNCC_MsgType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void MNCC__MsgType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.MNCC_MsgType.", int_val);
enum_value = (enum_type)int_val;
}

MNCC__MsgType::operator MNCC__MsgType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.MNCC_MsgType.");
return enum_value;
}

void MNCC__MsgType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void MNCC__MsgType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.MNCC_MsgType");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.MNCC_MsgType.");
  }
}

void MNCC__MsgType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
text_buf.push_int(enum_value);
}

void MNCC__MsgType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.MNCC_MsgType.", enum_value);
}

void MNCC__MsgType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__MsgType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__MsgType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 11, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int MNCC__MsgType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 11);
}

void MNCC__MsgType_template::copy_template(const MNCC__MsgType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__MsgType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_MsgType.");
}
}

MNCC__MsgType_template::MNCC__MsgType_template()
{
}

MNCC__MsgType_template::MNCC__MsgType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__MsgType_template::MNCC__MsgType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!MNCC__MsgType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.MNCC_MsgType with unknown numeric value %d.", other_value);
single_value = (MNCC__MsgType::enum_type)other_value;
}

MNCC__MsgType_template::MNCC__MsgType_template(MNCC__MsgType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

MNCC__MsgType_template::MNCC__MsgType_template(const MNCC__MsgType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == MNCC__MsgType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.MNCC_MsgType.");
single_value = other_value.enum_value;
}

MNCC__MsgType_template::MNCC__MsgType_template(const OPTIONAL<MNCC__MsgType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__MsgType::enum_type)(const MNCC__MsgType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.MNCC_MsgType from an unbound optional field.");
}
}

MNCC__MsgType_template::MNCC__MsgType_template(const MNCC__MsgType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

MNCC__MsgType_template::~MNCC__MsgType_template()
{
clean_up();
}

boolean MNCC__MsgType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean MNCC__MsgType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != MNCC__MsgType::UNBOUND_VALUE;
}

void MNCC__MsgType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(int other_value)
{
if (!MNCC__MsgType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.MNCC_MsgType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__MsgType::enum_type)other_value;
return *this;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(MNCC__MsgType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(const MNCC__MsgType& other_value)
{
if (other_value.enum_value == MNCC__MsgType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.MNCC_MsgType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(const OPTIONAL<MNCC__MsgType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__MsgType::enum_type)(const MNCC__MsgType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.MNCC_MsgType.");
}
return *this;
}

MNCC__MsgType_template& MNCC__MsgType_template::operator=(const MNCC__MsgType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__MsgType_template::match(MNCC__MsgType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_MsgType.");
}
return FALSE;
}

boolean MNCC__MsgType_template::match(const MNCC__MsgType& other_value, boolean) const
{
if (other_value.enum_value == MNCC__MsgType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.MNCC_MsgType with an unbound value.");
return match(other_value.enum_value);
}

MNCC__MsgType::enum_type MNCC__MsgType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.MNCC_MsgType.");
return single_value;
}

void MNCC__MsgType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.MNCC_MsgType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__MsgType_template[list_length];
}

MNCC__MsgType_template& MNCC__MsgType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.MNCC_MsgType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.MNCC_MsgType.");
return value_list.list_value[list_index];
}

void MNCC__MsgType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(MNCC__MsgType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__MsgType_template::log_match(const MNCC__MsgType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void MNCC__MsgType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_MsgType.");
}
}

void MNCC__MsgType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (MNCC__MsgType::enum_type)text_buf.pull_int().get_val();
if (!MNCC__MsgType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.MNCC_MsgType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__MsgType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.MNCC_MsgType.");
}
}

boolean MNCC__MsgType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__MsgType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MNCC__MsgType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__MsgType_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    MNCC__MsgType::enum_type enum_val = MNCC__MsgType::str_to_enum(m_p->get_enumerated());
    if (!MNCC__MsgType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.MNCC_MsgType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.MNCC_MsgType");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__MsgType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_MsgType");
}

MNCC__bearer__cap__data::MNCC__bearer__cap__data()
{
}

MNCC__bearer__cap__data::MNCC__bearer__cap__data(const GSM48__bcap__ra& par_rate__adaptation,
    const GSM48__bcap__sig__access& par_sig__access,
    const INTEGER& par_async,
    const INTEGER& par_nr__stop__bits,
    const INTEGER& par_nr__data__bits,
    const GSM48__bcap__user__rate& par_user__rate,
    const GSM48__bcap__parity& par_parity,
    const GSM48__bcap__interm__rate& par_interm__rate,
    const GSM48__bcap__transp& par_transp,
    const GSM48__bcap__modem__type& par_modem__type)
  :   field_rate__adaptation(par_rate__adaptation),
  field_sig__access(par_sig__access),
  field_async(par_async),
  field_nr__stop__bits(par_nr__stop__bits),
  field_nr__data__bits(par_nr__data__bits),
  field_user__rate(par_user__rate),
  field_parity(par_parity),
  field_interm__rate(par_interm__rate),
  field_transp(par_transp),
  field_modem__type(par_modem__type)
{
}

MNCC__bearer__cap__data::MNCC__bearer__cap__data(const MNCC__bearer__cap__data& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_bearer_cap_data.");
if (other_value.rate__adaptation().is_bound()) field_rate__adaptation = other_value.rate__adaptation();
else field_rate__adaptation.clean_up();
if (other_value.sig__access().is_bound()) field_sig__access = other_value.sig__access();
else field_sig__access.clean_up();
if (other_value.async().is_bound()) field_async = other_value.async();
else field_async.clean_up();
if (other_value.nr__stop__bits().is_bound()) field_nr__stop__bits = other_value.nr__stop__bits();
else field_nr__stop__bits.clean_up();
if (other_value.nr__data__bits().is_bound()) field_nr__data__bits = other_value.nr__data__bits();
else field_nr__data__bits.clean_up();
if (other_value.user__rate().is_bound()) field_user__rate = other_value.user__rate();
else field_user__rate.clean_up();
if (other_value.parity().is_bound()) field_parity = other_value.parity();
else field_parity.clean_up();
if (other_value.interm__rate().is_bound()) field_interm__rate = other_value.interm__rate();
else field_interm__rate.clean_up();
if (other_value.transp().is_bound()) field_transp = other_value.transp();
else field_transp.clean_up();
if (other_value.modem__type().is_bound()) field_modem__type = other_value.modem__type();
else field_modem__type.clean_up();
}

void MNCC__bearer__cap__data::clean_up()
{
field_rate__adaptation.clean_up();
field_sig__access.clean_up();
field_async.clean_up();
field_nr__stop__bits.clean_up();
field_nr__data__bits.clean_up();
field_user__rate.clean_up();
field_parity.clean_up();
field_interm__rate.clean_up();
field_transp.clean_up();
field_modem__type.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__bearer__cap__data::get_descriptor() const { return &MNCC__bearer__cap__data_descr_; }
MNCC__bearer__cap__data& MNCC__bearer__cap__data::operator=(const MNCC__bearer__cap__data& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_bearer_cap_data.");
  if (other_value.rate__adaptation().is_bound()) field_rate__adaptation = other_value.rate__adaptation();
  else field_rate__adaptation.clean_up();
  if (other_value.sig__access().is_bound()) field_sig__access = other_value.sig__access();
  else field_sig__access.clean_up();
  if (other_value.async().is_bound()) field_async = other_value.async();
  else field_async.clean_up();
  if (other_value.nr__stop__bits().is_bound()) field_nr__stop__bits = other_value.nr__stop__bits();
  else field_nr__stop__bits.clean_up();
  if (other_value.nr__data__bits().is_bound()) field_nr__data__bits = other_value.nr__data__bits();
  else field_nr__data__bits.clean_up();
  if (other_value.user__rate().is_bound()) field_user__rate = other_value.user__rate();
  else field_user__rate.clean_up();
  if (other_value.parity().is_bound()) field_parity = other_value.parity();
  else field_parity.clean_up();
  if (other_value.interm__rate().is_bound()) field_interm__rate = other_value.interm__rate();
  else field_interm__rate.clean_up();
  if (other_value.transp().is_bound()) field_transp = other_value.transp();
  else field_transp.clean_up();
  if (other_value.modem__type().is_bound()) field_modem__type = other_value.modem__type();
  else field_modem__type.clean_up();
}
return *this;
}

boolean MNCC__bearer__cap__data::operator==(const MNCC__bearer__cap__data& other_value) const
{
return field_rate__adaptation==other_value.field_rate__adaptation
  && field_sig__access==other_value.field_sig__access
  && field_async==other_value.field_async
  && field_nr__stop__bits==other_value.field_nr__stop__bits
  && field_nr__data__bits==other_value.field_nr__data__bits
  && field_user__rate==other_value.field_user__rate
  && field_parity==other_value.field_parity
  && field_interm__rate==other_value.field_interm__rate
  && field_transp==other_value.field_transp
  && field_modem__type==other_value.field_modem__type;
}

boolean MNCC__bearer__cap__data::is_bound() const
{
if(field_rate__adaptation.is_bound()) return TRUE;
if(field_sig__access.is_bound()) return TRUE;
if(field_async.is_bound()) return TRUE;
if(field_nr__stop__bits.is_bound()) return TRUE;
if(field_nr__data__bits.is_bound()) return TRUE;
if(field_user__rate.is_bound()) return TRUE;
if(field_parity.is_bound()) return TRUE;
if(field_interm__rate.is_bound()) return TRUE;
if(field_transp.is_bound()) return TRUE;
if(field_modem__type.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__bearer__cap__data::is_value() const
{
if(!field_rate__adaptation.is_value()) return FALSE;
if(!field_sig__access.is_value()) return FALSE;
if(!field_async.is_value()) return FALSE;
if(!field_nr__stop__bits.is_value()) return FALSE;
if(!field_nr__data__bits.is_value()) return FALSE;
if(!field_user__rate.is_value()) return FALSE;
if(!field_parity.is_value()) return FALSE;
if(!field_interm__rate.is_value()) return FALSE;
if(!field_transp.is_value()) return FALSE;
if(!field_modem__type.is_value()) return FALSE;
return TRUE;
}
void MNCC__bearer__cap__data::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ rate_adaptation := ");
field_rate__adaptation.log();
TTCN_Logger::log_event_str(", sig_access := ");
field_sig__access.log();
TTCN_Logger::log_event_str(", async := ");
field_async.log();
TTCN_Logger::log_event_str(", nr_stop_bits := ");
field_nr__stop__bits.log();
TTCN_Logger::log_event_str(", nr_data_bits := ");
field_nr__data__bits.log();
TTCN_Logger::log_event_str(", user_rate := ");
field_user__rate.log();
TTCN_Logger::log_event_str(", parity := ");
field_parity.log();
TTCN_Logger::log_event_str(", interm_rate := ");
field_interm__rate.log();
TTCN_Logger::log_event_str(", transp := ");
field_transp.log();
TTCN_Logger::log_event_str(", modem_type := ");
field_modem__type.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__bearer__cap__data::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (10<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_bearer_cap_data has 10 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rate__adaptation().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sig__access().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) async().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) nr__stop__bits().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nr__data__bits().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) user__rate().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) parity().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) interm__rate().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) transp().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) modem__type().set_param(*param.get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rate_adaptation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rate__adaptation().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sig_access")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sig__access().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "async")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          async().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nr_stop_bits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nr__stop__bits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nr_data_bits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nr__data__bits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_rate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__rate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "parity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          parity().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interm_rate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interm__rate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "modem_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          modem__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_bearer_cap_data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_bearer_cap_data");
  }
}

void MNCC__bearer__cap__data::set_implicit_omit()
{
if (rate__adaptation().is_bound()) rate__adaptation().set_implicit_omit();
if (sig__access().is_bound()) sig__access().set_implicit_omit();
if (async().is_bound()) async().set_implicit_omit();
if (nr__stop__bits().is_bound()) nr__stop__bits().set_implicit_omit();
if (nr__data__bits().is_bound()) nr__data__bits().set_implicit_omit();
if (user__rate().is_bound()) user__rate().set_implicit_omit();
if (parity().is_bound()) parity().set_implicit_omit();
if (interm__rate().is_bound()) interm__rate().set_implicit_omit();
if (transp().is_bound()) transp().set_implicit_omit();
if (modem__type().is_bound()) modem__type().set_implicit_omit();
}

void MNCC__bearer__cap__data::encode_text(Text_Buf& text_buf) const
{
field_rate__adaptation.encode_text(text_buf);
field_sig__access.encode_text(text_buf);
field_async.encode_text(text_buf);
field_nr__stop__bits.encode_text(text_buf);
field_nr__data__bits.encode_text(text_buf);
field_user__rate.encode_text(text_buf);
field_parity.encode_text(text_buf);
field_interm__rate.encode_text(text_buf);
field_transp.encode_text(text_buf);
field_modem__type.encode_text(text_buf);
}

void MNCC__bearer__cap__data::decode_text(Text_Buf& text_buf)
{
field_rate__adaptation.decode_text(text_buf);
field_sig__access.decode_text(text_buf);
field_async.decode_text(text_buf);
field_nr__stop__bits.decode_text(text_buf);
field_nr__data__bits.decode_text(text_buf);
field_user__rate.decode_text(text_buf);
field_parity.decode_text(text_buf);
field_interm__rate.decode_text(text_buf);
field_transp.decode_text(text_buf);
field_modem__type.decode_text(text_buf);
}

void MNCC__bearer__cap__data::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__bearer__cap__data::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__bearer__cap__data::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__bearer__cap__data_rate__adaptation_descr_.raw->forceomit);
  decoded_field_length = field_rate__adaptation.RAW_decode(MNCC__bearer__cap__data_rate__adaptation_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__bearer__cap__data_sig__access_descr_.raw->forceomit);
  decoded_field_length = field_sig__access.RAW_decode(MNCC__bearer__cap__data_sig__access_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__bearer__cap__data_async_descr_.raw->forceomit);
  decoded_field_length = field_async.RAW_decode(MNCC__bearer__cap__data_async_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__bearer__cap__data_nr__stop__bits_descr_.raw->forceomit);
  decoded_field_length = field_nr__stop__bits.RAW_decode(MNCC__bearer__cap__data_nr__stop__bits_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__bearer__cap__data_nr__data__bits_descr_.raw->forceomit);
  decoded_field_length = field_nr__data__bits.RAW_decode(MNCC__bearer__cap__data_nr__data__bits_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, MNCC__bearer__cap__data_user__rate_descr_.raw->forceomit);
  decoded_field_length = field_user__rate.RAW_decode(MNCC__bearer__cap__data_user__rate_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, MNCC__bearer__cap__data_parity_descr_.raw->forceomit);
  decoded_field_length = field_parity.RAW_decode(MNCC__bearer__cap__data_parity_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_7_force_omit(7, force_omit, MNCC__bearer__cap__data_interm__rate_descr_.raw->forceomit);
  decoded_field_length = field_interm__rate.RAW_decode(MNCC__bearer__cap__data_interm__rate_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_8_force_omit(8, force_omit, MNCC__bearer__cap__data_transp_descr_.raw->forceomit);
  decoded_field_length = field_transp.RAW_decode(MNCC__bearer__cap__data_transp_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_9_force_omit(9, force_omit, MNCC__bearer__cap__data_modem__type_descr_.raw->forceomit);
  decoded_field_length = field_modem__type.RAW_decode(MNCC__bearer__cap__data_modem__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__bearer__cap__data::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 10;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(10);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__bearer__cap__data_rate__adaptation_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__bearer__cap__data_sig__access_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__bearer__cap__data_async_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__bearer__cap__data_nr__stop__bits_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__bearer__cap__data_nr__data__bits_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, MNCC__bearer__cap__data_user__rate_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, MNCC__bearer__cap__data_parity_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, MNCC__bearer__cap__data_interm__rate_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, MNCC__bearer__cap__data_transp_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, MNCC__bearer__cap__data_modem__type_descr_.raw);
  encoded_length += field_rate__adaptation.RAW_encode(MNCC__bearer__cap__data_rate__adaptation_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_sig__access.RAW_encode(MNCC__bearer__cap__data_sig__access_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_async.RAW_encode(MNCC__bearer__cap__data_async_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_nr__stop__bits.RAW_encode(MNCC__bearer__cap__data_nr__stop__bits_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_nr__data__bits.RAW_encode(MNCC__bearer__cap__data_nr__data__bits_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_user__rate.RAW_encode(MNCC__bearer__cap__data_user__rate_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_parity.RAW_encode(MNCC__bearer__cap__data_parity_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_interm__rate.RAW_encode(MNCC__bearer__cap__data_interm__rate_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_transp.RAW_encode(MNCC__bearer__cap__data_transp_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_modem__type.RAW_encode(MNCC__bearer__cap__data_modem__type_descr_, *myleaf.body.node.nodes[9]);
  return myleaf.length = encoded_length;
}

struct MNCC__bearer__cap__data_template::single_value_struct {
GSM48__bcap__ra_template field_rate__adaptation;
GSM48__bcap__sig__access_template field_sig__access;
INTEGER_template field_async;
INTEGER_template field_nr__stop__bits;
INTEGER_template field_nr__data__bits;
GSM48__bcap__user__rate_template field_user__rate;
GSM48__bcap__parity_template field_parity;
GSM48__bcap__interm__rate_template field_interm__rate;
GSM48__bcap__transp_template field_transp;
GSM48__bcap__modem__type_template field_modem__type;
};

void MNCC__bearer__cap__data_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_rate__adaptation = ANY_VALUE;
single_value->field_sig__access = ANY_VALUE;
single_value->field_async = ANY_VALUE;
single_value->field_nr__stop__bits = ANY_VALUE;
single_value->field_nr__data__bits = ANY_VALUE;
single_value->field_user__rate = ANY_VALUE;
single_value->field_parity = ANY_VALUE;
single_value->field_interm__rate = ANY_VALUE;
single_value->field_transp = ANY_VALUE;
single_value->field_modem__type = ANY_VALUE;
}
}
}

void MNCC__bearer__cap__data_template::copy_value(const MNCC__bearer__cap__data& other_value)
{
single_value = new single_value_struct;
if (other_value.rate__adaptation().is_bound()) {
  single_value->field_rate__adaptation = other_value.rate__adaptation();
} else {
  single_value->field_rate__adaptation.clean_up();
}
if (other_value.sig__access().is_bound()) {
  single_value->field_sig__access = other_value.sig__access();
} else {
  single_value->field_sig__access.clean_up();
}
if (other_value.async().is_bound()) {
  single_value->field_async = other_value.async();
} else {
  single_value->field_async.clean_up();
}
if (other_value.nr__stop__bits().is_bound()) {
  single_value->field_nr__stop__bits = other_value.nr__stop__bits();
} else {
  single_value->field_nr__stop__bits.clean_up();
}
if (other_value.nr__data__bits().is_bound()) {
  single_value->field_nr__data__bits = other_value.nr__data__bits();
} else {
  single_value->field_nr__data__bits.clean_up();
}
if (other_value.user__rate().is_bound()) {
  single_value->field_user__rate = other_value.user__rate();
} else {
  single_value->field_user__rate.clean_up();
}
if (other_value.parity().is_bound()) {
  single_value->field_parity = other_value.parity();
} else {
  single_value->field_parity.clean_up();
}
if (other_value.interm__rate().is_bound()) {
  single_value->field_interm__rate = other_value.interm__rate();
} else {
  single_value->field_interm__rate.clean_up();
}
if (other_value.transp().is_bound()) {
  single_value->field_transp = other_value.transp();
} else {
  single_value->field_transp.clean_up();
}
if (other_value.modem__type().is_bound()) {
  single_value->field_modem__type = other_value.modem__type();
} else {
  single_value->field_modem__type.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__bearer__cap__data_template::copy_template(const MNCC__bearer__cap__data_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.rate__adaptation().get_selection()) {
single_value->field_rate__adaptation = other_value.rate__adaptation();
} else {
single_value->field_rate__adaptation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sig__access().get_selection()) {
single_value->field_sig__access = other_value.sig__access();
} else {
single_value->field_sig__access.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.async().get_selection()) {
single_value->field_async = other_value.async();
} else {
single_value->field_async.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nr__stop__bits().get_selection()) {
single_value->field_nr__stop__bits = other_value.nr__stop__bits();
} else {
single_value->field_nr__stop__bits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nr__data__bits().get_selection()) {
single_value->field_nr__data__bits = other_value.nr__data__bits();
} else {
single_value->field_nr__data__bits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.user__rate().get_selection()) {
single_value->field_user__rate = other_value.user__rate();
} else {
single_value->field_user__rate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.parity().get_selection()) {
single_value->field_parity = other_value.parity();
} else {
single_value->field_parity.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.interm__rate().get_selection()) {
single_value->field_interm__rate = other_value.interm__rate();
} else {
single_value->field_interm__rate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.transp().get_selection()) {
single_value->field_transp = other_value.transp();
} else {
single_value->field_transp.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.modem__type().get_selection()) {
single_value->field_modem__type = other_value.modem__type();
} else {
single_value->field_modem__type.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__bearer__cap__data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap_data.");
break;
}
set_selection(other_value);
}

MNCC__bearer__cap__data_template::MNCC__bearer__cap__data_template()
{
}

MNCC__bearer__cap__data_template::MNCC__bearer__cap__data_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__bearer__cap__data_template::MNCC__bearer__cap__data_template(const MNCC__bearer__cap__data& other_value)
{
copy_value(other_value);
}

MNCC__bearer__cap__data_template::MNCC__bearer__cap__data_template(const OPTIONAL<MNCC__bearer__cap__data>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__bearer__cap__data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_bearer_cap_data from an unbound optional field.");
}
}

MNCC__bearer__cap__data_template::MNCC__bearer__cap__data_template(const MNCC__bearer__cap__data_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__bearer__cap__data_template::~MNCC__bearer__cap__data_template()
{
clean_up();
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap__data_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap__data_template::operator=(const MNCC__bearer__cap__data& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap__data_template::operator=(const OPTIONAL<MNCC__bearer__cap__data>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__bearer__cap__data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_bearer_cap_data.");
}
return *this;
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap__data_template::operator=(const MNCC__bearer__cap__data_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__bearer__cap__data_template::match(const MNCC__bearer__cap__data& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.rate__adaptation().is_bound()) return FALSE;
if(!single_value->field_rate__adaptation.match(other_value.rate__adaptation(), legacy))return FALSE;
if(!other_value.sig__access().is_bound()) return FALSE;
if(!single_value->field_sig__access.match(other_value.sig__access(), legacy))return FALSE;
if(!other_value.async().is_bound()) return FALSE;
if(!single_value->field_async.match(other_value.async(), legacy))return FALSE;
if(!other_value.nr__stop__bits().is_bound()) return FALSE;
if(!single_value->field_nr__stop__bits.match(other_value.nr__stop__bits(), legacy))return FALSE;
if(!other_value.nr__data__bits().is_bound()) return FALSE;
if(!single_value->field_nr__data__bits.match(other_value.nr__data__bits(), legacy))return FALSE;
if(!other_value.user__rate().is_bound()) return FALSE;
if(!single_value->field_user__rate.match(other_value.user__rate(), legacy))return FALSE;
if(!other_value.parity().is_bound()) return FALSE;
if(!single_value->field_parity.match(other_value.parity(), legacy))return FALSE;
if(!other_value.interm__rate().is_bound()) return FALSE;
if(!single_value->field_interm__rate.match(other_value.interm__rate(), legacy))return FALSE;
if(!other_value.transp().is_bound()) return FALSE;
if(!single_value->field_transp.match(other_value.transp(), legacy))return FALSE;
if(!other_value.modem__type().is_bound()) return FALSE;
if(!single_value->field_modem__type.match(other_value.modem__type(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap_data.");
}
return FALSE;
}

boolean MNCC__bearer__cap__data_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_rate__adaptation.is_bound()) return TRUE;
if (single_value->field_sig__access.is_bound()) return TRUE;
if (single_value->field_async.is_bound()) return TRUE;
if (single_value->field_nr__stop__bits.is_bound()) return TRUE;
if (single_value->field_nr__data__bits.is_bound()) return TRUE;
if (single_value->field_user__rate.is_bound()) return TRUE;
if (single_value->field_parity.is_bound()) return TRUE;
if (single_value->field_interm__rate.is_bound()) return TRUE;
if (single_value->field_transp.is_bound()) return TRUE;
if (single_value->field_modem__type.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__bearer__cap__data_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_rate__adaptation.is_value()) return FALSE;
if (!single_value->field_sig__access.is_value()) return FALSE;
if (!single_value->field_async.is_value()) return FALSE;
if (!single_value->field_nr__stop__bits.is_value()) return FALSE;
if (!single_value->field_nr__data__bits.is_value()) return FALSE;
if (!single_value->field_user__rate.is_value()) return FALSE;
if (!single_value->field_parity.is_value()) return FALSE;
if (!single_value->field_interm__rate.is_value()) return FALSE;
if (!single_value->field_transp.is_value()) return FALSE;
if (!single_value->field_modem__type.is_value()) return FALSE;
return TRUE;
}

void MNCC__bearer__cap__data_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__bearer__cap__data MNCC__bearer__cap__data_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
MNCC__bearer__cap__data ret_val;
if (single_value->field_rate__adaptation.is_bound()) {
ret_val.rate__adaptation() = single_value->field_rate__adaptation.valueof();
}
if (single_value->field_sig__access.is_bound()) {
ret_val.sig__access() = single_value->field_sig__access.valueof();
}
if (single_value->field_async.is_bound()) {
ret_val.async() = single_value->field_async.valueof();
}
if (single_value->field_nr__stop__bits.is_bound()) {
ret_val.nr__stop__bits() = single_value->field_nr__stop__bits.valueof();
}
if (single_value->field_nr__data__bits.is_bound()) {
ret_val.nr__data__bits() = single_value->field_nr__data__bits.valueof();
}
if (single_value->field_user__rate.is_bound()) {
ret_val.user__rate() = single_value->field_user__rate.valueof();
}
if (single_value->field_parity.is_bound()) {
ret_val.parity() = single_value->field_parity.valueof();
}
if (single_value->field_interm__rate.is_bound()) {
ret_val.interm__rate() = single_value->field_interm__rate.valueof();
}
if (single_value->field_transp.is_bound()) {
ret_val.transp() = single_value->field_transp.valueof();
}
if (single_value->field_modem__type.is_bound()) {
ret_val.modem__type() = single_value->field_modem__type.valueof();
}
return ret_val;
}

void MNCC__bearer__cap__data_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_bearer_cap_data.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__bearer__cap__data_template[list_length];
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap__data_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_bearer_cap_data.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_bearer_cap_data.");
return value_list.list_value[list_index];
}

GSM48__bcap__ra_template& MNCC__bearer__cap__data_template::rate__adaptation()
{
set_specific();
return single_value->field_rate__adaptation;
}

const GSM48__bcap__ra_template& MNCC__bearer__cap__data_template::rate__adaptation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rate_adaptation of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_rate__adaptation;
}

GSM48__bcap__sig__access_template& MNCC__bearer__cap__data_template::sig__access()
{
set_specific();
return single_value->field_sig__access;
}

const GSM48__bcap__sig__access_template& MNCC__bearer__cap__data_template::sig__access() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sig_access of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_sig__access;
}

INTEGER_template& MNCC__bearer__cap__data_template::async()
{
set_specific();
return single_value->field_async;
}

const INTEGER_template& MNCC__bearer__cap__data_template::async() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field async of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_async;
}

INTEGER_template& MNCC__bearer__cap__data_template::nr__stop__bits()
{
set_specific();
return single_value->field_nr__stop__bits;
}

const INTEGER_template& MNCC__bearer__cap__data_template::nr__stop__bits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nr_stop_bits of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_nr__stop__bits;
}

INTEGER_template& MNCC__bearer__cap__data_template::nr__data__bits()
{
set_specific();
return single_value->field_nr__data__bits;
}

const INTEGER_template& MNCC__bearer__cap__data_template::nr__data__bits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nr_data_bits of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_nr__data__bits;
}

GSM48__bcap__user__rate_template& MNCC__bearer__cap__data_template::user__rate()
{
set_specific();
return single_value->field_user__rate;
}

const GSM48__bcap__user__rate_template& MNCC__bearer__cap__data_template::user__rate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field user_rate of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_user__rate;
}

GSM48__bcap__parity_template& MNCC__bearer__cap__data_template::parity()
{
set_specific();
return single_value->field_parity;
}

const GSM48__bcap__parity_template& MNCC__bearer__cap__data_template::parity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field parity of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_parity;
}

GSM48__bcap__interm__rate_template& MNCC__bearer__cap__data_template::interm__rate()
{
set_specific();
return single_value->field_interm__rate;
}

const GSM48__bcap__interm__rate_template& MNCC__bearer__cap__data_template::interm__rate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field interm_rate of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_interm__rate;
}

GSM48__bcap__transp_template& MNCC__bearer__cap__data_template::transp()
{
set_specific();
return single_value->field_transp;
}

const GSM48__bcap__transp_template& MNCC__bearer__cap__data_template::transp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field transp of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_transp;
}

GSM48__bcap__modem__type_template& MNCC__bearer__cap__data_template::modem__type()
{
set_specific();
return single_value->field_modem__type;
}

const GSM48__bcap__modem__type_template& MNCC__bearer__cap__data_template::modem__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field modem_type of a non-specific template of type @MNCC_Types.MNCC_bearer_cap_data.");
return single_value->field_modem__type;
}

int MNCC__bearer__cap__data_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 10;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap_data containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap_data.");
  }
  return 0;
}

void MNCC__bearer__cap__data_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ rate_adaptation := ");
single_value->field_rate__adaptation.log();
TTCN_Logger::log_event_str(", sig_access := ");
single_value->field_sig__access.log();
TTCN_Logger::log_event_str(", async := ");
single_value->field_async.log();
TTCN_Logger::log_event_str(", nr_stop_bits := ");
single_value->field_nr__stop__bits.log();
TTCN_Logger::log_event_str(", nr_data_bits := ");
single_value->field_nr__data__bits.log();
TTCN_Logger::log_event_str(", user_rate := ");
single_value->field_user__rate.log();
TTCN_Logger::log_event_str(", parity := ");
single_value->field_parity.log();
TTCN_Logger::log_event_str(", interm_rate := ");
single_value->field_interm__rate.log();
TTCN_Logger::log_event_str(", transp := ");
single_value->field_transp.log();
TTCN_Logger::log_event_str(", modem_type := ");
single_value->field_modem__type.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__bearer__cap__data_template::log_match(const MNCC__bearer__cap__data& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_rate__adaptation.match(match_value.rate__adaptation(), legacy)){
TTCN_Logger::log_logmatch_info(".rate_adaptation");
single_value->field_rate__adaptation.log_match(match_value.rate__adaptation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sig__access.match(match_value.sig__access(), legacy)){
TTCN_Logger::log_logmatch_info(".sig_access");
single_value->field_sig__access.log_match(match_value.sig__access(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_async.match(match_value.async(), legacy)){
TTCN_Logger::log_logmatch_info(".async");
single_value->field_async.log_match(match_value.async(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nr__stop__bits.match(match_value.nr__stop__bits(), legacy)){
TTCN_Logger::log_logmatch_info(".nr_stop_bits");
single_value->field_nr__stop__bits.log_match(match_value.nr__stop__bits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nr__data__bits.match(match_value.nr__data__bits(), legacy)){
TTCN_Logger::log_logmatch_info(".nr_data_bits");
single_value->field_nr__data__bits.log_match(match_value.nr__data__bits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_user__rate.match(match_value.user__rate(), legacy)){
TTCN_Logger::log_logmatch_info(".user_rate");
single_value->field_user__rate.log_match(match_value.user__rate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_parity.match(match_value.parity(), legacy)){
TTCN_Logger::log_logmatch_info(".parity");
single_value->field_parity.log_match(match_value.parity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_interm__rate.match(match_value.interm__rate(), legacy)){
TTCN_Logger::log_logmatch_info(".interm_rate");
single_value->field_interm__rate.log_match(match_value.interm__rate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_transp.match(match_value.transp(), legacy)){
TTCN_Logger::log_logmatch_info(".transp");
single_value->field_transp.log_match(match_value.transp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_modem__type.match(match_value.modem__type(), legacy)){
TTCN_Logger::log_logmatch_info(".modem_type");
single_value->field_modem__type.log_match(match_value.modem__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ rate_adaptation := ");
single_value->field_rate__adaptation.log_match(match_value.rate__adaptation(), legacy);
TTCN_Logger::log_event_str(", sig_access := ");
single_value->field_sig__access.log_match(match_value.sig__access(), legacy);
TTCN_Logger::log_event_str(", async := ");
single_value->field_async.log_match(match_value.async(), legacy);
TTCN_Logger::log_event_str(", nr_stop_bits := ");
single_value->field_nr__stop__bits.log_match(match_value.nr__stop__bits(), legacy);
TTCN_Logger::log_event_str(", nr_data_bits := ");
single_value->field_nr__data__bits.log_match(match_value.nr__data__bits(), legacy);
TTCN_Logger::log_event_str(", user_rate := ");
single_value->field_user__rate.log_match(match_value.user__rate(), legacy);
TTCN_Logger::log_event_str(", parity := ");
single_value->field_parity.log_match(match_value.parity(), legacy);
TTCN_Logger::log_event_str(", interm_rate := ");
single_value->field_interm__rate.log_match(match_value.interm__rate(), legacy);
TTCN_Logger::log_event_str(", transp := ");
single_value->field_transp.log_match(match_value.transp(), legacy);
TTCN_Logger::log_event_str(", modem_type := ");
single_value->field_modem__type.log_match(match_value.modem__type(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__bearer__cap__data_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_rate__adaptation.encode_text(text_buf);
single_value->field_sig__access.encode_text(text_buf);
single_value->field_async.encode_text(text_buf);
single_value->field_nr__stop__bits.encode_text(text_buf);
single_value->field_nr__data__bits.encode_text(text_buf);
single_value->field_user__rate.encode_text(text_buf);
single_value->field_parity.encode_text(text_buf);
single_value->field_interm__rate.encode_text(text_buf);
single_value->field_transp.encode_text(text_buf);
single_value->field_modem__type.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap_data.");
}
}

void MNCC__bearer__cap__data_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_rate__adaptation.decode_text(text_buf);
single_value->field_sig__access.decode_text(text_buf);
single_value->field_async.decode_text(text_buf);
single_value->field_nr__stop__bits.decode_text(text_buf);
single_value->field_nr__data__bits.decode_text(text_buf);
single_value->field_user__rate.decode_text(text_buf);
single_value->field_parity.decode_text(text_buf);
single_value->field_interm__rate.decode_text(text_buf);
single_value->field_transp.decode_text(text_buf);
single_value->field_modem__type.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__bearer__cap__data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_bearer_cap_data.");
}
}

void MNCC__bearer__cap__data_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__bearer__cap__data_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (10<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_bearer_cap_data has 10 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rate__adaptation().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sig__access().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) async().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) nr__stop__bits().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nr__data__bits().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) user__rate().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) parity().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) interm__rate().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) transp().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) modem__type().set_param(*param.get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rate_adaptation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rate__adaptation().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sig_access")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sig__access().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "async")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          async().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nr_stop_bits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nr__stop__bits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nr_data_bits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nr__data__bits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_rate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__rate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "parity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          parity().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interm_rate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interm__rate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "modem_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          modem__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_bearer_cap_data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_bearer_cap_data");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__bearer__cap__data_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_rate__adaptation.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_sig__access.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_async.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_nr__stop__bits.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_nr__data__bits.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_user__rate.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_parity.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_interm__rate.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_transp.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
single_value->field_modem__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap_data");
}

boolean MNCC__bearer__cap__data_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__bearer__cap__data_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__bearer__cap::MNCC__bearer__cap()
{
}

MNCC__bearer__cap::MNCC__bearer__cap(const INTEGER& par_transfer,
    const INTEGER& par_mode,
    const INTEGER& par_coding,
    const INTEGER& par_radio,
    const INTEGER& par_speech__ctm,
    const MNCC__speech__vers& par_speech__ver,
    const OPTIONAL<MNCC__bearer__cap__data>& par_data)
  :   field_transfer(par_transfer),
  field_mode(par_mode),
  field_coding(par_coding),
  field_radio(par_radio),
  field_speech__ctm(par_speech__ctm),
  field_speech__ver(par_speech__ver),
  field_data(par_data)
{
}

MNCC__bearer__cap::MNCC__bearer__cap(const MNCC__bearer__cap& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_bearer_cap.");
if (other_value.transfer().is_bound()) field_transfer = other_value.transfer();
else field_transfer.clean_up();
if (other_value.mode().is_bound()) field_mode = other_value.mode();
else field_mode.clean_up();
if (other_value.coding().is_bound()) field_coding = other_value.coding();
else field_coding.clean_up();
if (other_value.radio().is_bound()) field_radio = other_value.radio();
else field_radio.clean_up();
if (other_value.speech__ctm().is_bound()) field_speech__ctm = other_value.speech__ctm();
else field_speech__ctm.clean_up();
if (other_value.speech__ver().is_bound()) field_speech__ver = other_value.speech__ver();
else field_speech__ver.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void MNCC__bearer__cap::clean_up()
{
field_transfer.clean_up();
field_mode.clean_up();
field_coding.clean_up();
field_radio.clean_up();
field_speech__ctm.clean_up();
field_speech__ver.clean_up();
field_data.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__bearer__cap::get_descriptor() const { return &MNCC__bearer__cap_descr_; }
MNCC__bearer__cap& MNCC__bearer__cap::operator=(const MNCC__bearer__cap& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_bearer_cap.");
  if (other_value.transfer().is_bound()) field_transfer = other_value.transfer();
  else field_transfer.clean_up();
  if (other_value.mode().is_bound()) field_mode = other_value.mode();
  else field_mode.clean_up();
  if (other_value.coding().is_bound()) field_coding = other_value.coding();
  else field_coding.clean_up();
  if (other_value.radio().is_bound()) field_radio = other_value.radio();
  else field_radio.clean_up();
  if (other_value.speech__ctm().is_bound()) field_speech__ctm = other_value.speech__ctm();
  else field_speech__ctm.clean_up();
  if (other_value.speech__ver().is_bound()) field_speech__ver = other_value.speech__ver();
  else field_speech__ver.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean MNCC__bearer__cap::operator==(const MNCC__bearer__cap& other_value) const
{
return field_transfer==other_value.field_transfer
  && field_mode==other_value.field_mode
  && field_coding==other_value.field_coding
  && field_radio==other_value.field_radio
  && field_speech__ctm==other_value.field_speech__ctm
  && field_speech__ver==other_value.field_speech__ver
  && field_data==other_value.field_data;
}

boolean MNCC__bearer__cap::is_bound() const
{
if(field_transfer.is_bound()) return TRUE;
if(field_mode.is_bound()) return TRUE;
if(field_coding.is_bound()) return TRUE;
if(field_radio.is_bound()) return TRUE;
if(field_speech__ctm.is_bound()) return TRUE;
if(field_speech__ver.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_data.get_selection() || field_data.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__bearer__cap::is_value() const
{
if(!field_transfer.is_value()) return FALSE;
if(!field_mode.is_value()) return FALSE;
if(!field_coding.is_value()) return FALSE;
if(!field_radio.is_value()) return FALSE;
if(!field_speech__ctm.is_value()) return FALSE;
if(!field_speech__ver.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_data.get_selection() && !field_data.is_value()) return FALSE;
return TRUE;
}
int MNCC__bearer__cap::size_of() const
{
  int ret_val = 6;
  if (field_data.ispresent()) ret_val++;
  return ret_val;
}

void MNCC__bearer__cap::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ transfer := ");
field_transfer.log();
TTCN_Logger::log_event_str(", mode := ");
field_mode.log();
TTCN_Logger::log_event_str(", coding := ");
field_coding.log();
TTCN_Logger::log_event_str(", radio := ");
field_radio.log();
TTCN_Logger::log_event_str(", speech_ctm := ");
field_speech__ctm.log();
TTCN_Logger::log_event_str(", speech_ver := ");
field_speech__ver.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__bearer__cap::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_bearer_cap has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) transfer().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mode().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) radio().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) speech__ctm().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speech__ver().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transfer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transfer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "radio")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          radio().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speech_ctm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speech__ctm().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speech_ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speech__ver().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_bearer_cap: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_bearer_cap");
  }
}

void MNCC__bearer__cap::set_implicit_omit()
{
if (transfer().is_bound()) transfer().set_implicit_omit();
if (mode().is_bound()) mode().set_implicit_omit();
if (coding().is_bound()) coding().set_implicit_omit();
if (radio().is_bound()) radio().set_implicit_omit();
if (speech__ctm().is_bound()) speech__ctm().set_implicit_omit();
if (speech__ver().is_bound()) speech__ver().set_implicit_omit();
if (!data().is_bound()) data() = OMIT_VALUE;
else data().set_implicit_omit();
}

void MNCC__bearer__cap::encode_text(Text_Buf& text_buf) const
{
field_transfer.encode_text(text_buf);
field_mode.encode_text(text_buf);
field_coding.encode_text(text_buf);
field_radio.encode_text(text_buf);
field_speech__ctm.encode_text(text_buf);
field_speech__ver.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void MNCC__bearer__cap::decode_text(Text_Buf& text_buf)
{
field_transfer.decode_text(text_buf);
field_mode.decode_text(text_buf);
field_coding.decode_text(text_buf);
field_radio.decode_text(text_buf);
field_speech__ctm.decode_text(text_buf);
field_speech__ver.decode_text(text_buf);
field_data.decode_text(text_buf);
}

void MNCC__bearer__cap::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__bearer__cap::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__bearer__cap::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__bearer__cap_transfer_descr_.raw->forceomit);
  decoded_field_length = field_transfer.RAW_decode(MNCC__bearer__cap_transfer_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__bearer__cap_mode_descr_.raw->forceomit);
  decoded_field_length = field_mode.RAW_decode(MNCC__bearer__cap_mode_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__bearer__cap_coding_descr_.raw->forceomit);
  decoded_field_length = field_coding.RAW_decode(MNCC__bearer__cap_coding_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__bearer__cap_radio_descr_.raw->forceomit);
  decoded_field_length = field_radio.RAW_decode(MNCC__bearer__cap_radio_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__bearer__cap_speech__ctm_descr_.raw->forceomit);
  decoded_field_length = field_speech__ctm.RAW_decode(MNCC__bearer__cap_speech__ctm_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, MNCC__bearer__cap_speech__ver_descr_.raw->forceomit);
  decoded_field_length = field_speech__ver.RAW_decode(MNCC__bearer__cap_speech__ver_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(6)) {
    field_data = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_6_force_omit(6, force_omit, MNCC__bearer__cap_data_descr_.raw->forceomit);
  decoded_field_length = field_data().RAW_decode(MNCC__bearer__cap_data_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 1) {
  field_data = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_data=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__bearer__cap::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__bearer__cap_transfer_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__bearer__cap_mode_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__bearer__cap_coding_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__bearer__cap_radio_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__bearer__cap_speech__ctm_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, MNCC__bearer__cap_speech__ver_descr_.raw);
  if (field_data.ispresent()) {
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, MNCC__bearer__cap_data_descr_.raw);
  }
  else myleaf.body.node.nodes[6] = NULL;
  encoded_length += field_transfer.RAW_encode(MNCC__bearer__cap_transfer_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_mode.RAW_encode(MNCC__bearer__cap_mode_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_coding.RAW_encode(MNCC__bearer__cap_coding_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_radio.RAW_encode(MNCC__bearer__cap_radio_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_speech__ctm.RAW_encode(MNCC__bearer__cap_speech__ctm_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_speech__ver.RAW_encode(MNCC__bearer__cap_speech__ver_descr_, *myleaf.body.node.nodes[5]);
  if (field_data.ispresent()) {
  encoded_length += field_data().RAW_encode(MNCC__bearer__cap_data_descr_, *myleaf.body.node.nodes[6]);
  }
  return myleaf.length = encoded_length;
}

struct MNCC__bearer__cap_template::single_value_struct {
INTEGER_template field_transfer;
INTEGER_template field_mode;
INTEGER_template field_coding;
INTEGER_template field_radio;
INTEGER_template field_speech__ctm;
MNCC__speech__vers_template field_speech__ver;
MNCC__bearer__cap__data_template field_data;
};

void MNCC__bearer__cap_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_transfer = ANY_VALUE;
single_value->field_mode = ANY_VALUE;
single_value->field_coding = ANY_VALUE;
single_value->field_radio = ANY_VALUE;
single_value->field_speech__ctm = ANY_VALUE;
single_value->field_speech__ver = ANY_VALUE;
single_value->field_data = ANY_OR_OMIT;
}
}
}

void MNCC__bearer__cap_template::copy_value(const MNCC__bearer__cap& other_value)
{
single_value = new single_value_struct;
if (other_value.transfer().is_bound()) {
  single_value->field_transfer = other_value.transfer();
} else {
  single_value->field_transfer.clean_up();
}
if (other_value.mode().is_bound()) {
  single_value->field_mode = other_value.mode();
} else {
  single_value->field_mode.clean_up();
}
if (other_value.coding().is_bound()) {
  single_value->field_coding = other_value.coding();
} else {
  single_value->field_coding.clean_up();
}
if (other_value.radio().is_bound()) {
  single_value->field_radio = other_value.radio();
} else {
  single_value->field_radio.clean_up();
}
if (other_value.speech__ctm().is_bound()) {
  single_value->field_speech__ctm = other_value.speech__ctm();
} else {
  single_value->field_speech__ctm.clean_up();
}
if (other_value.speech__ver().is_bound()) {
  single_value->field_speech__ver = other_value.speech__ver();
} else {
  single_value->field_speech__ver.clean_up();
}
if (other_value.data().is_bound()) {
  if (other_value.data().ispresent()) single_value->field_data = other_value.data()();
  else single_value->field_data = OMIT_VALUE;
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__bearer__cap_template::copy_template(const MNCC__bearer__cap_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.transfer().get_selection()) {
single_value->field_transfer = other_value.transfer();
} else {
single_value->field_transfer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mode().get_selection()) {
single_value->field_mode = other_value.mode();
} else {
single_value->field_mode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.coding().get_selection()) {
single_value->field_coding = other_value.coding();
} else {
single_value->field_coding.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.radio().get_selection()) {
single_value->field_radio = other_value.radio();
} else {
single_value->field_radio.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speech__ctm().get_selection()) {
single_value->field_speech__ctm = other_value.speech__ctm();
} else {
single_value->field_speech__ctm.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speech__ver().get_selection()) {
single_value->field_speech__ver = other_value.speech__ver();
} else {
single_value->field_speech__ver.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__bearer__cap_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap.");
break;
}
set_selection(other_value);
}

MNCC__bearer__cap_template::MNCC__bearer__cap_template()
{
}

MNCC__bearer__cap_template::MNCC__bearer__cap_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__bearer__cap_template::MNCC__bearer__cap_template(const MNCC__bearer__cap& other_value)
{
copy_value(other_value);
}

MNCC__bearer__cap_template::MNCC__bearer__cap_template(const OPTIONAL<MNCC__bearer__cap>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__bearer__cap&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_bearer_cap from an unbound optional field.");
}
}

MNCC__bearer__cap_template::MNCC__bearer__cap_template(const MNCC__bearer__cap_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__bearer__cap_template::~MNCC__bearer__cap_template()
{
clean_up();
}

MNCC__bearer__cap_template& MNCC__bearer__cap_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__bearer__cap_template& MNCC__bearer__cap_template::operator=(const MNCC__bearer__cap& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__bearer__cap_template& MNCC__bearer__cap_template::operator=(const OPTIONAL<MNCC__bearer__cap>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__bearer__cap&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_bearer_cap.");
}
return *this;
}

MNCC__bearer__cap_template& MNCC__bearer__cap_template::operator=(const MNCC__bearer__cap_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__bearer__cap_template::match(const MNCC__bearer__cap& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.transfer().is_bound()) return FALSE;
if(!single_value->field_transfer.match(other_value.transfer(), legacy))return FALSE;
if(!other_value.mode().is_bound()) return FALSE;
if(!single_value->field_mode.match(other_value.mode(), legacy))return FALSE;
if(!other_value.coding().is_bound()) return FALSE;
if(!single_value->field_coding.match(other_value.coding(), legacy))return FALSE;
if(!other_value.radio().is_bound()) return FALSE;
if(!single_value->field_radio.match(other_value.radio(), legacy))return FALSE;
if(!other_value.speech__ctm().is_bound()) return FALSE;
if(!single_value->field_speech__ctm.match(other_value.speech__ctm(), legacy))return FALSE;
if(!other_value.speech__ver().is_bound()) return FALSE;
if(!single_value->field_speech__ver.match(other_value.speech__ver(), legacy))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if((other_value.data().ispresent() ? !single_value->field_data.match((const MNCC__bearer__cap__data&)other_value.data(), legacy) : !single_value->field_data.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap.");
}
return FALSE;
}

boolean MNCC__bearer__cap_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_transfer.is_bound()) return TRUE;
if (single_value->field_mode.is_bound()) return TRUE;
if (single_value->field_coding.is_bound()) return TRUE;
if (single_value->field_radio.is_bound()) return TRUE;
if (single_value->field_speech__ctm.is_bound()) return TRUE;
if (single_value->field_speech__ver.is_bound()) return TRUE;
if (single_value->field_data.is_omit() || single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__bearer__cap_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_transfer.is_value()) return FALSE;
if (!single_value->field_mode.is_value()) return FALSE;
if (!single_value->field_coding.is_value()) return FALSE;
if (!single_value->field_radio.is_value()) return FALSE;
if (!single_value->field_speech__ctm.is_value()) return FALSE;
if (!single_value->field_speech__ver.is_value()) return FALSE;
if (!single_value->field_data.is_omit() && !single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void MNCC__bearer__cap_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__bearer__cap MNCC__bearer__cap_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
MNCC__bearer__cap ret_val;
if (single_value->field_transfer.is_bound()) {
ret_val.transfer() = single_value->field_transfer.valueof();
}
if (single_value->field_mode.is_bound()) {
ret_val.mode() = single_value->field_mode.valueof();
}
if (single_value->field_coding.is_bound()) {
ret_val.coding() = single_value->field_coding.valueof();
}
if (single_value->field_radio.is_bound()) {
ret_val.radio() = single_value->field_radio.valueof();
}
if (single_value->field_speech__ctm.is_bound()) {
ret_val.speech__ctm() = single_value->field_speech__ctm.valueof();
}
if (single_value->field_speech__ver.is_bound()) {
ret_val.speech__ver() = single_value->field_speech__ver.valueof();
}
if (single_value->field_data.is_omit()) ret_val.data() = OMIT_VALUE;
else if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void MNCC__bearer__cap_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_bearer_cap.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__bearer__cap_template[list_length];
}

MNCC__bearer__cap_template& MNCC__bearer__cap_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_bearer_cap.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_bearer_cap.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__bearer__cap_template::transfer()
{
set_specific();
return single_value->field_transfer;
}

const INTEGER_template& MNCC__bearer__cap_template::transfer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field transfer of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_transfer;
}

INTEGER_template& MNCC__bearer__cap_template::mode()
{
set_specific();
return single_value->field_mode;
}

const INTEGER_template& MNCC__bearer__cap_template::mode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mode of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_mode;
}

INTEGER_template& MNCC__bearer__cap_template::coding()
{
set_specific();
return single_value->field_coding;
}

const INTEGER_template& MNCC__bearer__cap_template::coding() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field coding of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_coding;
}

INTEGER_template& MNCC__bearer__cap_template::radio()
{
set_specific();
return single_value->field_radio;
}

const INTEGER_template& MNCC__bearer__cap_template::radio() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field radio of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_radio;
}

INTEGER_template& MNCC__bearer__cap_template::speech__ctm()
{
set_specific();
return single_value->field_speech__ctm;
}

const INTEGER_template& MNCC__bearer__cap_template::speech__ctm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speech_ctm of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_speech__ctm;
}

MNCC__speech__vers_template& MNCC__bearer__cap_template::speech__ver()
{
set_specific();
return single_value->field_speech__ver;
}

const MNCC__speech__vers_template& MNCC__bearer__cap_template::speech__ver() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speech_ver of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_speech__ver;
}

MNCC__bearer__cap__data_template& MNCC__bearer__cap_template::data()
{
set_specific();
return single_value->field_data;
}

const MNCC__bearer__cap__data_template& MNCC__bearer__cap_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @MNCC_Types.MNCC_bearer_cap.");
return single_value->field_data;
}

int MNCC__bearer__cap_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 6;
      if (single_value->field_data.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_bearer_cap containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap.");
  }
  return 0;
}

void MNCC__bearer__cap_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ transfer := ");
single_value->field_transfer.log();
TTCN_Logger::log_event_str(", mode := ");
single_value->field_mode.log();
TTCN_Logger::log_event_str(", coding := ");
single_value->field_coding.log();
TTCN_Logger::log_event_str(", radio := ");
single_value->field_radio.log();
TTCN_Logger::log_event_str(", speech_ctm := ");
single_value->field_speech__ctm.log();
TTCN_Logger::log_event_str(", speech_ver := ");
single_value->field_speech__ver.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__bearer__cap_template::log_match(const MNCC__bearer__cap& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_transfer.match(match_value.transfer(), legacy)){
TTCN_Logger::log_logmatch_info(".transfer");
single_value->field_transfer.log_match(match_value.transfer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mode.match(match_value.mode(), legacy)){
TTCN_Logger::log_logmatch_info(".mode");
single_value->field_mode.log_match(match_value.mode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_coding.match(match_value.coding(), legacy)){
TTCN_Logger::log_logmatch_info(".coding");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_radio.match(match_value.radio(), legacy)){
TTCN_Logger::log_logmatch_info(".radio");
single_value->field_radio.log_match(match_value.radio(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speech__ctm.match(match_value.speech__ctm(), legacy)){
TTCN_Logger::log_logmatch_info(".speech_ctm");
single_value->field_speech__ctm.log_match(match_value.speech__ctm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speech__ver.match(match_value.speech__ver(), legacy)){
TTCN_Logger::log_logmatch_info(".speech_ver");
single_value->field_speech__ver.log_match(match_value.speech__ver(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.data().ispresent()){
if(!single_value->field_data.match(match_value.data(), legacy)){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_data.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".data := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_data.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ transfer := ");
single_value->field_transfer.log_match(match_value.transfer(), legacy);
TTCN_Logger::log_event_str(", mode := ");
single_value->field_mode.log_match(match_value.mode(), legacy);
TTCN_Logger::log_event_str(", coding := ");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::log_event_str(", radio := ");
single_value->field_radio.log_match(match_value.radio(), legacy);
TTCN_Logger::log_event_str(", speech_ctm := ");
single_value->field_speech__ctm.log_match(match_value.speech__ctm(), legacy);
TTCN_Logger::log_event_str(", speech_ver := ");
single_value->field_speech__ver.log_match(match_value.speech__ver(), legacy);
TTCN_Logger::log_event_str(", data := ");
if (match_value.data().ispresent()) single_value->field_data.log_match(match_value.data(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_data.log();
if (single_value->field_data.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__bearer__cap_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_transfer.encode_text(text_buf);
single_value->field_mode.encode_text(text_buf);
single_value->field_coding.encode_text(text_buf);
single_value->field_radio.encode_text(text_buf);
single_value->field_speech__ctm.encode_text(text_buf);
single_value->field_speech__ver.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_bearer_cap.");
}
}

void MNCC__bearer__cap_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_transfer.decode_text(text_buf);
single_value->field_mode.decode_text(text_buf);
single_value->field_coding.decode_text(text_buf);
single_value->field_radio.decode_text(text_buf);
single_value->field_speech__ctm.decode_text(text_buf);
single_value->field_speech__ver.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__bearer__cap_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_bearer_cap.");
}
}

void MNCC__bearer__cap_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__bearer__cap_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_bearer_cap has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) transfer().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mode().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) radio().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) speech__ctm().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speech__ver().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transfer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transfer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "radio")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          radio().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speech_ctm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speech__ctm().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speech_ver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speech__ver().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_bearer_cap: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_bearer_cap");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__bearer__cap_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_transfer.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_mode.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_coding.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_radio.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_speech__ctm.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_speech__ver.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_bearer_cap");
}

boolean MNCC__bearer__cap_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__bearer__cap_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GSM48__type__of__number::GSM48__type__of__number()
{
enum_value = UNBOUND_VALUE;
}

GSM48__type__of__number::GSM48__type__of__number(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_type_of_number with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__type__of__number::GSM48__type__of__number(enum_type other_value)
{
enum_value = other_value;
}

GSM48__type__of__number::GSM48__type__of__number(const GSM48__type__of__number& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
enum_value = other_value.enum_value;
}

GSM48__type__of__number& GSM48__type__of__number::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_type_of_number.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__type__of__number& GSM48__type__of__number::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__type__of__number& GSM48__type__of__number::operator=(const GSM48__type__of__number& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__type__of__number::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value == other_value;
}

boolean GSM48__type__of__number::operator==(const GSM48__type__of__number& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value == other_value.enum_value;
}

boolean GSM48__type__of__number::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value < other_value;
}

boolean GSM48__type__of__number::operator<(const GSM48__type__of__number& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value < other_value.enum_value;
}

boolean GSM48__type__of__number::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value > other_value;
}

boolean GSM48__type__of__number::operator>(const GSM48__type__of__number& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value > other_value.enum_value;
}

const char *GSM48__type__of__number::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__TON__UNKNOWN: return "GSM48_TON_UNKNOWN";
case GSM48__TON__INTERNATIONAL: return "GSM48_TON_INTERNATIONAL";
case GSM48__TON__NATIONAL: return "GSM48_TON_NATIONAL";
case GSM48__TON__NETWORK__SPECIFIC: return "GSM48_TON_NETWORK_SPECIFIC";
case GSM48__TON__SHORT__CODE: return "GSM48_TON_SHORT_CODE";
default: return "<unknown>";
}
}

GSM48__type__of__number::enum_type GSM48__type__of__number::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_TON_UNKNOWN")) return GSM48__TON__UNKNOWN;
else if (!strcmp(str_par, "GSM48_TON_INTERNATIONAL")) return GSM48__TON__INTERNATIONAL;
else if (!strcmp(str_par, "GSM48_TON_NATIONAL")) return GSM48__TON__NATIONAL;
else if (!strcmp(str_par, "GSM48_TON_NETWORK_SPECIFIC")) return GSM48__TON__NETWORK__SPECIFIC;
else if (!strcmp(str_par, "GSM48_TON_SHORT_CODE")) return GSM48__TON__SHORT__CODE;
else return UNKNOWN_VALUE;
}

boolean GSM48__type__of__number::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int GSM48__type__of__number::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_type_of_number.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__type__of__number::enum2int(const GSM48__type__of__number& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_type_of_number.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__type__of__number::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_type_of_number.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__type__of__number::operator GSM48__type__of__number::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_type_of_number.");
return enum_value;
}

void GSM48__type__of__number::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__type__of__number::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_type_of_number");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_type_of_number.");
  }
}

void GSM48__type__of__number::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
text_buf.push_int(enum_value);
}

void GSM48__type__of__number::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_type_of_number.", enum_value);
}

void GSM48__type__of__number::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__type__of__number::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__type__of__number::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__type__of__number::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__type__of__number_template::copy_template(const GSM48__type__of__number_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__type__of__number_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_type_of_number.");
}
}

GSM48__type__of__number_template::GSM48__type__of__number_template()
{
}

GSM48__type__of__number_template::GSM48__type__of__number_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__type__of__number_template::GSM48__type__of__number_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__type__of__number::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_type_of_number with unknown numeric value %d.", other_value);
single_value = (GSM48__type__of__number::enum_type)other_value;
}

GSM48__type__of__number_template::GSM48__type__of__number_template(GSM48__type__of__number::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__type__of__number_template::GSM48__type__of__number_template(const GSM48__type__of__number& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__type__of__number::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number.");
single_value = other_value.enum_value;
}

GSM48__type__of__number_template::GSM48__type__of__number_template(const OPTIONAL<GSM48__type__of__number>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__type__of__number::enum_type)(const GSM48__type__of__number&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_type_of_number from an unbound optional field.");
}
}

GSM48__type__of__number_template::GSM48__type__of__number_template(const GSM48__type__of__number_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__type__of__number_template::~GSM48__type__of__number_template()
{
clean_up();
}

boolean GSM48__type__of__number_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__type__of__number_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__type__of__number::UNBOUND_VALUE;
}

void GSM48__type__of__number_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(int other_value)
{
if (!GSM48__type__of__number::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_type_of_number.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__type__of__number::enum_type)other_value;
return *this;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(GSM48__type__of__number::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(const GSM48__type__of__number& other_value)
{
if (other_value.enum_value == GSM48__type__of__number::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_type_of_number to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(const OPTIONAL<GSM48__type__of__number>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__type__of__number::enum_type)(const GSM48__type__of__number&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_type_of_number.");
}
return *this;
}

GSM48__type__of__number_template& GSM48__type__of__number_template::operator=(const GSM48__type__of__number_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__type__of__number_template::match(GSM48__type__of__number::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_type_of_number.");
}
return FALSE;
}

boolean GSM48__type__of__number_template::match(const GSM48__type__of__number& other_value, boolean) const
{
if (other_value.enum_value == GSM48__type__of__number::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_type_of_number with an unbound value.");
return match(other_value.enum_value);
}

GSM48__type__of__number::enum_type GSM48__type__of__number_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_type_of_number.");
return single_value;
}

void GSM48__type__of__number_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_type_of_number.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__type__of__number_template[list_length];
}

GSM48__type__of__number_template& GSM48__type__of__number_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_type_of_number.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_type_of_number.");
return value_list.list_value[list_index];
}

void GSM48__type__of__number_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__type__of__number::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__type__of__number_template::log_match(const GSM48__type__of__number& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__type__of__number_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_type_of_number.");
}
}

void GSM48__type__of__number_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__type__of__number::enum_type)text_buf.pull_int().get_val();
if (!GSM48__type__of__number::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_type_of_number.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__type__of__number_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_type_of_number.");
}
}

boolean GSM48__type__of__number_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__type__of__number_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__type__of__number_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__type__of__number_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__type__of__number::enum_type enum_val = GSM48__type__of__number::str_to_enum(m_p->get_enumerated());
    if (!GSM48__type__of__number::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_type_of_number.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_type_of_number");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__type__of__number_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_type_of_number");
}

GSM48__num__plan__ind::GSM48__num__plan__ind()
{
enum_value = UNBOUND_VALUE;
}

GSM48__num__plan__ind::GSM48__num__plan__ind(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_num_plan_ind with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__num__plan__ind::GSM48__num__plan__ind(enum_type other_value)
{
enum_value = other_value;
}

GSM48__num__plan__ind::GSM48__num__plan__ind(const GSM48__num__plan__ind& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
enum_value = other_value.enum_value;
}

GSM48__num__plan__ind& GSM48__num__plan__ind::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_num_plan_ind.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__num__plan__ind& GSM48__num__plan__ind::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__num__plan__ind& GSM48__num__plan__ind::operator=(const GSM48__num__plan__ind& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__num__plan__ind::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value == other_value;
}

boolean GSM48__num__plan__ind::operator==(const GSM48__num__plan__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value == other_value.enum_value;
}

boolean GSM48__num__plan__ind::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value < other_value;
}

boolean GSM48__num__plan__ind::operator<(const GSM48__num__plan__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value < other_value.enum_value;
}

boolean GSM48__num__plan__ind::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value > other_value;
}

boolean GSM48__num__plan__ind::operator>(const GSM48__num__plan__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value > other_value.enum_value;
}

const char *GSM48__num__plan__ind::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__NUMPLAN__UNKNOWN: return "GSM48_NUMPLAN_UNKNOWN";
case GSM48__NUMPLAN__E164: return "GSM48_NUMPLAN_E164";
case GSM48__NUMPLAN__X121: return "GSM48_NUMPLAN_X121";
case GSM48__NUMPLAN__F69: return "GSM48_NUMPLAN_F69";
case GSM48__NUMPLAN__NATIONAL: return "GSM48_NUMPLAN_NATIONAL";
case GSM48__NUMPLAN__PRIVATE: return "GSM48_NUMPLAN_PRIVATE";
case GSM48__NUMPLAN__CTS: return "GSM48_NUMPLAN_CTS";
case GSM48__NUMPLAN__RESERVED: return "GSM48_NUMPLAN_RESERVED";
default: return "<unknown>";
}
}

GSM48__num__plan__ind::enum_type GSM48__num__plan__ind::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_NUMPLAN_UNKNOWN")) return GSM48__NUMPLAN__UNKNOWN;
else if (!strcmp(str_par, "GSM48_NUMPLAN_E164")) return GSM48__NUMPLAN__E164;
else if (!strcmp(str_par, "GSM48_NUMPLAN_X121")) return GSM48__NUMPLAN__X121;
else if (!strcmp(str_par, "GSM48_NUMPLAN_F69")) return GSM48__NUMPLAN__F69;
else if (!strcmp(str_par, "GSM48_NUMPLAN_NATIONAL")) return GSM48__NUMPLAN__NATIONAL;
else if (!strcmp(str_par, "GSM48_NUMPLAN_PRIVATE")) return GSM48__NUMPLAN__PRIVATE;
else if (!strcmp(str_par, "GSM48_NUMPLAN_CTS")) return GSM48__NUMPLAN__CTS;
else if (!strcmp(str_par, "GSM48_NUMPLAN_RESERVED")) return GSM48__NUMPLAN__RESERVED;
else return UNKNOWN_VALUE;
}

boolean GSM48__num__plan__ind::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 3:
case 4:
case 8:
case 9:
case 11:
case 15:
return TRUE;
default:
return FALSE;
}
}

int GSM48__num__plan__ind::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_num_plan_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__num__plan__ind::enum2int(const GSM48__num__plan__ind& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_num_plan_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__num__plan__ind::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_num_plan_ind.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__num__plan__ind::operator GSM48__num__plan__ind::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return enum_value;
}

void GSM48__num__plan__ind::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__num__plan__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_num_plan_ind");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_num_plan_ind.");
  }
}

void GSM48__num__plan__ind::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
text_buf.push_int(enum_value);
}

void GSM48__num__plan__ind::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_num_plan_ind.", enum_value);
}

void GSM48__num__plan__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__num__plan__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__num__plan__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__num__plan__ind::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

void GSM48__num__plan__ind_template::copy_template(const GSM48__num__plan__ind_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__num__plan__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
}
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template()
{
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__num__plan__ind::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_num_plan_ind with unknown numeric value %d.", other_value);
single_value = (GSM48__num__plan__ind::enum_type)other_value;
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(GSM48__num__plan__ind::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(const GSM48__num__plan__ind& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__num__plan__ind::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
single_value = other_value.enum_value;
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(const OPTIONAL<GSM48__num__plan__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__num__plan__ind::enum_type)(const GSM48__num__plan__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_num_plan_ind from an unbound optional field.");
}
}

GSM48__num__plan__ind_template::GSM48__num__plan__ind_template(const GSM48__num__plan__ind_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__num__plan__ind_template::~GSM48__num__plan__ind_template()
{
clean_up();
}

boolean GSM48__num__plan__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__num__plan__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__num__plan__ind::UNBOUND_VALUE;
}

void GSM48__num__plan__ind_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(int other_value)
{
if (!GSM48__num__plan__ind::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_num_plan_ind.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__num__plan__ind::enum_type)other_value;
return *this;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(GSM48__num__plan__ind::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(const GSM48__num__plan__ind& other_value)
{
if (other_value.enum_value == GSM48__num__plan__ind::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_num_plan_ind to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(const OPTIONAL<GSM48__num__plan__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__num__plan__ind::enum_type)(const GSM48__num__plan__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
}
return *this;
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::operator=(const GSM48__num__plan__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__num__plan__ind_template::match(GSM48__num__plan__ind::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
}
return FALSE;
}

boolean GSM48__num__plan__ind_template::match(const GSM48__num__plan__ind& other_value, boolean) const
{
if (other_value.enum_value == GSM48__num__plan__ind::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_num_plan_ind with an unbound value.");
return match(other_value.enum_value);
}

GSM48__num__plan__ind::enum_type GSM48__num__plan__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return single_value;
}

void GSM48__num__plan__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__num__plan__ind_template[list_length];
}

GSM48__num__plan__ind_template& GSM48__num__plan__ind_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
return value_list.list_value[list_index];
}

void GSM48__num__plan__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__num__plan__ind::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__num__plan__ind_template::log_match(const GSM48__num__plan__ind& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__num__plan__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
}
}

void GSM48__num__plan__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__num__plan__ind::enum_type)text_buf.pull_int().get_val();
if (!GSM48__num__plan__ind::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_num_plan_ind.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__num__plan__ind_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_num_plan_ind.");
}
}

boolean GSM48__num__plan__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__num__plan__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__num__plan__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__num__plan__ind_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__num__plan__ind::enum_type enum_val = GSM48__num__plan__ind::str_to_enum(m_p->get_enumerated());
    if (!GSM48__num__plan__ind::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_num_plan_ind.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_num_plan_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__num__plan__ind_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_num_plan_ind");
}

GSM48__present__ind::GSM48__present__ind()
{
enum_value = UNBOUND_VALUE;
}

GSM48__present__ind::GSM48__present__ind(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_present_ind with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__present__ind::GSM48__present__ind(enum_type other_value)
{
enum_value = other_value;
}

GSM48__present__ind::GSM48__present__ind(const GSM48__present__ind& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
enum_value = other_value.enum_value;
}

GSM48__present__ind& GSM48__present__ind::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_present_ind.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__present__ind& GSM48__present__ind::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__present__ind& GSM48__present__ind::operator=(const GSM48__present__ind& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__present__ind::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value == other_value;
}

boolean GSM48__present__ind::operator==(const GSM48__present__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value == other_value.enum_value;
}

boolean GSM48__present__ind::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value < other_value;
}

boolean GSM48__present__ind::operator<(const GSM48__present__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value < other_value.enum_value;
}

boolean GSM48__present__ind::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value > other_value;
}

boolean GSM48__present__ind::operator>(const GSM48__present__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value > other_value.enum_value;
}

const char *GSM48__present__ind::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__PRES__IND__ALLOWED: return "GSM48_PRES_IND_ALLOWED";
case GSM48__PRES__IND__RESTRICTED: return "GSM48_PRES_IND_RESTRICTED";
case GSM48__PRES__IND__NUM__NOT__AVAIL: return "GSM48_PRES_IND_NUM_NOT_AVAIL";
case GSM48__PRES__IND__RESERVED: return "GSM48_PRES_IND_RESERVED";
default: return "<unknown>";
}
}

GSM48__present__ind::enum_type GSM48__present__ind::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_PRES_IND_ALLOWED")) return GSM48__PRES__IND__ALLOWED;
else if (!strcmp(str_par, "GSM48_PRES_IND_RESTRICTED")) return GSM48__PRES__IND__RESTRICTED;
else if (!strcmp(str_par, "GSM48_PRES_IND_NUM_NOT_AVAIL")) return GSM48__PRES__IND__NUM__NOT__AVAIL;
else if (!strcmp(str_par, "GSM48_PRES_IND_RESERVED")) return GSM48__PRES__IND__RESERVED;
else return UNKNOWN_VALUE;
}

boolean GSM48__present__ind::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__present__ind::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_present_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__present__ind::enum2int(const GSM48__present__ind& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_present_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__present__ind::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_present_ind.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__present__ind::operator GSM48__present__ind::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_present_ind.");
return enum_value;
}

void GSM48__present__ind::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__present__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_present_ind");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_present_ind.");
  }
}

void GSM48__present__ind::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
text_buf.push_int(enum_value);
}

void GSM48__present__ind::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_present_ind.", enum_value);
}

void GSM48__present__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__present__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__present__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__present__ind::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__present__ind_template::copy_template(const GSM48__present__ind_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__present__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_present_ind.");
}
}

GSM48__present__ind_template::GSM48__present__ind_template()
{
}

GSM48__present__ind_template::GSM48__present__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__present__ind_template::GSM48__present__ind_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__present__ind::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_present_ind with unknown numeric value %d.", other_value);
single_value = (GSM48__present__ind::enum_type)other_value;
}

GSM48__present__ind_template::GSM48__present__ind_template(GSM48__present__ind::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__present__ind_template::GSM48__present__ind_template(const GSM48__present__ind& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__present__ind::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_present_ind.");
single_value = other_value.enum_value;
}

GSM48__present__ind_template::GSM48__present__ind_template(const OPTIONAL<GSM48__present__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__present__ind::enum_type)(const GSM48__present__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_present_ind from an unbound optional field.");
}
}

GSM48__present__ind_template::GSM48__present__ind_template(const GSM48__present__ind_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__present__ind_template::~GSM48__present__ind_template()
{
clean_up();
}

boolean GSM48__present__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__present__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__present__ind::UNBOUND_VALUE;
}

void GSM48__present__ind_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(int other_value)
{
if (!GSM48__present__ind::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_present_ind.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__present__ind::enum_type)other_value;
return *this;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(GSM48__present__ind::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(const GSM48__present__ind& other_value)
{
if (other_value.enum_value == GSM48__present__ind::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_present_ind to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(const OPTIONAL<GSM48__present__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__present__ind::enum_type)(const GSM48__present__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_present_ind.");
}
return *this;
}

GSM48__present__ind_template& GSM48__present__ind_template::operator=(const GSM48__present__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__present__ind_template::match(GSM48__present__ind::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_present_ind.");
}
return FALSE;
}

boolean GSM48__present__ind_template::match(const GSM48__present__ind& other_value, boolean) const
{
if (other_value.enum_value == GSM48__present__ind::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_present_ind with an unbound value.");
return match(other_value.enum_value);
}

GSM48__present__ind::enum_type GSM48__present__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_present_ind.");
return single_value;
}

void GSM48__present__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_present_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__present__ind_template[list_length];
}

GSM48__present__ind_template& GSM48__present__ind_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_present_ind.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_present_ind.");
return value_list.list_value[list_index];
}

void GSM48__present__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__present__ind::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__present__ind_template::log_match(const GSM48__present__ind& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__present__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_present_ind.");
}
}

void GSM48__present__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__present__ind::enum_type)text_buf.pull_int().get_val();
if (!GSM48__present__ind::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_present_ind.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__present__ind_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_present_ind.");
}
}

boolean GSM48__present__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__present__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__present__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__present__ind_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__present__ind::enum_type enum_val = GSM48__present__ind::str_to_enum(m_p->get_enumerated());
    if (!GSM48__present__ind::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_present_ind.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_present_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__present__ind_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_present_ind");
}

GSM48__screening__ind::GSM48__screening__ind()
{
enum_value = UNBOUND_VALUE;
}

GSM48__screening__ind::GSM48__screening__ind(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_screening_ind with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__screening__ind::GSM48__screening__ind(enum_type other_value)
{
enum_value = other_value;
}

GSM48__screening__ind::GSM48__screening__ind(const GSM48__screening__ind& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
enum_value = other_value.enum_value;
}

GSM48__screening__ind& GSM48__screening__ind::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_screening_ind.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__screening__ind& GSM48__screening__ind::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__screening__ind& GSM48__screening__ind::operator=(const GSM48__screening__ind& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__screening__ind::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value == other_value;
}

boolean GSM48__screening__ind::operator==(const GSM48__screening__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value == other_value.enum_value;
}

boolean GSM48__screening__ind::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value < other_value;
}

boolean GSM48__screening__ind::operator<(const GSM48__screening__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value < other_value.enum_value;
}

boolean GSM48__screening__ind::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value > other_value;
}

boolean GSM48__screening__ind::operator>(const GSM48__screening__ind& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value > other_value.enum_value;
}

const char *GSM48__screening__ind::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__SCR__IND__NOT__SCREENED: return "GSM48_SCR_IND_NOT_SCREENED";
case GSM48__SCR__IND__VERIF__PASSED: return "GSM48_SCR_IND_VERIF_PASSED";
case GSM48__SCR__IND__VERIF__FAILED: return "GSM48_SCR_IND_VERIF_FAILED";
case GSM48__SCR__IND__NETW__PROVIDED: return "GSM48_SCR_IND_NETW_PROVIDED";
default: return "<unknown>";
}
}

GSM48__screening__ind::enum_type GSM48__screening__ind::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_SCR_IND_NOT_SCREENED")) return GSM48__SCR__IND__NOT__SCREENED;
else if (!strcmp(str_par, "GSM48_SCR_IND_VERIF_PASSED")) return GSM48__SCR__IND__VERIF__PASSED;
else if (!strcmp(str_par, "GSM48_SCR_IND_VERIF_FAILED")) return GSM48__SCR__IND__VERIF__FAILED;
else if (!strcmp(str_par, "GSM48_SCR_IND_NETW_PROVIDED")) return GSM48__SCR__IND__NETW__PROVIDED;
else return UNKNOWN_VALUE;
}

boolean GSM48__screening__ind::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__screening__ind::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_screening_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__screening__ind::enum2int(const GSM48__screening__ind& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_screening_ind.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__screening__ind::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_screening_ind.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__screening__ind::operator GSM48__screening__ind::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_screening_ind.");
return enum_value;
}

void GSM48__screening__ind::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__screening__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_screening_ind");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_screening_ind.");
  }
}

void GSM48__screening__ind::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
text_buf.push_int(enum_value);
}

void GSM48__screening__ind::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_screening_ind.", enum_value);
}

void GSM48__screening__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__screening__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__screening__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__screening__ind::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__screening__ind_template::copy_template(const GSM48__screening__ind_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__screening__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_screening_ind.");
}
}

GSM48__screening__ind_template::GSM48__screening__ind_template()
{
}

GSM48__screening__ind_template::GSM48__screening__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__screening__ind_template::GSM48__screening__ind_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__screening__ind::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_screening_ind with unknown numeric value %d.", other_value);
single_value = (GSM48__screening__ind::enum_type)other_value;
}

GSM48__screening__ind_template::GSM48__screening__ind_template(GSM48__screening__ind::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__screening__ind_template::GSM48__screening__ind_template(const GSM48__screening__ind& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__screening__ind::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind.");
single_value = other_value.enum_value;
}

GSM48__screening__ind_template::GSM48__screening__ind_template(const OPTIONAL<GSM48__screening__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__screening__ind::enum_type)(const GSM48__screening__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_screening_ind from an unbound optional field.");
}
}

GSM48__screening__ind_template::GSM48__screening__ind_template(const GSM48__screening__ind_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__screening__ind_template::~GSM48__screening__ind_template()
{
clean_up();
}

boolean GSM48__screening__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__screening__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__screening__ind::UNBOUND_VALUE;
}

void GSM48__screening__ind_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(int other_value)
{
if (!GSM48__screening__ind::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_screening_ind.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__screening__ind::enum_type)other_value;
return *this;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(GSM48__screening__ind::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(const GSM48__screening__ind& other_value)
{
if (other_value.enum_value == GSM48__screening__ind::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_screening_ind to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(const OPTIONAL<GSM48__screening__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__screening__ind::enum_type)(const GSM48__screening__ind&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_screening_ind.");
}
return *this;
}

GSM48__screening__ind_template& GSM48__screening__ind_template::operator=(const GSM48__screening__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__screening__ind_template::match(GSM48__screening__ind::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_screening_ind.");
}
return FALSE;
}

boolean GSM48__screening__ind_template::match(const GSM48__screening__ind& other_value, boolean) const
{
if (other_value.enum_value == GSM48__screening__ind::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_screening_ind with an unbound value.");
return match(other_value.enum_value);
}

GSM48__screening__ind::enum_type GSM48__screening__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_screening_ind.");
return single_value;
}

void GSM48__screening__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_screening_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__screening__ind_template[list_length];
}

GSM48__screening__ind_template& GSM48__screening__ind_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_screening_ind.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_screening_ind.");
return value_list.list_value[list_index];
}

void GSM48__screening__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__screening__ind::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__screening__ind_template::log_match(const GSM48__screening__ind& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__screening__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_screening_ind.");
}
}

void GSM48__screening__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__screening__ind::enum_type)text_buf.pull_int().get_val();
if (!GSM48__screening__ind::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_screening_ind.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__screening__ind_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_screening_ind.");
}
}

boolean GSM48__screening__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__screening__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__screening__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__screening__ind_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__screening__ind::enum_type enum_val = GSM48__screening__ind::str_to_enum(m_p->get_enumerated());
    if (!GSM48__screening__ind::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_screening_ind.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_screening_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__screening__ind_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_screening_ind");
}

MNCC__number::MNCC__number()
{
}

MNCC__number::MNCC__number(const GSM48__type__of__number& par_number__type,
    const GSM48__num__plan__ind& par_plan,
    const GSM48__present__ind& par_presence,
    const GSM48__screening__ind& par_screen,
    const CHARSTRING& par_number)
  :   field_number__type(par_number__type),
  field_plan(par_plan),
  field_presence(par_presence),
  field_screen(par_screen),
  field_number(par_number)
{
}

MNCC__number::MNCC__number(const MNCC__number& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_number.");
if (other_value.number__type().is_bound()) field_number__type = other_value.number__type();
else field_number__type.clean_up();
if (other_value.plan().is_bound()) field_plan = other_value.plan();
else field_plan.clean_up();
if (other_value.presence().is_bound()) field_presence = other_value.presence();
else field_presence.clean_up();
if (other_value.screen().is_bound()) field_screen = other_value.screen();
else field_screen.clean_up();
if (other_value.number().is_bound()) field_number = other_value.number();
else field_number.clean_up();
}

void MNCC__number::clean_up()
{
field_number__type.clean_up();
field_plan.clean_up();
field_presence.clean_up();
field_screen.clean_up();
field_number.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__number::get_descriptor() const { return &MNCC__number_descr_; }
MNCC__number& MNCC__number::operator=(const MNCC__number& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_number.");
  if (other_value.number__type().is_bound()) field_number__type = other_value.number__type();
  else field_number__type.clean_up();
  if (other_value.plan().is_bound()) field_plan = other_value.plan();
  else field_plan.clean_up();
  if (other_value.presence().is_bound()) field_presence = other_value.presence();
  else field_presence.clean_up();
  if (other_value.screen().is_bound()) field_screen = other_value.screen();
  else field_screen.clean_up();
  if (other_value.number().is_bound()) field_number = other_value.number();
  else field_number.clean_up();
}
return *this;
}

boolean MNCC__number::operator==(const MNCC__number& other_value) const
{
return field_number__type==other_value.field_number__type
  && field_plan==other_value.field_plan
  && field_presence==other_value.field_presence
  && field_screen==other_value.field_screen
  && field_number==other_value.field_number;
}

boolean MNCC__number::is_bound() const
{
if(field_number__type.is_bound()) return TRUE;
if(field_plan.is_bound()) return TRUE;
if(field_presence.is_bound()) return TRUE;
if(field_screen.is_bound()) return TRUE;
if(field_number.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__number::is_value() const
{
if(!field_number__type.is_value()) return FALSE;
if(!field_plan.is_value()) return FALSE;
if(!field_presence.is_value()) return FALSE;
if(!field_screen.is_value()) return FALSE;
if(!field_number.is_value()) return FALSE;
return TRUE;
}
void MNCC__number::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ number_type := ");
field_number__type.log();
TTCN_Logger::log_event_str(", plan := ");
field_plan.log();
TTCN_Logger::log_event_str(", presence := ");
field_presence.log();
TTCN_Logger::log_event_str(", screen := ");
field_screen.log();
TTCN_Logger::log_event_str(", number := ");
field_number.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__number::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_number has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) number__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) plan().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) presence().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) screen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) number().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "number_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          number__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plan")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plan().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "presence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          presence().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "screen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          screen().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "number")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          number().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_number: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_number");
  }
}

void MNCC__number::set_implicit_omit()
{
if (number__type().is_bound()) number__type().set_implicit_omit();
if (plan().is_bound()) plan().set_implicit_omit();
if (presence().is_bound()) presence().set_implicit_omit();
if (screen().is_bound()) screen().set_implicit_omit();
if (number().is_bound()) number().set_implicit_omit();
}

void MNCC__number::encode_text(Text_Buf& text_buf) const
{
field_number__type.encode_text(text_buf);
field_plan.encode_text(text_buf);
field_presence.encode_text(text_buf);
field_screen.encode_text(text_buf);
field_number.encode_text(text_buf);
}

void MNCC__number::decode_text(Text_Buf& text_buf)
{
field_number__type.decode_text(text_buf);
field_plan.decode_text(text_buf);
field_presence.decode_text(text_buf);
field_screen.decode_text(text_buf);
field_number.decode_text(text_buf);
}

void MNCC__number::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__number::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__number::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__number_number__type_descr_.raw->forceomit);
  decoded_field_length = field_number__type.RAW_decode(MNCC__number_number__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__number_plan_descr_.raw->forceomit);
  decoded_field_length = field_plan.RAW_decode(MNCC__number_plan_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__number_presence_descr_.raw->forceomit);
  decoded_field_length = field_presence.RAW_decode(MNCC__number_presence_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__number_screen_descr_.raw->forceomit);
  decoded_field_length = field_screen.RAW_decode(MNCC__number_screen_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__number_number_descr_.raw->forceomit);
  decoded_field_length = field_number.RAW_decode(MNCC__number_number_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__number::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__number_number__type_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__number_plan_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__number_presence_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__number_screen_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__number_number_descr_.raw);
  encoded_length += field_number__type.RAW_encode(MNCC__number_number__type_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_plan.RAW_encode(MNCC__number_plan_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_presence.RAW_encode(MNCC__number_presence_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_screen.RAW_encode(MNCC__number_screen_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_number.RAW_encode(MNCC__number_number_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

struct MNCC__number_template::single_value_struct {
GSM48__type__of__number_template field_number__type;
GSM48__num__plan__ind_template field_plan;
GSM48__present__ind_template field_presence;
GSM48__screening__ind_template field_screen;
CHARSTRING_template field_number;
};

void MNCC__number_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_number__type = ANY_VALUE;
single_value->field_plan = ANY_VALUE;
single_value->field_presence = ANY_VALUE;
single_value->field_screen = ANY_VALUE;
single_value->field_number = ANY_VALUE;
}
}
}

void MNCC__number_template::copy_value(const MNCC__number& other_value)
{
single_value = new single_value_struct;
if (other_value.number__type().is_bound()) {
  single_value->field_number__type = other_value.number__type();
} else {
  single_value->field_number__type.clean_up();
}
if (other_value.plan().is_bound()) {
  single_value->field_plan = other_value.plan();
} else {
  single_value->field_plan.clean_up();
}
if (other_value.presence().is_bound()) {
  single_value->field_presence = other_value.presence();
} else {
  single_value->field_presence.clean_up();
}
if (other_value.screen().is_bound()) {
  single_value->field_screen = other_value.screen();
} else {
  single_value->field_screen.clean_up();
}
if (other_value.number().is_bound()) {
  single_value->field_number = other_value.number();
} else {
  single_value->field_number.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__number_template::copy_template(const MNCC__number_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.number__type().get_selection()) {
single_value->field_number__type = other_value.number__type();
} else {
single_value->field_number__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.plan().get_selection()) {
single_value->field_plan = other_value.plan();
} else {
single_value->field_plan.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.presence().get_selection()) {
single_value->field_presence = other_value.presence();
} else {
single_value->field_presence.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.screen().get_selection()) {
single_value->field_screen = other_value.screen();
} else {
single_value->field_screen.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.number().get_selection()) {
single_value->field_number = other_value.number();
} else {
single_value->field_number.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__number_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_number.");
break;
}
set_selection(other_value);
}

MNCC__number_template::MNCC__number_template()
{
}

MNCC__number_template::MNCC__number_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__number_template::MNCC__number_template(const MNCC__number& other_value)
{
copy_value(other_value);
}

MNCC__number_template::MNCC__number_template(const OPTIONAL<MNCC__number>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__number&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_number from an unbound optional field.");
}
}

MNCC__number_template::MNCC__number_template(const MNCC__number_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__number_template::~MNCC__number_template()
{
clean_up();
}

MNCC__number_template& MNCC__number_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__number_template& MNCC__number_template::operator=(const MNCC__number& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__number_template& MNCC__number_template::operator=(const OPTIONAL<MNCC__number>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__number&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_number.");
}
return *this;
}

MNCC__number_template& MNCC__number_template::operator=(const MNCC__number_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__number_template::match(const MNCC__number& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.number__type().is_bound()) return FALSE;
if(!single_value->field_number__type.match(other_value.number__type(), legacy))return FALSE;
if(!other_value.plan().is_bound()) return FALSE;
if(!single_value->field_plan.match(other_value.plan(), legacy))return FALSE;
if(!other_value.presence().is_bound()) return FALSE;
if(!single_value->field_presence.match(other_value.presence(), legacy))return FALSE;
if(!other_value.screen().is_bound()) return FALSE;
if(!single_value->field_screen.match(other_value.screen(), legacy))return FALSE;
if(!other_value.number().is_bound()) return FALSE;
if(!single_value->field_number.match(other_value.number(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_number.");
}
return FALSE;
}

boolean MNCC__number_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_number__type.is_bound()) return TRUE;
if (single_value->field_plan.is_bound()) return TRUE;
if (single_value->field_presence.is_bound()) return TRUE;
if (single_value->field_screen.is_bound()) return TRUE;
if (single_value->field_number.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__number_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_number__type.is_value()) return FALSE;
if (!single_value->field_plan.is_value()) return FALSE;
if (!single_value->field_presence.is_value()) return FALSE;
if (!single_value->field_screen.is_value()) return FALSE;
if (!single_value->field_number.is_value()) return FALSE;
return TRUE;
}

void MNCC__number_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__number MNCC__number_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_number.");
MNCC__number ret_val;
if (single_value->field_number__type.is_bound()) {
ret_val.number__type() = single_value->field_number__type.valueof();
}
if (single_value->field_plan.is_bound()) {
ret_val.plan() = single_value->field_plan.valueof();
}
if (single_value->field_presence.is_bound()) {
ret_val.presence() = single_value->field_presence.valueof();
}
if (single_value->field_screen.is_bound()) {
ret_val.screen() = single_value->field_screen.valueof();
}
if (single_value->field_number.is_bound()) {
ret_val.number() = single_value->field_number.valueof();
}
return ret_val;
}

void MNCC__number_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_number.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__number_template[list_length];
}

MNCC__number_template& MNCC__number_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_number.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_number.");
return value_list.list_value[list_index];
}

GSM48__type__of__number_template& MNCC__number_template::number__type()
{
set_specific();
return single_value->field_number__type;
}

const GSM48__type__of__number_template& MNCC__number_template::number__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field number_type of a non-specific template of type @MNCC_Types.MNCC_number.");
return single_value->field_number__type;
}

GSM48__num__plan__ind_template& MNCC__number_template::plan()
{
set_specific();
return single_value->field_plan;
}

const GSM48__num__plan__ind_template& MNCC__number_template::plan() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field plan of a non-specific template of type @MNCC_Types.MNCC_number.");
return single_value->field_plan;
}

GSM48__present__ind_template& MNCC__number_template::presence()
{
set_specific();
return single_value->field_presence;
}

const GSM48__present__ind_template& MNCC__number_template::presence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field presence of a non-specific template of type @MNCC_Types.MNCC_number.");
return single_value->field_presence;
}

GSM48__screening__ind_template& MNCC__number_template::screen()
{
set_specific();
return single_value->field_screen;
}

const GSM48__screening__ind_template& MNCC__number_template::screen() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field screen of a non-specific template of type @MNCC_Types.MNCC_number.");
return single_value->field_screen;
}

CHARSTRING_template& MNCC__number_template::number()
{
set_specific();
return single_value->field_number;
}

const CHARSTRING_template& MNCC__number_template::number() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field number of a non-specific template of type @MNCC_Types.MNCC_number.");
return single_value->field_number;
}

int MNCC__number_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_number containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_number.");
  }
  return 0;
}

void MNCC__number_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ number_type := ");
single_value->field_number__type.log();
TTCN_Logger::log_event_str(", plan := ");
single_value->field_plan.log();
TTCN_Logger::log_event_str(", presence := ");
single_value->field_presence.log();
TTCN_Logger::log_event_str(", screen := ");
single_value->field_screen.log();
TTCN_Logger::log_event_str(", number := ");
single_value->field_number.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__number_template::log_match(const MNCC__number& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_number__type.match(match_value.number__type(), legacy)){
TTCN_Logger::log_logmatch_info(".number_type");
single_value->field_number__type.log_match(match_value.number__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_plan.match(match_value.plan(), legacy)){
TTCN_Logger::log_logmatch_info(".plan");
single_value->field_plan.log_match(match_value.plan(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_presence.match(match_value.presence(), legacy)){
TTCN_Logger::log_logmatch_info(".presence");
single_value->field_presence.log_match(match_value.presence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_screen.match(match_value.screen(), legacy)){
TTCN_Logger::log_logmatch_info(".screen");
single_value->field_screen.log_match(match_value.screen(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_number.match(match_value.number(), legacy)){
TTCN_Logger::log_logmatch_info(".number");
single_value->field_number.log_match(match_value.number(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ number_type := ");
single_value->field_number__type.log_match(match_value.number__type(), legacy);
TTCN_Logger::log_event_str(", plan := ");
single_value->field_plan.log_match(match_value.plan(), legacy);
TTCN_Logger::log_event_str(", presence := ");
single_value->field_presence.log_match(match_value.presence(), legacy);
TTCN_Logger::log_event_str(", screen := ");
single_value->field_screen.log_match(match_value.screen(), legacy);
TTCN_Logger::log_event_str(", number := ");
single_value->field_number.log_match(match_value.number(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__number_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_number__type.encode_text(text_buf);
single_value->field_plan.encode_text(text_buf);
single_value->field_presence.encode_text(text_buf);
single_value->field_screen.encode_text(text_buf);
single_value->field_number.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_number.");
}
}

void MNCC__number_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_number__type.decode_text(text_buf);
single_value->field_plan.decode_text(text_buf);
single_value->field_presence.decode_text(text_buf);
single_value->field_screen.decode_text(text_buf);
single_value->field_number.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__number_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_number.");
}
}

void MNCC__number_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__number_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_number has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) number__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) plan().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) presence().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) screen().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) number().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "number_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          number__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plan")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plan().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "presence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          presence().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "screen")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          screen().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "number")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          number().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_number: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_number");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__number_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_number__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_number");
single_value->field_plan.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_number");
single_value->field_presence.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_number");
single_value->field_screen.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_number");
single_value->field_number.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_number");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_number");
}

boolean MNCC__number_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__number_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GSM48__cause__coding::GSM48__cause__coding()
{
enum_value = UNBOUND_VALUE;
}

GSM48__cause__coding::GSM48__cause__coding(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_cause_coding with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__cause__coding::GSM48__cause__coding(enum_type other_value)
{
enum_value = other_value;
}

GSM48__cause__coding::GSM48__cause__coding(const GSM48__cause__coding& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
enum_value = other_value.enum_value;
}

GSM48__cause__coding& GSM48__cause__coding::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_cause_coding.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__cause__coding& GSM48__cause__coding::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__cause__coding& GSM48__cause__coding::operator=(const GSM48__cause__coding& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__cause__coding::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value == other_value;
}

boolean GSM48__cause__coding::operator==(const GSM48__cause__coding& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value == other_value.enum_value;
}

boolean GSM48__cause__coding::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value < other_value;
}

boolean GSM48__cause__coding::operator<(const GSM48__cause__coding& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value < other_value.enum_value;
}

boolean GSM48__cause__coding::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value > other_value;
}

boolean GSM48__cause__coding::operator>(const GSM48__cause__coding& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value > other_value.enum_value;
}

const char *GSM48__cause__coding::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__CAUSE__CS__Q931: return "GSM48_CAUSE_CS_Q931";
case GSM48__CAUSE__CS__RSVD: return "GSM48_CAUSE_CS_RSVD";
case GSM48__CAUSE__CS__NATIONAL: return "GSM48_CAUSE_CS_NATIONAL";
case GSM48__CAUSE__CS__GSM: return "GSM48_CAUSE_CS_GSM";
default: return "<unknown>";
}
}

GSM48__cause__coding::enum_type GSM48__cause__coding::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_CAUSE_CS_Q931")) return GSM48__CAUSE__CS__Q931;
else if (!strcmp(str_par, "GSM48_CAUSE_CS_RSVD")) return GSM48__CAUSE__CS__RSVD;
else if (!strcmp(str_par, "GSM48_CAUSE_CS_NATIONAL")) return GSM48__CAUSE__CS__NATIONAL;
else if (!strcmp(str_par, "GSM48_CAUSE_CS_GSM")) return GSM48__CAUSE__CS__GSM;
else return UNKNOWN_VALUE;
}

boolean GSM48__cause__coding::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GSM48__cause__coding::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_cause_coding.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__cause__coding::enum2int(const GSM48__cause__coding& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_cause_coding.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__cause__coding::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_cause_coding.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__cause__coding::operator GSM48__cause__coding::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_cause_coding.");
return enum_value;
}

void GSM48__cause__coding::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__cause__coding::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_cause_coding");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_cause_coding.");
  }
}

void GSM48__cause__coding::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
text_buf.push_int(enum_value);
}

void GSM48__cause__coding::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_cause_coding.", enum_value);
}

void GSM48__cause__coding::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__cause__coding::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__cause__coding::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__cause__coding::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GSM48__cause__coding_template::copy_template(const GSM48__cause__coding_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__cause__coding_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_coding.");
}
}

GSM48__cause__coding_template::GSM48__cause__coding_template()
{
}

GSM48__cause__coding_template::GSM48__cause__coding_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__cause__coding_template::GSM48__cause__coding_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__cause__coding::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_cause_coding with unknown numeric value %d.", other_value);
single_value = (GSM48__cause__coding::enum_type)other_value;
}

GSM48__cause__coding_template::GSM48__cause__coding_template(GSM48__cause__coding::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__cause__coding_template::GSM48__cause__coding_template(const GSM48__cause__coding& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__cause__coding::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding.");
single_value = other_value.enum_value;
}

GSM48__cause__coding_template::GSM48__cause__coding_template(const OPTIONAL<GSM48__cause__coding>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__coding::enum_type)(const GSM48__cause__coding&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_cause_coding from an unbound optional field.");
}
}

GSM48__cause__coding_template::GSM48__cause__coding_template(const GSM48__cause__coding_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__cause__coding_template::~GSM48__cause__coding_template()
{
clean_up();
}

boolean GSM48__cause__coding_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__cause__coding_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__cause__coding::UNBOUND_VALUE;
}

void GSM48__cause__coding_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(int other_value)
{
if (!GSM48__cause__coding::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_cause_coding.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__coding::enum_type)other_value;
return *this;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(GSM48__cause__coding::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(const GSM48__cause__coding& other_value)
{
if (other_value.enum_value == GSM48__cause__coding::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_cause_coding to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(const OPTIONAL<GSM48__cause__coding>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__coding::enum_type)(const GSM48__cause__coding&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_cause_coding.");
}
return *this;
}

GSM48__cause__coding_template& GSM48__cause__coding_template::operator=(const GSM48__cause__coding_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__cause__coding_template::match(GSM48__cause__coding::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_coding.");
}
return FALSE;
}

boolean GSM48__cause__coding_template::match(const GSM48__cause__coding& other_value, boolean) const
{
if (other_value.enum_value == GSM48__cause__coding::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_cause_coding with an unbound value.");
return match(other_value.enum_value);
}

GSM48__cause__coding::enum_type GSM48__cause__coding_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_cause_coding.");
return single_value;
}

void GSM48__cause__coding_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_cause_coding.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__cause__coding_template[list_length];
}

GSM48__cause__coding_template& GSM48__cause__coding_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_cause_coding.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_cause_coding.");
return value_list.list_value[list_index];
}

void GSM48__cause__coding_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__cause__coding::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__cause__coding_template::log_match(const GSM48__cause__coding& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__cause__coding_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_coding.");
}
}

void GSM48__cause__coding_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__cause__coding::enum_type)text_buf.pull_int().get_val();
if (!GSM48__cause__coding::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_cause_coding.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__cause__coding_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_cause_coding.");
}
}

boolean GSM48__cause__coding_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__cause__coding_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__cause__coding_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__cause__coding_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__cause__coding::enum_type enum_val = GSM48__cause__coding::str_to_enum(m_p->get_enumerated());
    if (!GSM48__cause__coding::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_cause_coding.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_cause_coding");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__cause__coding_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_cause_coding");
}

GSM48__cause__loc::GSM48__cause__loc()
{
enum_value = UNBOUND_VALUE;
}

GSM48__cause__loc::GSM48__cause__loc(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.GSM48_cause_loc with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GSM48__cause__loc::GSM48__cause__loc(enum_type other_value)
{
enum_value = other_value;
}

GSM48__cause__loc::GSM48__cause__loc(const GSM48__cause__loc& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
enum_value = other_value.enum_value;
}

GSM48__cause__loc& GSM48__cause__loc::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_cause_loc.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GSM48__cause__loc& GSM48__cause__loc::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GSM48__cause__loc& GSM48__cause__loc::operator=(const GSM48__cause__loc& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
enum_value = other_value.enum_value;
return *this;
}

boolean GSM48__cause__loc::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value == other_value;
}

boolean GSM48__cause__loc::operator==(const GSM48__cause__loc& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value == other_value.enum_value;
}

boolean GSM48__cause__loc::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value < other_value;
}

boolean GSM48__cause__loc::operator<(const GSM48__cause__loc& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value < other_value.enum_value;
}

boolean GSM48__cause__loc::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value > other_value;
}

boolean GSM48__cause__loc::operator>(const GSM48__cause__loc& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value > other_value.enum_value;
}

const char *GSM48__cause__loc::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM48__CAUSE__LOC__USER: return "GSM48_CAUSE_LOC_USER";
case GSM48__CAUSE__LOC__PRN__S__LU: return "GSM48_CAUSE_LOC_PRN_S_LU";
case GSM48__CAUSE__LOC__PUN__S__LU: return "GSM48_CAUSE_LOC_PUN_S_LU";
case GSM48__CAUSE__LOC__TRANS__NET: return "GSM48_CAUSE_LOC_TRANS_NET";
case GSM48__CAUSE__LOC__PUN__S__RU: return "GSM48_CAUSE_LOC_PUN_S_RU";
case GSM48__CAUSE__LOC__PRN__S__RU: return "GSM48_CAUSE_LOC_PRN_S_RU";
case GSM48__CAUSE__LOC__INN__NET: return "GSM48_CAUSE_LOC_INN_NET";
case GSM48__CAUSE__LOC__NET__BEYOND: return "GSM48_CAUSE_LOC_NET_BEYOND";
default: return "<unknown>";
}
}

GSM48__cause__loc::enum_type GSM48__cause__loc::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM48_CAUSE_LOC_USER")) return GSM48__CAUSE__LOC__USER;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_PRN_S_LU")) return GSM48__CAUSE__LOC__PRN__S__LU;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_PUN_S_LU")) return GSM48__CAUSE__LOC__PUN__S__LU;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_TRANS_NET")) return GSM48__CAUSE__LOC__TRANS__NET;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_PUN_S_RU")) return GSM48__CAUSE__LOC__PUN__S__RU;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_PRN_S_RU")) return GSM48__CAUSE__LOC__PRN__S__RU;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_INN_NET")) return GSM48__CAUSE__LOC__INN__NET;
else if (!strcmp(str_par, "GSM48_CAUSE_LOC_NET_BEYOND")) return GSM48__CAUSE__LOC__NET__BEYOND;
else return UNKNOWN_VALUE;
}

boolean GSM48__cause__loc::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 7:
case 10:
return TRUE;
default:
return FALSE;
}
}

int GSM48__cause__loc::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_cause_loc.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GSM48__cause__loc::enum2int(const GSM48__cause__loc& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.GSM48_cause_loc.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GSM48__cause__loc::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.GSM48_cause_loc.", int_val);
enum_value = (enum_type)int_val;
}

GSM48__cause__loc::operator GSM48__cause__loc::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.GSM48_cause_loc.");
return enum_value;
}

void GSM48__cause__loc::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GSM48__cause__loc::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.GSM48_cause_loc");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.GSM48_cause_loc.");
  }
}

void GSM48__cause__loc::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
text_buf.push_int(enum_value);
}

void GSM48__cause__loc::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.GSM48_cause_loc.", enum_value);
}

void GSM48__cause__loc::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GSM48__cause__loc::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GSM48__cause__loc::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GSM48__cause__loc::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

void GSM48__cause__loc_template::copy_template(const GSM48__cause__loc_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GSM48__cause__loc_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_loc.");
}
}

GSM48__cause__loc_template::GSM48__cause__loc_template()
{
}

GSM48__cause__loc_template::GSM48__cause__loc_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GSM48__cause__loc_template::GSM48__cause__loc_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GSM48__cause__loc::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.GSM48_cause_loc with unknown numeric value %d.", other_value);
single_value = (GSM48__cause__loc::enum_type)other_value;
}

GSM48__cause__loc_template::GSM48__cause__loc_template(GSM48__cause__loc::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GSM48__cause__loc_template::GSM48__cause__loc_template(const GSM48__cause__loc& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GSM48__cause__loc::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc.");
single_value = other_value.enum_value;
}

GSM48__cause__loc_template::GSM48__cause__loc_template(const OPTIONAL<GSM48__cause__loc>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__loc::enum_type)(const GSM48__cause__loc&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.GSM48_cause_loc from an unbound optional field.");
}
}

GSM48__cause__loc_template::GSM48__cause__loc_template(const GSM48__cause__loc_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GSM48__cause__loc_template::~GSM48__cause__loc_template()
{
clean_up();
}

boolean GSM48__cause__loc_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GSM48__cause__loc_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GSM48__cause__loc::UNBOUND_VALUE;
}

void GSM48__cause__loc_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(int other_value)
{
if (!GSM48__cause__loc::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.GSM48_cause_loc.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__loc::enum_type)other_value;
return *this;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(GSM48__cause__loc::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(const GSM48__cause__loc& other_value)
{
if (other_value.enum_value == GSM48__cause__loc::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.GSM48_cause_loc to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(const OPTIONAL<GSM48__cause__loc>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GSM48__cause__loc::enum_type)(const GSM48__cause__loc&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.GSM48_cause_loc.");
}
return *this;
}

GSM48__cause__loc_template& GSM48__cause__loc_template::operator=(const GSM48__cause__loc_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GSM48__cause__loc_template::match(GSM48__cause__loc::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_loc.");
}
return FALSE;
}

boolean GSM48__cause__loc_template::match(const GSM48__cause__loc& other_value, boolean) const
{
if (other_value.enum_value == GSM48__cause__loc::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.GSM48_cause_loc with an unbound value.");
return match(other_value.enum_value);
}

GSM48__cause__loc::enum_type GSM48__cause__loc_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.GSM48_cause_loc.");
return single_value;
}

void GSM48__cause__loc_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.GSM48_cause_loc.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GSM48__cause__loc_template[list_length];
}

GSM48__cause__loc_template& GSM48__cause__loc_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.GSM48_cause_loc.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.GSM48_cause_loc.");
return value_list.list_value[list_index];
}

void GSM48__cause__loc_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GSM48__cause__loc::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GSM48__cause__loc_template::log_match(const GSM48__cause__loc& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GSM48__cause__loc_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.GSM48_cause_loc.");
}
}

void GSM48__cause__loc_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GSM48__cause__loc::enum_type)text_buf.pull_int().get_val();
if (!GSM48__cause__loc::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.GSM48_cause_loc.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GSM48__cause__loc_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.GSM48_cause_loc.");
}
}

boolean GSM48__cause__loc_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GSM48__cause__loc_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GSM48__cause__loc_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GSM48__cause__loc_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GSM48__cause__loc::enum_type enum_val = GSM48__cause__loc::str_to_enum(m_p->get_enumerated());
    if (!GSM48__cause__loc::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.GSM48_cause_loc.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.GSM48_cause_loc");
  }
  is_ifpresent = param.get_ifpresent();
}

void GSM48__cause__loc_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.GSM48_cause_loc");
}

MNCC__cause::MNCC__cause()
{
}

MNCC__cause::MNCC__cause(const GSM48__cause__loc& par_location,
    const GSM48__cause__coding& par_coding,
    const INTEGER& par_rec,
    const INTEGER& par_rec__val,
    const INTEGER& par_val,
    const OCTETSTRING& par_diag)
  :   field_location(par_location),
  field_coding(par_coding),
  field_rec(par_rec),
  field_rec__val(par_rec__val),
  field_val(par_val),
  field_diag(par_diag)
{
}

MNCC__cause::MNCC__cause(const MNCC__cause& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_cause.");
if (other_value.location().is_bound()) field_location = other_value.location();
else field_location.clean_up();
if (other_value.coding().is_bound()) field_coding = other_value.coding();
else field_coding.clean_up();
if (other_value.rec().is_bound()) field_rec = other_value.rec();
else field_rec.clean_up();
if (other_value.rec__val().is_bound()) field_rec__val = other_value.rec__val();
else field_rec__val.clean_up();
if (other_value.val().is_bound()) field_val = other_value.val();
else field_val.clean_up();
if (other_value.diag().is_bound()) field_diag = other_value.diag();
else field_diag.clean_up();
}

void MNCC__cause::clean_up()
{
field_location.clean_up();
field_coding.clean_up();
field_rec.clean_up();
field_rec__val.clean_up();
field_val.clean_up();
field_diag.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__cause::get_descriptor() const { return &MNCC__cause_descr_; }
MNCC__cause& MNCC__cause::operator=(const MNCC__cause& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_cause.");
  if (other_value.location().is_bound()) field_location = other_value.location();
  else field_location.clean_up();
  if (other_value.coding().is_bound()) field_coding = other_value.coding();
  else field_coding.clean_up();
  if (other_value.rec().is_bound()) field_rec = other_value.rec();
  else field_rec.clean_up();
  if (other_value.rec__val().is_bound()) field_rec__val = other_value.rec__val();
  else field_rec__val.clean_up();
  if (other_value.val().is_bound()) field_val = other_value.val();
  else field_val.clean_up();
  if (other_value.diag().is_bound()) field_diag = other_value.diag();
  else field_diag.clean_up();
}
return *this;
}

boolean MNCC__cause::operator==(const MNCC__cause& other_value) const
{
return field_location==other_value.field_location
  && field_coding==other_value.field_coding
  && field_rec==other_value.field_rec
  && field_rec__val==other_value.field_rec__val
  && field_val==other_value.field_val
  && field_diag==other_value.field_diag;
}

boolean MNCC__cause::is_bound() const
{
if(field_location.is_bound()) return TRUE;
if(field_coding.is_bound()) return TRUE;
if(field_rec.is_bound()) return TRUE;
if(field_rec__val.is_bound()) return TRUE;
if(field_val.is_bound()) return TRUE;
if(field_diag.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__cause::is_value() const
{
if(!field_location.is_value()) return FALSE;
if(!field_coding.is_value()) return FALSE;
if(!field_rec.is_value()) return FALSE;
if(!field_rec__val.is_value()) return FALSE;
if(!field_val.is_value()) return FALSE;
if(!field_diag.is_value()) return FALSE;
return TRUE;
}
void MNCC__cause::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ location := ");
field_location.log();
TTCN_Logger::log_event_str(", coding := ");
field_coding.log();
TTCN_Logger::log_event_str(", rec := ");
field_rec.log();
TTCN_Logger::log_event_str(", rec_val := ");
field_rec__val.log();
TTCN_Logger::log_event_str(", val := ");
field_val.log();
TTCN_Logger::log_event_str(", diag := ");
field_diag.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__cause::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_cause has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rec().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rec__val().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) val().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) diag().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rec")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rec().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rec_val")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rec__val().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "val")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          val().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "diag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          diag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_cause: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_cause");
  }
}

void MNCC__cause::set_implicit_omit()
{
if (location().is_bound()) location().set_implicit_omit();
if (coding().is_bound()) coding().set_implicit_omit();
if (rec().is_bound()) rec().set_implicit_omit();
if (rec__val().is_bound()) rec__val().set_implicit_omit();
if (val().is_bound()) val().set_implicit_omit();
if (diag().is_bound()) diag().set_implicit_omit();
}

void MNCC__cause::encode_text(Text_Buf& text_buf) const
{
field_location.encode_text(text_buf);
field_coding.encode_text(text_buf);
field_rec.encode_text(text_buf);
field_rec__val.encode_text(text_buf);
field_val.encode_text(text_buf);
field_diag.encode_text(text_buf);
}

void MNCC__cause::decode_text(Text_Buf& text_buf)
{
field_location.decode_text(text_buf);
field_coding.decode_text(text_buf);
field_rec.decode_text(text_buf);
field_rec__val.decode_text(text_buf);
field_val.decode_text(text_buf);
field_diag.decode_text(text_buf);
}

void MNCC__cause::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__cause::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__cause::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__cause_location_descr_.raw->forceomit);
  decoded_field_length = field_location.RAW_decode(MNCC__cause_location_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__cause_coding_descr_.raw->forceomit);
  decoded_field_length = field_coding.RAW_decode(MNCC__cause_coding_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__cause_rec_descr_.raw->forceomit);
  decoded_field_length = field_rec.RAW_decode(MNCC__cause_rec_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__cause_rec__val_descr_.raw->forceomit);
  decoded_field_length = field_rec__val.RAW_decode(MNCC__cause_rec__val_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__cause_val_descr_.raw->forceomit);
  decoded_field_length = field_val.RAW_decode(MNCC__cause_val_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, MNCC__cause_diag_descr_.raw->forceomit);
  decoded_field_length = field_diag.RAW_decode(MNCC__cause_diag_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__cause::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__cause_location_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__cause_coding_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__cause_rec_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__cause_rec__val_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__cause_val_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, MNCC__cause_diag_descr_.raw);
  encoded_length += field_location.RAW_encode(MNCC__cause_location_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_coding.RAW_encode(MNCC__cause_coding_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_rec.RAW_encode(MNCC__cause_rec_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_rec__val.RAW_encode(MNCC__cause_rec__val_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_val.RAW_encode(MNCC__cause_val_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_diag.RAW_encode(MNCC__cause_diag_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

struct MNCC__cause_template::single_value_struct {
GSM48__cause__loc_template field_location;
GSM48__cause__coding_template field_coding;
INTEGER_template field_rec;
INTEGER_template field_rec__val;
INTEGER_template field_val;
OCTETSTRING_template field_diag;
};

void MNCC__cause_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_location = ANY_VALUE;
single_value->field_coding = ANY_VALUE;
single_value->field_rec = ANY_VALUE;
single_value->field_rec__val = ANY_VALUE;
single_value->field_val = ANY_VALUE;
single_value->field_diag = ANY_VALUE;
}
}
}

void MNCC__cause_template::copy_value(const MNCC__cause& other_value)
{
single_value = new single_value_struct;
if (other_value.location().is_bound()) {
  single_value->field_location = other_value.location();
} else {
  single_value->field_location.clean_up();
}
if (other_value.coding().is_bound()) {
  single_value->field_coding = other_value.coding();
} else {
  single_value->field_coding.clean_up();
}
if (other_value.rec().is_bound()) {
  single_value->field_rec = other_value.rec();
} else {
  single_value->field_rec.clean_up();
}
if (other_value.rec__val().is_bound()) {
  single_value->field_rec__val = other_value.rec__val();
} else {
  single_value->field_rec__val.clean_up();
}
if (other_value.val().is_bound()) {
  single_value->field_val = other_value.val();
} else {
  single_value->field_val.clean_up();
}
if (other_value.diag().is_bound()) {
  single_value->field_diag = other_value.diag();
} else {
  single_value->field_diag.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__cause_template::copy_template(const MNCC__cause_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.location().get_selection()) {
single_value->field_location = other_value.location();
} else {
single_value->field_location.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.coding().get_selection()) {
single_value->field_coding = other_value.coding();
} else {
single_value->field_coding.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rec().get_selection()) {
single_value->field_rec = other_value.rec();
} else {
single_value->field_rec.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rec__val().get_selection()) {
single_value->field_rec__val = other_value.rec__val();
} else {
single_value->field_rec__val.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.val().get_selection()) {
single_value->field_val = other_value.val();
} else {
single_value->field_val.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.diag().get_selection()) {
single_value->field_diag = other_value.diag();
} else {
single_value->field_diag.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__cause_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_cause.");
break;
}
set_selection(other_value);
}

MNCC__cause_template::MNCC__cause_template()
{
}

MNCC__cause_template::MNCC__cause_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__cause_template::MNCC__cause_template(const MNCC__cause& other_value)
{
copy_value(other_value);
}

MNCC__cause_template::MNCC__cause_template(const OPTIONAL<MNCC__cause>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__cause&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_cause from an unbound optional field.");
}
}

MNCC__cause_template::MNCC__cause_template(const MNCC__cause_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__cause_template::~MNCC__cause_template()
{
clean_up();
}

MNCC__cause_template& MNCC__cause_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__cause_template& MNCC__cause_template::operator=(const MNCC__cause& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__cause_template& MNCC__cause_template::operator=(const OPTIONAL<MNCC__cause>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__cause&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_cause.");
}
return *this;
}

MNCC__cause_template& MNCC__cause_template::operator=(const MNCC__cause_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__cause_template::match(const MNCC__cause& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.location().is_bound()) return FALSE;
if(!single_value->field_location.match(other_value.location(), legacy))return FALSE;
if(!other_value.coding().is_bound()) return FALSE;
if(!single_value->field_coding.match(other_value.coding(), legacy))return FALSE;
if(!other_value.rec().is_bound()) return FALSE;
if(!single_value->field_rec.match(other_value.rec(), legacy))return FALSE;
if(!other_value.rec__val().is_bound()) return FALSE;
if(!single_value->field_rec__val.match(other_value.rec__val(), legacy))return FALSE;
if(!other_value.val().is_bound()) return FALSE;
if(!single_value->field_val.match(other_value.val(), legacy))return FALSE;
if(!other_value.diag().is_bound()) return FALSE;
if(!single_value->field_diag.match(other_value.diag(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_cause.");
}
return FALSE;
}

boolean MNCC__cause_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_location.is_bound()) return TRUE;
if (single_value->field_coding.is_bound()) return TRUE;
if (single_value->field_rec.is_bound()) return TRUE;
if (single_value->field_rec__val.is_bound()) return TRUE;
if (single_value->field_val.is_bound()) return TRUE;
if (single_value->field_diag.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__cause_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_location.is_value()) return FALSE;
if (!single_value->field_coding.is_value()) return FALSE;
if (!single_value->field_rec.is_value()) return FALSE;
if (!single_value->field_rec__val.is_value()) return FALSE;
if (!single_value->field_val.is_value()) return FALSE;
if (!single_value->field_diag.is_value()) return FALSE;
return TRUE;
}

void MNCC__cause_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__cause MNCC__cause_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_cause.");
MNCC__cause ret_val;
if (single_value->field_location.is_bound()) {
ret_val.location() = single_value->field_location.valueof();
}
if (single_value->field_coding.is_bound()) {
ret_val.coding() = single_value->field_coding.valueof();
}
if (single_value->field_rec.is_bound()) {
ret_val.rec() = single_value->field_rec.valueof();
}
if (single_value->field_rec__val.is_bound()) {
ret_val.rec__val() = single_value->field_rec__val.valueof();
}
if (single_value->field_val.is_bound()) {
ret_val.val() = single_value->field_val.valueof();
}
if (single_value->field_diag.is_bound()) {
ret_val.diag() = single_value->field_diag.valueof();
}
return ret_val;
}

void MNCC__cause_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_cause.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__cause_template[list_length];
}

MNCC__cause_template& MNCC__cause_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_cause.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_cause.");
return value_list.list_value[list_index];
}

GSM48__cause__loc_template& MNCC__cause_template::location()
{
set_specific();
return single_value->field_location;
}

const GSM48__cause__loc_template& MNCC__cause_template::location() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field location of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_location;
}

GSM48__cause__coding_template& MNCC__cause_template::coding()
{
set_specific();
return single_value->field_coding;
}

const GSM48__cause__coding_template& MNCC__cause_template::coding() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field coding of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_coding;
}

INTEGER_template& MNCC__cause_template::rec()
{
set_specific();
return single_value->field_rec;
}

const INTEGER_template& MNCC__cause_template::rec() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rec of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_rec;
}

INTEGER_template& MNCC__cause_template::rec__val()
{
set_specific();
return single_value->field_rec__val;
}

const INTEGER_template& MNCC__cause_template::rec__val() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rec_val of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_rec__val;
}

INTEGER_template& MNCC__cause_template::val()
{
set_specific();
return single_value->field_val;
}

const INTEGER_template& MNCC__cause_template::val() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field val of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_val;
}

OCTETSTRING_template& MNCC__cause_template::diag()
{
set_specific();
return single_value->field_diag;
}

const OCTETSTRING_template& MNCC__cause_template::diag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field diag of a non-specific template of type @MNCC_Types.MNCC_cause.");
return single_value->field_diag;
}

int MNCC__cause_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cause containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_cause.");
  }
  return 0;
}

void MNCC__cause_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ location := ");
single_value->field_location.log();
TTCN_Logger::log_event_str(", coding := ");
single_value->field_coding.log();
TTCN_Logger::log_event_str(", rec := ");
single_value->field_rec.log();
TTCN_Logger::log_event_str(", rec_val := ");
single_value->field_rec__val.log();
TTCN_Logger::log_event_str(", val := ");
single_value->field_val.log();
TTCN_Logger::log_event_str(", diag := ");
single_value->field_diag.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__cause_template::log_match(const MNCC__cause& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_location.match(match_value.location(), legacy)){
TTCN_Logger::log_logmatch_info(".location");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_coding.match(match_value.coding(), legacy)){
TTCN_Logger::log_logmatch_info(".coding");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rec.match(match_value.rec(), legacy)){
TTCN_Logger::log_logmatch_info(".rec");
single_value->field_rec.log_match(match_value.rec(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rec__val.match(match_value.rec__val(), legacy)){
TTCN_Logger::log_logmatch_info(".rec_val");
single_value->field_rec__val.log_match(match_value.rec__val(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_val.match(match_value.val(), legacy)){
TTCN_Logger::log_logmatch_info(".val");
single_value->field_val.log_match(match_value.val(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_diag.match(match_value.diag(), legacy)){
TTCN_Logger::log_logmatch_info(".diag");
single_value->field_diag.log_match(match_value.diag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ location := ");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::log_event_str(", coding := ");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::log_event_str(", rec := ");
single_value->field_rec.log_match(match_value.rec(), legacy);
TTCN_Logger::log_event_str(", rec_val := ");
single_value->field_rec__val.log_match(match_value.rec__val(), legacy);
TTCN_Logger::log_event_str(", val := ");
single_value->field_val.log_match(match_value.val(), legacy);
TTCN_Logger::log_event_str(", diag := ");
single_value->field_diag.log_match(match_value.diag(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__cause_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_location.encode_text(text_buf);
single_value->field_coding.encode_text(text_buf);
single_value->field_rec.encode_text(text_buf);
single_value->field_rec__val.encode_text(text_buf);
single_value->field_val.encode_text(text_buf);
single_value->field_diag.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_cause.");
}
}

void MNCC__cause_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_location.decode_text(text_buf);
single_value->field_coding.decode_text(text_buf);
single_value->field_rec.decode_text(text_buf);
single_value->field_rec__val.decode_text(text_buf);
single_value->field_val.decode_text(text_buf);
single_value->field_diag.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__cause_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_cause.");
}
}

void MNCC__cause_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__cause_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_cause has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rec().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rec__val().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) val().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) diag().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rec")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rec().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rec_val")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rec__val().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "val")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          val().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "diag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          diag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_cause: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_cause");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__cause_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_location.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
single_value->field_coding.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
single_value->field_rec.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
single_value->field_rec__val.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
single_value->field_val.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
single_value->field_diag.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cause");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_cause");
}

boolean MNCC__cause_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__cause_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__useruser::MNCC__useruser()
{
}

MNCC__useruser::MNCC__useruser(const INTEGER& par_proto,
    const CHARSTRING& par_info)
  :   field_proto(par_proto),
  field_info(par_info)
{
}

MNCC__useruser::MNCC__useruser(const MNCC__useruser& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_useruser.");
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.info().is_bound()) field_info = other_value.info();
else field_info.clean_up();
}

void MNCC__useruser::clean_up()
{
field_proto.clean_up();
field_info.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__useruser::get_descriptor() const { return &MNCC__useruser_descr_; }
MNCC__useruser& MNCC__useruser::operator=(const MNCC__useruser& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_useruser.");
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.info().is_bound()) field_info = other_value.info();
  else field_info.clean_up();
}
return *this;
}

boolean MNCC__useruser::operator==(const MNCC__useruser& other_value) const
{
return field_proto==other_value.field_proto
  && field_info==other_value.field_info;
}

boolean MNCC__useruser::is_bound() const
{
if(field_proto.is_bound()) return TRUE;
if(field_info.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__useruser::is_value() const
{
if(!field_proto.is_value()) return FALSE;
if(!field_info.is_value()) return FALSE;
return TRUE;
}
void MNCC__useruser::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", info := ");
field_info.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__useruser::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_useruser has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) info().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          info().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_useruser: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_useruser");
  }
}

void MNCC__useruser::set_implicit_omit()
{
if (proto().is_bound()) proto().set_implicit_omit();
if (info().is_bound()) info().set_implicit_omit();
}

void MNCC__useruser::encode_text(Text_Buf& text_buf) const
{
field_proto.encode_text(text_buf);
field_info.encode_text(text_buf);
}

void MNCC__useruser::decode_text(Text_Buf& text_buf)
{
field_proto.decode_text(text_buf);
field_info.decode_text(text_buf);
}

void MNCC__useruser::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__useruser::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__useruser::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__useruser_proto_descr_.raw->forceomit);
  decoded_field_length = field_proto.RAW_decode(MNCC__useruser_proto_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__useruser_info_descr_.raw->forceomit);
  decoded_field_length = field_info.RAW_decode(MNCC__useruser_info_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__useruser::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__useruser_proto_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__useruser_info_descr_.raw);
  encoded_length += field_proto.RAW_encode(MNCC__useruser_proto_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_info.RAW_encode(MNCC__useruser_info_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

struct MNCC__useruser_template::single_value_struct {
INTEGER_template field_proto;
CHARSTRING_template field_info;
};

void MNCC__useruser_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_proto = ANY_VALUE;
single_value->field_info = ANY_VALUE;
}
}
}

void MNCC__useruser_template::copy_value(const MNCC__useruser& other_value)
{
single_value = new single_value_struct;
if (other_value.proto().is_bound()) {
  single_value->field_proto = other_value.proto();
} else {
  single_value->field_proto.clean_up();
}
if (other_value.info().is_bound()) {
  single_value->field_info = other_value.info();
} else {
  single_value->field_info.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__useruser_template::copy_template(const MNCC__useruser_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.info().get_selection()) {
single_value->field_info = other_value.info();
} else {
single_value->field_info.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__useruser_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_useruser.");
break;
}
set_selection(other_value);
}

MNCC__useruser_template::MNCC__useruser_template()
{
}

MNCC__useruser_template::MNCC__useruser_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__useruser_template::MNCC__useruser_template(const MNCC__useruser& other_value)
{
copy_value(other_value);
}

MNCC__useruser_template::MNCC__useruser_template(const OPTIONAL<MNCC__useruser>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__useruser&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_useruser from an unbound optional field.");
}
}

MNCC__useruser_template::MNCC__useruser_template(const MNCC__useruser_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__useruser_template::~MNCC__useruser_template()
{
clean_up();
}

MNCC__useruser_template& MNCC__useruser_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__useruser_template& MNCC__useruser_template::operator=(const MNCC__useruser& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__useruser_template& MNCC__useruser_template::operator=(const OPTIONAL<MNCC__useruser>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__useruser&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_useruser.");
}
return *this;
}

MNCC__useruser_template& MNCC__useruser_template::operator=(const MNCC__useruser_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__useruser_template::match(const MNCC__useruser& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.proto().is_bound()) return FALSE;
if(!single_value->field_proto.match(other_value.proto(), legacy))return FALSE;
if(!other_value.info().is_bound()) return FALSE;
if(!single_value->field_info.match(other_value.info(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_useruser.");
}
return FALSE;
}

boolean MNCC__useruser_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_info.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__useruser_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_info.is_value()) return FALSE;
return TRUE;
}

void MNCC__useruser_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__useruser MNCC__useruser_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_useruser.");
MNCC__useruser ret_val;
if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_info.is_bound()) {
ret_val.info() = single_value->field_info.valueof();
}
return ret_val;
}

void MNCC__useruser_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_useruser.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__useruser_template[list_length];
}

MNCC__useruser_template& MNCC__useruser_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_useruser.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_useruser.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__useruser_template::proto()
{
set_specific();
return single_value->field_proto;
}

const INTEGER_template& MNCC__useruser_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @MNCC_Types.MNCC_useruser.");
return single_value->field_proto;
}

CHARSTRING_template& MNCC__useruser_template::info()
{
set_specific();
return single_value->field_info;
}

const CHARSTRING_template& MNCC__useruser_template::info() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field info of a non-specific template of type @MNCC_Types.MNCC_useruser.");
return single_value->field_info;
}

int MNCC__useruser_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_useruser containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_useruser.");
  }
  return 0;
}

void MNCC__useruser_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", info := ");
single_value->field_info.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__useruser_template::log_match(const MNCC__useruser& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_info.match(match_value.info(), legacy)){
TTCN_Logger::log_logmatch_info(".info");
single_value->field_info.log_match(match_value.info(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ proto := ");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::log_event_str(", info := ");
single_value->field_info.log_match(match_value.info(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__useruser_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_proto.encode_text(text_buf);
single_value->field_info.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_useruser.");
}
}

void MNCC__useruser_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_proto.decode_text(text_buf);
single_value->field_info.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__useruser_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_useruser.");
}
}

void MNCC__useruser_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__useruser_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_useruser has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) info().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          info().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_useruser: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_useruser");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__useruser_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_useruser");
single_value->field_info.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_useruser");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_useruser");
}

boolean MNCC__useruser_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__useruser_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__progress::MNCC__progress()
{
}

MNCC__progress::MNCC__progress(const INTEGER& par_coding,
    const INTEGER& par_location,
    const INTEGER& par_descr)
  :   field_coding(par_coding),
  field_location(par_location),
  field_descr(par_descr)
{
}

MNCC__progress::MNCC__progress(const MNCC__progress& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_progress.");
if (other_value.coding().is_bound()) field_coding = other_value.coding();
else field_coding.clean_up();
if (other_value.location().is_bound()) field_location = other_value.location();
else field_location.clean_up();
if (other_value.descr().is_bound()) field_descr = other_value.descr();
else field_descr.clean_up();
}

void MNCC__progress::clean_up()
{
field_coding.clean_up();
field_location.clean_up();
field_descr.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__progress::get_descriptor() const { return &MNCC__progress_descr_; }
MNCC__progress& MNCC__progress::operator=(const MNCC__progress& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_progress.");
  if (other_value.coding().is_bound()) field_coding = other_value.coding();
  else field_coding.clean_up();
  if (other_value.location().is_bound()) field_location = other_value.location();
  else field_location.clean_up();
  if (other_value.descr().is_bound()) field_descr = other_value.descr();
  else field_descr.clean_up();
}
return *this;
}

boolean MNCC__progress::operator==(const MNCC__progress& other_value) const
{
return field_coding==other_value.field_coding
  && field_location==other_value.field_location
  && field_descr==other_value.field_descr;
}

boolean MNCC__progress::is_bound() const
{
if(field_coding.is_bound()) return TRUE;
if(field_location.is_bound()) return TRUE;
if(field_descr.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__progress::is_value() const
{
if(!field_coding.is_value()) return FALSE;
if(!field_location.is_value()) return FALSE;
if(!field_descr.is_value()) return FALSE;
return TRUE;
}
void MNCC__progress::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ coding := ");
field_coding.log();
TTCN_Logger::log_event_str(", location := ");
field_location.log();
TTCN_Logger::log_event_str(", descr := ");
field_descr.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__progress::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_progress has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) descr().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "descr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          descr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_progress: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_progress");
  }
}

void MNCC__progress::set_implicit_omit()
{
if (coding().is_bound()) coding().set_implicit_omit();
if (location().is_bound()) location().set_implicit_omit();
if (descr().is_bound()) descr().set_implicit_omit();
}

void MNCC__progress::encode_text(Text_Buf& text_buf) const
{
field_coding.encode_text(text_buf);
field_location.encode_text(text_buf);
field_descr.encode_text(text_buf);
}

void MNCC__progress::decode_text(Text_Buf& text_buf)
{
field_coding.decode_text(text_buf);
field_location.decode_text(text_buf);
field_descr.decode_text(text_buf);
}

void MNCC__progress::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__progress::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__progress::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__progress_coding_descr_.raw->forceomit);
  decoded_field_length = field_coding.RAW_decode(MNCC__progress_coding_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__progress_location_descr_.raw->forceomit);
  decoded_field_length = field_location.RAW_decode(MNCC__progress_location_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__progress_descr_descr_.raw->forceomit);
  decoded_field_length = field_descr.RAW_decode(MNCC__progress_descr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__progress::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__progress_coding_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__progress_location_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__progress_descr_descr_.raw);
  encoded_length += field_coding.RAW_encode(MNCC__progress_coding_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_location.RAW_encode(MNCC__progress_location_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_descr.RAW_encode(MNCC__progress_descr_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

struct MNCC__progress_template::single_value_struct {
INTEGER_template field_coding;
INTEGER_template field_location;
INTEGER_template field_descr;
};

void MNCC__progress_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_coding = ANY_VALUE;
single_value->field_location = ANY_VALUE;
single_value->field_descr = ANY_VALUE;
}
}
}

void MNCC__progress_template::copy_value(const MNCC__progress& other_value)
{
single_value = new single_value_struct;
if (other_value.coding().is_bound()) {
  single_value->field_coding = other_value.coding();
} else {
  single_value->field_coding.clean_up();
}
if (other_value.location().is_bound()) {
  single_value->field_location = other_value.location();
} else {
  single_value->field_location.clean_up();
}
if (other_value.descr().is_bound()) {
  single_value->field_descr = other_value.descr();
} else {
  single_value->field_descr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__progress_template::copy_template(const MNCC__progress_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.coding().get_selection()) {
single_value->field_coding = other_value.coding();
} else {
single_value->field_coding.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.location().get_selection()) {
single_value->field_location = other_value.location();
} else {
single_value->field_location.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.descr().get_selection()) {
single_value->field_descr = other_value.descr();
} else {
single_value->field_descr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__progress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_progress.");
break;
}
set_selection(other_value);
}

MNCC__progress_template::MNCC__progress_template()
{
}

MNCC__progress_template::MNCC__progress_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__progress_template::MNCC__progress_template(const MNCC__progress& other_value)
{
copy_value(other_value);
}

MNCC__progress_template::MNCC__progress_template(const OPTIONAL<MNCC__progress>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__progress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_progress from an unbound optional field.");
}
}

MNCC__progress_template::MNCC__progress_template(const MNCC__progress_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__progress_template::~MNCC__progress_template()
{
clean_up();
}

MNCC__progress_template& MNCC__progress_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__progress_template& MNCC__progress_template::operator=(const MNCC__progress& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__progress_template& MNCC__progress_template::operator=(const OPTIONAL<MNCC__progress>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__progress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_progress.");
}
return *this;
}

MNCC__progress_template& MNCC__progress_template::operator=(const MNCC__progress_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__progress_template::match(const MNCC__progress& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.coding().is_bound()) return FALSE;
if(!single_value->field_coding.match(other_value.coding(), legacy))return FALSE;
if(!other_value.location().is_bound()) return FALSE;
if(!single_value->field_location.match(other_value.location(), legacy))return FALSE;
if(!other_value.descr().is_bound()) return FALSE;
if(!single_value->field_descr.match(other_value.descr(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_progress.");
}
return FALSE;
}

boolean MNCC__progress_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_coding.is_bound()) return TRUE;
if (single_value->field_location.is_bound()) return TRUE;
if (single_value->field_descr.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__progress_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_coding.is_value()) return FALSE;
if (!single_value->field_location.is_value()) return FALSE;
if (!single_value->field_descr.is_value()) return FALSE;
return TRUE;
}

void MNCC__progress_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__progress MNCC__progress_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_progress.");
MNCC__progress ret_val;
if (single_value->field_coding.is_bound()) {
ret_val.coding() = single_value->field_coding.valueof();
}
if (single_value->field_location.is_bound()) {
ret_val.location() = single_value->field_location.valueof();
}
if (single_value->field_descr.is_bound()) {
ret_val.descr() = single_value->field_descr.valueof();
}
return ret_val;
}

void MNCC__progress_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_progress.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__progress_template[list_length];
}

MNCC__progress_template& MNCC__progress_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_progress.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_progress.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__progress_template::coding()
{
set_specific();
return single_value->field_coding;
}

const INTEGER_template& MNCC__progress_template::coding() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field coding of a non-specific template of type @MNCC_Types.MNCC_progress.");
return single_value->field_coding;
}

INTEGER_template& MNCC__progress_template::location()
{
set_specific();
return single_value->field_location;
}

const INTEGER_template& MNCC__progress_template::location() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field location of a non-specific template of type @MNCC_Types.MNCC_progress.");
return single_value->field_location;
}

INTEGER_template& MNCC__progress_template::descr()
{
set_specific();
return single_value->field_descr;
}

const INTEGER_template& MNCC__progress_template::descr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field descr of a non-specific template of type @MNCC_Types.MNCC_progress.");
return single_value->field_descr;
}

int MNCC__progress_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_progress containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_progress.");
  }
  return 0;
}

void MNCC__progress_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ coding := ");
single_value->field_coding.log();
TTCN_Logger::log_event_str(", location := ");
single_value->field_location.log();
TTCN_Logger::log_event_str(", descr := ");
single_value->field_descr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__progress_template::log_match(const MNCC__progress& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_coding.match(match_value.coding(), legacy)){
TTCN_Logger::log_logmatch_info(".coding");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_location.match(match_value.location(), legacy)){
TTCN_Logger::log_logmatch_info(".location");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_descr.match(match_value.descr(), legacy)){
TTCN_Logger::log_logmatch_info(".descr");
single_value->field_descr.log_match(match_value.descr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ coding := ");
single_value->field_coding.log_match(match_value.coding(), legacy);
TTCN_Logger::log_event_str(", location := ");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::log_event_str(", descr := ");
single_value->field_descr.log_match(match_value.descr(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__progress_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_coding.encode_text(text_buf);
single_value->field_location.encode_text(text_buf);
single_value->field_descr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_progress.");
}
}

void MNCC__progress_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_coding.decode_text(text_buf);
single_value->field_location.decode_text(text_buf);
single_value->field_descr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__progress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_progress.");
}
}

void MNCC__progress_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__progress_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_progress has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) coding().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) descr().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "coding")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          coding().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "descr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          descr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_progress: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_progress");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__progress_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_coding.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_progress");
single_value->field_location.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_progress");
single_value->field_descr.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_progress");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_progress");
}

boolean MNCC__progress_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__progress_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__cccap::MNCC__cccap()
{
}

MNCC__cccap::MNCC__cccap(const INTEGER& par_dtmf,
    const INTEGER& par_pcp)
  :   field_dtmf(par_dtmf),
  field_pcp(par_pcp)
{
}

MNCC__cccap::MNCC__cccap(const MNCC__cccap& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_cccap.");
if (other_value.dtmf().is_bound()) field_dtmf = other_value.dtmf();
else field_dtmf.clean_up();
if (other_value.pcp().is_bound()) field_pcp = other_value.pcp();
else field_pcp.clean_up();
}

void MNCC__cccap::clean_up()
{
field_dtmf.clean_up();
field_pcp.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__cccap::get_descriptor() const { return &MNCC__cccap_descr_; }
MNCC__cccap& MNCC__cccap::operator=(const MNCC__cccap& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_cccap.");
  if (other_value.dtmf().is_bound()) field_dtmf = other_value.dtmf();
  else field_dtmf.clean_up();
  if (other_value.pcp().is_bound()) field_pcp = other_value.pcp();
  else field_pcp.clean_up();
}
return *this;
}

boolean MNCC__cccap::operator==(const MNCC__cccap& other_value) const
{
return field_dtmf==other_value.field_dtmf
  && field_pcp==other_value.field_pcp;
}

boolean MNCC__cccap::is_bound() const
{
if(field_dtmf.is_bound()) return TRUE;
if(field_pcp.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__cccap::is_value() const
{
if(!field_dtmf.is_value()) return FALSE;
if(!field_pcp.is_value()) return FALSE;
return TRUE;
}
void MNCC__cccap::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ dtmf := ");
field_dtmf.log();
TTCN_Logger::log_event_str(", pcp := ");
field_pcp.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__cccap::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_cccap has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dtmf().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pcp().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dtmf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dtmf().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pcp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pcp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_cccap: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_cccap");
  }
}

void MNCC__cccap::set_implicit_omit()
{
if (dtmf().is_bound()) dtmf().set_implicit_omit();
if (pcp().is_bound()) pcp().set_implicit_omit();
}

void MNCC__cccap::encode_text(Text_Buf& text_buf) const
{
field_dtmf.encode_text(text_buf);
field_pcp.encode_text(text_buf);
}

void MNCC__cccap::decode_text(Text_Buf& text_buf)
{
field_dtmf.decode_text(text_buf);
field_pcp.decode_text(text_buf);
}

void MNCC__cccap::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__cccap::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__cccap::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__cccap_dtmf_descr_.raw->forceomit);
  decoded_field_length = field_dtmf.RAW_decode(MNCC__cccap_dtmf_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__cccap_pcp_descr_.raw->forceomit);
  decoded_field_length = field_pcp.RAW_decode(MNCC__cccap_pcp_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__cccap::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__cccap_dtmf_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__cccap_pcp_descr_.raw);
  encoded_length += field_dtmf.RAW_encode(MNCC__cccap_dtmf_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_pcp.RAW_encode(MNCC__cccap_pcp_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

struct MNCC__cccap_template::single_value_struct {
INTEGER_template field_dtmf;
INTEGER_template field_pcp;
};

void MNCC__cccap_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_dtmf = ANY_VALUE;
single_value->field_pcp = ANY_VALUE;
}
}
}

void MNCC__cccap_template::copy_value(const MNCC__cccap& other_value)
{
single_value = new single_value_struct;
if (other_value.dtmf().is_bound()) {
  single_value->field_dtmf = other_value.dtmf();
} else {
  single_value->field_dtmf.clean_up();
}
if (other_value.pcp().is_bound()) {
  single_value->field_pcp = other_value.pcp();
} else {
  single_value->field_pcp.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__cccap_template::copy_template(const MNCC__cccap_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.dtmf().get_selection()) {
single_value->field_dtmf = other_value.dtmf();
} else {
single_value->field_dtmf.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pcp().get_selection()) {
single_value->field_pcp = other_value.pcp();
} else {
single_value->field_pcp.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__cccap_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_cccap.");
break;
}
set_selection(other_value);
}

MNCC__cccap_template::MNCC__cccap_template()
{
}

MNCC__cccap_template::MNCC__cccap_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__cccap_template::MNCC__cccap_template(const MNCC__cccap& other_value)
{
copy_value(other_value);
}

MNCC__cccap_template::MNCC__cccap_template(const OPTIONAL<MNCC__cccap>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__cccap&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_cccap from an unbound optional field.");
}
}

MNCC__cccap_template::MNCC__cccap_template(const MNCC__cccap_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__cccap_template::~MNCC__cccap_template()
{
clean_up();
}

MNCC__cccap_template& MNCC__cccap_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__cccap_template& MNCC__cccap_template::operator=(const MNCC__cccap& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__cccap_template& MNCC__cccap_template::operator=(const OPTIONAL<MNCC__cccap>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__cccap&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_cccap.");
}
return *this;
}

MNCC__cccap_template& MNCC__cccap_template::operator=(const MNCC__cccap_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__cccap_template::match(const MNCC__cccap& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.dtmf().is_bound()) return FALSE;
if(!single_value->field_dtmf.match(other_value.dtmf(), legacy))return FALSE;
if(!other_value.pcp().is_bound()) return FALSE;
if(!single_value->field_pcp.match(other_value.pcp(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_cccap.");
}
return FALSE;
}

boolean MNCC__cccap_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_dtmf.is_bound()) return TRUE;
if (single_value->field_pcp.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__cccap_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_dtmf.is_value()) return FALSE;
if (!single_value->field_pcp.is_value()) return FALSE;
return TRUE;
}

void MNCC__cccap_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__cccap MNCC__cccap_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_cccap.");
MNCC__cccap ret_val;
if (single_value->field_dtmf.is_bound()) {
ret_val.dtmf() = single_value->field_dtmf.valueof();
}
if (single_value->field_pcp.is_bound()) {
ret_val.pcp() = single_value->field_pcp.valueof();
}
return ret_val;
}

void MNCC__cccap_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_cccap.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__cccap_template[list_length];
}

MNCC__cccap_template& MNCC__cccap_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_cccap.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_cccap.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__cccap_template::dtmf()
{
set_specific();
return single_value->field_dtmf;
}

const INTEGER_template& MNCC__cccap_template::dtmf() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dtmf of a non-specific template of type @MNCC_Types.MNCC_cccap.");
return single_value->field_dtmf;
}

INTEGER_template& MNCC__cccap_template::pcp()
{
set_specific();
return single_value->field_pcp;
}

const INTEGER_template& MNCC__cccap_template::pcp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pcp of a non-specific template of type @MNCC_Types.MNCC_cccap.");
return single_value->field_pcp;
}

int MNCC__cccap_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_cccap containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_cccap.");
  }
  return 0;
}

void MNCC__cccap_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ dtmf := ");
single_value->field_dtmf.log();
TTCN_Logger::log_event_str(", pcp := ");
single_value->field_pcp.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__cccap_template::log_match(const MNCC__cccap& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_dtmf.match(match_value.dtmf(), legacy)){
TTCN_Logger::log_logmatch_info(".dtmf");
single_value->field_dtmf.log_match(match_value.dtmf(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_pcp.match(match_value.pcp(), legacy)){
TTCN_Logger::log_logmatch_info(".pcp");
single_value->field_pcp.log_match(match_value.pcp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ dtmf := ");
single_value->field_dtmf.log_match(match_value.dtmf(), legacy);
TTCN_Logger::log_event_str(", pcp := ");
single_value->field_pcp.log_match(match_value.pcp(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__cccap_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_dtmf.encode_text(text_buf);
single_value->field_pcp.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_cccap.");
}
}

void MNCC__cccap_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_dtmf.decode_text(text_buf);
single_value->field_pcp.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__cccap_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_cccap.");
}
}

void MNCC__cccap_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__cccap_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_cccap has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dtmf().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pcp().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dtmf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dtmf().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pcp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pcp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_cccap: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_cccap");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__cccap_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_dtmf.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cccap");
single_value->field_pcp.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_cccap");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_cccap");
}

boolean MNCC__cccap_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__cccap_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__bcap::MNCC__bcap()
{
enum_value = UNBOUND_VALUE;
}

MNCC__bcap::MNCC__bcap(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @MNCC_Types.MNCC_bcap with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

MNCC__bcap::MNCC__bcap(enum_type other_value)
{
enum_value = other_value;
}

MNCC__bcap::MNCC__bcap(const MNCC__bcap& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
enum_value = other_value.enum_value;
}

MNCC__bcap& MNCC__bcap::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @MNCC_Types.MNCC_bcap.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

MNCC__bcap& MNCC__bcap::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

MNCC__bcap& MNCC__bcap::operator=(const MNCC__bcap& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
enum_value = other_value.enum_value;
return *this;
}

boolean MNCC__bcap::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value == other_value;
}

boolean MNCC__bcap::operator==(const MNCC__bcap& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value == other_value.enum_value;
}

boolean MNCC__bcap::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value < other_value;
}

boolean MNCC__bcap::operator<(const MNCC__bcap& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value < other_value.enum_value;
}

boolean MNCC__bcap::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value > other_value;
}

boolean MNCC__bcap::operator>(const MNCC__bcap& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value > other_value.enum_value;
}

const char *MNCC__bcap::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case GSM__MNCC__BCAP__SPEECH: return "GSM_MNCC_BCAP_SPEECH";
case GSM__MNCC__BCAP__UNR__DIG: return "GSM_MNCC_BCAP_UNR_DIG";
case GSM__MNCC__BCAP__AUDIO: return "GSM_MNCC_BCAP_AUDIO";
case GSM__MNCC__BCAP__FAX__G3: return "GSM_MNCC_BCAP_FAX_G3";
case GSM__MNCC__BCAP__OTHER__ITC: return "GSM_MNCC_BCAP_OTHER_ITC";
case GSM__MNCC__BCAP__RESERVED: return "GSM_MNCC_BCAP_RESERVED";
default: return "<unknown>";
}
}

MNCC__bcap::enum_type MNCC__bcap::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "GSM_MNCC_BCAP_SPEECH")) return GSM__MNCC__BCAP__SPEECH;
else if (!strcmp(str_par, "GSM_MNCC_BCAP_UNR_DIG")) return GSM__MNCC__BCAP__UNR__DIG;
else if (!strcmp(str_par, "GSM_MNCC_BCAP_AUDIO")) return GSM__MNCC__BCAP__AUDIO;
else if (!strcmp(str_par, "GSM_MNCC_BCAP_FAX_G3")) return GSM__MNCC__BCAP__FAX__G3;
else if (!strcmp(str_par, "GSM_MNCC_BCAP_OTHER_ITC")) return GSM__MNCC__BCAP__OTHER__ITC;
else if (!strcmp(str_par, "GSM_MNCC_BCAP_RESERVED")) return GSM__MNCC__BCAP__RESERVED;
else return UNKNOWN_VALUE;
}

boolean MNCC__bcap::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 7:
return TRUE;
default:
return FALSE;
}
}

int MNCC__bcap::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.MNCC_bcap.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int MNCC__bcap::enum2int(const MNCC__bcap& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @MNCC_Types.MNCC_bcap.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void MNCC__bcap::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @MNCC_Types.MNCC_bcap.", int_val);
enum_value = (enum_type)int_val;
}

MNCC__bcap::operator MNCC__bcap::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @MNCC_Types.MNCC_bcap.");
return enum_value;
}

void MNCC__bcap::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void MNCC__bcap::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@MNCC_Types.MNCC_bcap");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @MNCC_Types.MNCC_bcap.");
  }
}

void MNCC__bcap::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
text_buf.push_int(enum_value);
}

void MNCC__bcap::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @MNCC_Types.MNCC_bcap.", enum_value);
}

void MNCC__bcap::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__bcap::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__bcap::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int MNCC__bcap::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void MNCC__bcap_template::copy_template(const MNCC__bcap_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__bcap_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_bcap.");
}
}

MNCC__bcap_template::MNCC__bcap_template()
{
}

MNCC__bcap_template::MNCC__bcap_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__bcap_template::MNCC__bcap_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!MNCC__bcap::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @MNCC_Types.MNCC_bcap with unknown numeric value %d.", other_value);
single_value = (MNCC__bcap::enum_type)other_value;
}

MNCC__bcap_template::MNCC__bcap_template(MNCC__bcap::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

MNCC__bcap_template::MNCC__bcap_template(const MNCC__bcap& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == MNCC__bcap::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @MNCC_Types.MNCC_bcap.");
single_value = other_value.enum_value;
}

MNCC__bcap_template::MNCC__bcap_template(const OPTIONAL<MNCC__bcap>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__bcap::enum_type)(const MNCC__bcap&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @MNCC_Types.MNCC_bcap from an unbound optional field.");
}
}

MNCC__bcap_template::MNCC__bcap_template(const MNCC__bcap_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

MNCC__bcap_template::~MNCC__bcap_template()
{
clean_up();
}

boolean MNCC__bcap_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean MNCC__bcap_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != MNCC__bcap::UNBOUND_VALUE;
}

void MNCC__bcap_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(int other_value)
{
if (!MNCC__bcap::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @MNCC_Types.MNCC_bcap.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__bcap::enum_type)other_value;
return *this;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(MNCC__bcap::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(const MNCC__bcap& other_value)
{
if (other_value.enum_value == MNCC__bcap::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @MNCC_Types.MNCC_bcap to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(const OPTIONAL<MNCC__bcap>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MNCC__bcap::enum_type)(const MNCC__bcap&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @MNCC_Types.MNCC_bcap.");
}
return *this;
}

MNCC__bcap_template& MNCC__bcap_template::operator=(const MNCC__bcap_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__bcap_template::match(MNCC__bcap::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_bcap.");
}
return FALSE;
}

boolean MNCC__bcap_template::match(const MNCC__bcap& other_value, boolean) const
{
if (other_value.enum_value == MNCC__bcap::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @MNCC_Types.MNCC_bcap with an unbound value.");
return match(other_value.enum_value);
}

MNCC__bcap::enum_type MNCC__bcap_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @MNCC_Types.MNCC_bcap.");
return single_value;
}

void MNCC__bcap_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @MNCC_Types.MNCC_bcap.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__bcap_template[list_length];
}

MNCC__bcap_template& MNCC__bcap_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @MNCC_Types.MNCC_bcap.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @MNCC_Types.MNCC_bcap.");
return value_list.list_value[list_index];
}

void MNCC__bcap_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(MNCC__bcap::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__bcap_template::log_match(const MNCC__bcap& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void MNCC__bcap_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @MNCC_Types.MNCC_bcap.");
}
}

void MNCC__bcap_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (MNCC__bcap::enum_type)text_buf.pull_int().get_val();
if (!MNCC__bcap::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @MNCC_Types.MNCC_bcap.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__bcap_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @MNCC_Types.MNCC_bcap.");
}
}

boolean MNCC__bcap_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__bcap_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MNCC__bcap_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__bcap_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    MNCC__bcap::enum_type enum_val = MNCC__bcap::str_to_enum(m_p->get_enumerated());
    if (!MNCC__bcap::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @MNCC_Types.MNCC_bcap.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@MNCC_Types.MNCC_bcap");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__bcap_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_bcap");
}

MNCC__PDU__Signal::MNCC__PDU__Signal()
{
}

MNCC__PDU__Signal::MNCC__PDU__Signal(const INTEGER& par_callref,
    const OPTIONAL<MNCC__bearer__cap>& par_bearer__cap,
    const OPTIONAL<MNCC__number>& par_called,
    const OPTIONAL<MNCC__number>& par_calling,
    const OPTIONAL<MNCC__number>& par_redirecting,
    const OPTIONAL<MNCC__number>& par_connected,
    const OPTIONAL<MNCC__cause>& par_cause,
    const OPTIONAL<MNCC__progress>& par_progress,
    const OPTIONAL<MNCC__useruser>& par_useruser,
    const OPTIONAL<CHARSTRING>& par_facility,
    const OPTIONAL<MNCC__cccap>& par_cccap,
    const OPTIONAL<CHARSTRING>& par_ssversion,
    const INTEGER& par_clir__sup,
    const INTEGER& par_clir__inv,
    const OPTIONAL<INTEGER>& par_signal,
    const OPTIONAL<CHARSTRING>& par_keypad,
    const INTEGER& par_more,
    const INTEGER& par_notify,
    const OPTIONAL<INTEGER>& par_emergency,
    const CHARSTRING& par_imsi,
    const INTEGER& par_lchan__type,
    const INTEGER& par_lchan__mode)
  :   field_callref(par_callref),
  field_bearer__cap(par_bearer__cap),
  field_called(par_called),
  field_calling(par_calling),
  field_redirecting(par_redirecting),
  field_connected(par_connected),
  field_cause(par_cause),
  field_progress(par_progress),
  field_useruser(par_useruser),
  field_facility(par_facility),
  field_cccap(par_cccap),
  field_ssversion(par_ssversion),
  field_clir__sup(par_clir__sup),
  field_clir__inv(par_clir__inv),
  field_signal(par_signal),
  field_keypad(par_keypad),
  field_more(par_more),
  field_notify(par_notify),
  field_emergency(par_emergency),
  field_imsi(par_imsi),
  field_lchan__type(par_lchan__type),
  field_lchan__mode(par_lchan__mode)
{
}

MNCC__PDU__Signal::MNCC__PDU__Signal(const MNCC__PDU__Signal& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_PDU_Signal.");
if (other_value.callref().is_bound()) field_callref = other_value.callref();
else field_callref.clean_up();
if (other_value.bearer__cap().is_bound()) field_bearer__cap = other_value.bearer__cap();
else field_bearer__cap.clean_up();
if (other_value.called().is_bound()) field_called = other_value.called();
else field_called.clean_up();
if (other_value.calling().is_bound()) field_calling = other_value.calling();
else field_calling.clean_up();
if (other_value.redirecting().is_bound()) field_redirecting = other_value.redirecting();
else field_redirecting.clean_up();
if (other_value.connected().is_bound()) field_connected = other_value.connected();
else field_connected.clean_up();
if (other_value.cause().is_bound()) field_cause = other_value.cause();
else field_cause.clean_up();
if (other_value.progress().is_bound()) field_progress = other_value.progress();
else field_progress.clean_up();
if (other_value.useruser().is_bound()) field_useruser = other_value.useruser();
else field_useruser.clean_up();
if (other_value.facility().is_bound()) field_facility = other_value.facility();
else field_facility.clean_up();
if (other_value.cccap().is_bound()) field_cccap = other_value.cccap();
else field_cccap.clean_up();
if (other_value.ssversion().is_bound()) field_ssversion = other_value.ssversion();
else field_ssversion.clean_up();
if (other_value.clir__sup().is_bound()) field_clir__sup = other_value.clir__sup();
else field_clir__sup.clean_up();
if (other_value.clir__inv().is_bound()) field_clir__inv = other_value.clir__inv();
else field_clir__inv.clean_up();
if (other_value.signal().is_bound()) field_signal = other_value.signal();
else field_signal.clean_up();
if (other_value.keypad().is_bound()) field_keypad = other_value.keypad();
else field_keypad.clean_up();
if (other_value.more().is_bound()) field_more = other_value.more();
else field_more.clean_up();
if (other_value.notify().is_bound()) field_notify = other_value.notify();
else field_notify.clean_up();
if (other_value.emergency().is_bound()) field_emergency = other_value.emergency();
else field_emergency.clean_up();
if (other_value.imsi().is_bound()) field_imsi = other_value.imsi();
else field_imsi.clean_up();
if (other_value.lchan__type().is_bound()) field_lchan__type = other_value.lchan__type();
else field_lchan__type.clean_up();
if (other_value.lchan__mode().is_bound()) field_lchan__mode = other_value.lchan__mode();
else field_lchan__mode.clean_up();
}

void MNCC__PDU__Signal::clean_up()
{
field_callref.clean_up();
field_bearer__cap.clean_up();
field_called.clean_up();
field_calling.clean_up();
field_redirecting.clean_up();
field_connected.clean_up();
field_cause.clean_up();
field_progress.clean_up();
field_useruser.clean_up();
field_facility.clean_up();
field_cccap.clean_up();
field_ssversion.clean_up();
field_clir__sup.clean_up();
field_clir__inv.clean_up();
field_signal.clean_up();
field_keypad.clean_up();
field_more.clean_up();
field_notify.clean_up();
field_emergency.clean_up();
field_imsi.clean_up();
field_lchan__type.clean_up();
field_lchan__mode.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__PDU__Signal::get_descriptor() const { return &MNCC__PDU__Signal_descr_; }
MNCC__PDU__Signal& MNCC__PDU__Signal::operator=(const MNCC__PDU__Signal& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_PDU_Signal.");
  if (other_value.callref().is_bound()) field_callref = other_value.callref();
  else field_callref.clean_up();
  if (other_value.bearer__cap().is_bound()) field_bearer__cap = other_value.bearer__cap();
  else field_bearer__cap.clean_up();
  if (other_value.called().is_bound()) field_called = other_value.called();
  else field_called.clean_up();
  if (other_value.calling().is_bound()) field_calling = other_value.calling();
  else field_calling.clean_up();
  if (other_value.redirecting().is_bound()) field_redirecting = other_value.redirecting();
  else field_redirecting.clean_up();
  if (other_value.connected().is_bound()) field_connected = other_value.connected();
  else field_connected.clean_up();
  if (other_value.cause().is_bound()) field_cause = other_value.cause();
  else field_cause.clean_up();
  if (other_value.progress().is_bound()) field_progress = other_value.progress();
  else field_progress.clean_up();
  if (other_value.useruser().is_bound()) field_useruser = other_value.useruser();
  else field_useruser.clean_up();
  if (other_value.facility().is_bound()) field_facility = other_value.facility();
  else field_facility.clean_up();
  if (other_value.cccap().is_bound()) field_cccap = other_value.cccap();
  else field_cccap.clean_up();
  if (other_value.ssversion().is_bound()) field_ssversion = other_value.ssversion();
  else field_ssversion.clean_up();
  if (other_value.clir__sup().is_bound()) field_clir__sup = other_value.clir__sup();
  else field_clir__sup.clean_up();
  if (other_value.clir__inv().is_bound()) field_clir__inv = other_value.clir__inv();
  else field_clir__inv.clean_up();
  if (other_value.signal().is_bound()) field_signal = other_value.signal();
  else field_signal.clean_up();
  if (other_value.keypad().is_bound()) field_keypad = other_value.keypad();
  else field_keypad.clean_up();
  if (other_value.more().is_bound()) field_more = other_value.more();
  else field_more.clean_up();
  if (other_value.notify().is_bound()) field_notify = other_value.notify();
  else field_notify.clean_up();
  if (other_value.emergency().is_bound()) field_emergency = other_value.emergency();
  else field_emergency.clean_up();
  if (other_value.imsi().is_bound()) field_imsi = other_value.imsi();
  else field_imsi.clean_up();
  if (other_value.lchan__type().is_bound()) field_lchan__type = other_value.lchan__type();
  else field_lchan__type.clean_up();
  if (other_value.lchan__mode().is_bound()) field_lchan__mode = other_value.lchan__mode();
  else field_lchan__mode.clean_up();
}
return *this;
}

boolean MNCC__PDU__Signal::operator==(const MNCC__PDU__Signal& other_value) const
{
return field_callref==other_value.field_callref
  && field_bearer__cap==other_value.field_bearer__cap
  && field_called==other_value.field_called
  && field_calling==other_value.field_calling
  && field_redirecting==other_value.field_redirecting
  && field_connected==other_value.field_connected
  && field_cause==other_value.field_cause
  && field_progress==other_value.field_progress
  && field_useruser==other_value.field_useruser
  && field_facility==other_value.field_facility
  && field_cccap==other_value.field_cccap
  && field_ssversion==other_value.field_ssversion
  && field_clir__sup==other_value.field_clir__sup
  && field_clir__inv==other_value.field_clir__inv
  && field_signal==other_value.field_signal
  && field_keypad==other_value.field_keypad
  && field_more==other_value.field_more
  && field_notify==other_value.field_notify
  && field_emergency==other_value.field_emergency
  && field_imsi==other_value.field_imsi
  && field_lchan__type==other_value.field_lchan__type
  && field_lchan__mode==other_value.field_lchan__mode;
}

boolean MNCC__PDU__Signal::is_bound() const
{
if(field_callref.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_bearer__cap.get_selection() || field_bearer__cap.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_called.get_selection() || field_called.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_calling.get_selection() || field_calling.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_redirecting.get_selection() || field_redirecting.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_connected.get_selection() || field_connected.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_cause.get_selection() || field_cause.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_progress.get_selection() || field_progress.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_useruser.get_selection() || field_useruser.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_facility.get_selection() || field_facility.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_cccap.get_selection() || field_cccap.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ssversion.get_selection() || field_ssversion.is_bound()) return TRUE;
if(field_clir__sup.is_bound()) return TRUE;
if(field_clir__inv.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_signal.get_selection() || field_signal.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_keypad.get_selection() || field_keypad.is_bound()) return TRUE;
if(field_more.is_bound()) return TRUE;
if(field_notify.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_emergency.get_selection() || field_emergency.is_bound()) return TRUE;
if(field_imsi.is_bound()) return TRUE;
if(field_lchan__type.is_bound()) return TRUE;
if(field_lchan__mode.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__PDU__Signal::is_value() const
{
if(!field_callref.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_bearer__cap.get_selection() && !field_bearer__cap.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_called.get_selection() && !field_called.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_calling.get_selection() && !field_calling.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_redirecting.get_selection() && !field_redirecting.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_connected.get_selection() && !field_connected.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_cause.get_selection() && !field_cause.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_progress.get_selection() && !field_progress.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_useruser.get_selection() && !field_useruser.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_facility.get_selection() && !field_facility.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_cccap.get_selection() && !field_cccap.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ssversion.get_selection() && !field_ssversion.is_value()) return FALSE;
if(!field_clir__sup.is_value()) return FALSE;
if(!field_clir__inv.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_signal.get_selection() && !field_signal.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_keypad.get_selection() && !field_keypad.is_value()) return FALSE;
if(!field_more.is_value()) return FALSE;
if(!field_notify.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_emergency.get_selection() && !field_emergency.is_value()) return FALSE;
if(!field_imsi.is_value()) return FALSE;
if(!field_lchan__type.is_value()) return FALSE;
if(!field_lchan__mode.is_value()) return FALSE;
return TRUE;
}
int MNCC__PDU__Signal::size_of() const
{
  int ret_val = 8;
  if (field_bearer__cap.ispresent()) ret_val++;
  if (field_called.ispresent()) ret_val++;
  if (field_calling.ispresent()) ret_val++;
  if (field_redirecting.ispresent()) ret_val++;
  if (field_connected.ispresent()) ret_val++;
  if (field_cause.ispresent()) ret_val++;
  if (field_progress.ispresent()) ret_val++;
  if (field_useruser.ispresent()) ret_val++;
  if (field_facility.ispresent()) ret_val++;
  if (field_cccap.ispresent()) ret_val++;
  if (field_ssversion.ispresent()) ret_val++;
  if (field_signal.ispresent()) ret_val++;
  if (field_keypad.ispresent()) ret_val++;
  if (field_emergency.ispresent()) ret_val++;
  return ret_val;
}

void MNCC__PDU__Signal::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ callref := ");
field_callref.log();
TTCN_Logger::log_event_str(", bearer_cap := ");
field_bearer__cap.log();
TTCN_Logger::log_event_str(", called := ");
field_called.log();
TTCN_Logger::log_event_str(", calling := ");
field_calling.log();
TTCN_Logger::log_event_str(", redirecting := ");
field_redirecting.log();
TTCN_Logger::log_event_str(", connected := ");
field_connected.log();
TTCN_Logger::log_event_str(", cause := ");
field_cause.log();
TTCN_Logger::log_event_str(", progress := ");
field_progress.log();
TTCN_Logger::log_event_str(", useruser := ");
field_useruser.log();
TTCN_Logger::log_event_str(", facility := ");
field_facility.log();
TTCN_Logger::log_event_str(", cccap := ");
field_cccap.log();
TTCN_Logger::log_event_str(", ssversion := ");
field_ssversion.log();
TTCN_Logger::log_event_str(", clir_sup := ");
field_clir__sup.log();
TTCN_Logger::log_event_str(", clir_inv := ");
field_clir__inv.log();
TTCN_Logger::log_event_str(", signal := ");
field_signal.log();
TTCN_Logger::log_event_str(", keypad := ");
field_keypad.log();
TTCN_Logger::log_event_str(", more := ");
field_more.log();
TTCN_Logger::log_event_str(", notify := ");
field_notify.log();
TTCN_Logger::log_event_str(", emergency := ");
field_emergency.log();
TTCN_Logger::log_event_str(", imsi := ");
field_imsi.log();
TTCN_Logger::log_event_str(", lchan_type := ");
field_lchan__type.log();
TTCN_Logger::log_event_str(", lchan_mode := ");
field_lchan__mode.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__PDU__Signal::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (22<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_PDU_Signal has 22 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) bearer__cap().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) called().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) calling().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) redirecting().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) connected().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) cause().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) progress().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) useruser().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) facility().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) cccap().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) ssversion().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) clir__sup().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) clir__inv().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) signal().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) keypad().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) more().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) notify().set_param(*param.get_elem(17));
    if (param.get_size()>18 && param.get_elem(18)->get_type()!=Module_Param::MP_NotUsed) emergency().set_param(*param.get_elem(18));
    if (param.get_size()>19 && param.get_elem(19)->get_type()!=Module_Param::MP_NotUsed) imsi().set_param(*param.get_elem(19));
    if (param.get_size()>20 && param.get_elem(20)->get_type()!=Module_Param::MP_NotUsed) lchan__type().set_param(*param.get_elem(20));
    if (param.get_size()>21 && param.get_elem(21)->get_type()!=Module_Param::MP_NotUsed) lchan__mode().set_param(*param.get_elem(21));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bearer_cap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bearer__cap().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "called")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          called().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "calling")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          calling().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "redirecting")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          redirecting().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connected")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connected().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cause().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "progress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          progress().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "useruser")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          useruser().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "facility")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          facility().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cccap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cccap().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssversion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssversion().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clir_sup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clir__sup().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clir_inv")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clir__inv().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "keypad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          keypad().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "more")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          more().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "notify")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          notify().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "imsi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          imsi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_mode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__mode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Signal: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_PDU_Signal");
  }
}

void MNCC__PDU__Signal::set_implicit_omit()
{
if (callref().is_bound()) callref().set_implicit_omit();
if (!bearer__cap().is_bound()) bearer__cap() = OMIT_VALUE;
else bearer__cap().set_implicit_omit();
if (!called().is_bound()) called() = OMIT_VALUE;
else called().set_implicit_omit();
if (!calling().is_bound()) calling() = OMIT_VALUE;
else calling().set_implicit_omit();
if (!redirecting().is_bound()) redirecting() = OMIT_VALUE;
else redirecting().set_implicit_omit();
if (!connected().is_bound()) connected() = OMIT_VALUE;
else connected().set_implicit_omit();
if (!cause().is_bound()) cause() = OMIT_VALUE;
else cause().set_implicit_omit();
if (!progress().is_bound()) progress() = OMIT_VALUE;
else progress().set_implicit_omit();
if (!useruser().is_bound()) useruser() = OMIT_VALUE;
else useruser().set_implicit_omit();
if (!facility().is_bound()) facility() = OMIT_VALUE;
else facility().set_implicit_omit();
if (!cccap().is_bound()) cccap() = OMIT_VALUE;
else cccap().set_implicit_omit();
if (!ssversion().is_bound()) ssversion() = OMIT_VALUE;
else ssversion().set_implicit_omit();
if (clir__sup().is_bound()) clir__sup().set_implicit_omit();
if (clir__inv().is_bound()) clir__inv().set_implicit_omit();
if (!signal().is_bound()) signal() = OMIT_VALUE;
else signal().set_implicit_omit();
if (!keypad().is_bound()) keypad() = OMIT_VALUE;
else keypad().set_implicit_omit();
if (more().is_bound()) more().set_implicit_omit();
if (notify().is_bound()) notify().set_implicit_omit();
if (!emergency().is_bound()) emergency() = OMIT_VALUE;
else emergency().set_implicit_omit();
if (imsi().is_bound()) imsi().set_implicit_omit();
if (lchan__type().is_bound()) lchan__type().set_implicit_omit();
if (lchan__mode().is_bound()) lchan__mode().set_implicit_omit();
}

void MNCC__PDU__Signal::encode_text(Text_Buf& text_buf) const
{
field_callref.encode_text(text_buf);
field_bearer__cap.encode_text(text_buf);
field_called.encode_text(text_buf);
field_calling.encode_text(text_buf);
field_redirecting.encode_text(text_buf);
field_connected.encode_text(text_buf);
field_cause.encode_text(text_buf);
field_progress.encode_text(text_buf);
field_useruser.encode_text(text_buf);
field_facility.encode_text(text_buf);
field_cccap.encode_text(text_buf);
field_ssversion.encode_text(text_buf);
field_clir__sup.encode_text(text_buf);
field_clir__inv.encode_text(text_buf);
field_signal.encode_text(text_buf);
field_keypad.encode_text(text_buf);
field_more.encode_text(text_buf);
field_notify.encode_text(text_buf);
field_emergency.encode_text(text_buf);
field_imsi.encode_text(text_buf);
field_lchan__type.encode_text(text_buf);
field_lchan__mode.encode_text(text_buf);
}

void MNCC__PDU__Signal::decode_text(Text_Buf& text_buf)
{
field_callref.decode_text(text_buf);
field_bearer__cap.decode_text(text_buf);
field_called.decode_text(text_buf);
field_calling.decode_text(text_buf);
field_redirecting.decode_text(text_buf);
field_connected.decode_text(text_buf);
field_cause.decode_text(text_buf);
field_progress.decode_text(text_buf);
field_useruser.decode_text(text_buf);
field_facility.decode_text(text_buf);
field_cccap.decode_text(text_buf);
field_ssversion.decode_text(text_buf);
field_clir__sup.decode_text(text_buf);
field_clir__inv.decode_text(text_buf);
field_signal.decode_text(text_buf);
field_keypad.decode_text(text_buf);
field_more.decode_text(text_buf);
field_notify.decode_text(text_buf);
field_emergency.decode_text(text_buf);
field_imsi.decode_text(text_buf);
field_lchan__type.decode_text(text_buf);
field_lchan__mode.decode_text(text_buf);
}

void MNCC__PDU__Signal::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__PDU__Signal::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__PDU__Signal::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__PDU__Signal_callref_descr_.raw->forceomit);
  decoded_field_length = field_callref.RAW_decode(MNCC__PDU__Signal_callref_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(1)) {
    field_bearer__cap = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__PDU__Signal_bearer__cap_descr_.raw->forceomit);
  decoded_field_length = field_bearer__cap().RAW_decode(MNCC__PDU__Signal_bearer__cap_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 1) {
  field_bearer__cap = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_bearer__cap=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(2)) {
    field_called = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__PDU__Signal_called_descr_.raw->forceomit);
  decoded_field_length = field_called().RAW_decode(MNCC__PDU__Signal_called_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 1) {
  field_called = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_called=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(3)) {
    field_calling = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__PDU__Signal_calling_descr_.raw->forceomit);
  decoded_field_length = field_calling().RAW_decode(MNCC__PDU__Signal_calling_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 1) {
  field_calling = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_calling=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(4)) {
    field_redirecting = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__PDU__Signal_redirecting_descr_.raw->forceomit);
  decoded_field_length = field_redirecting().RAW_decode(MNCC__PDU__Signal_redirecting_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 1) {
  field_redirecting = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_redirecting=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(5)) {
    field_connected = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_5_force_omit(5, force_omit, MNCC__PDU__Signal_connected_descr_.raw->forceomit);
  decoded_field_length = field_connected().RAW_decode(MNCC__PDU__Signal_connected_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 1) {
  field_connected = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_connected=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(6)) {
    field_cause = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_6_force_omit(6, force_omit, MNCC__PDU__Signal_cause_descr_.raw->forceomit);
  decoded_field_length = field_cause().RAW_decode(MNCC__PDU__Signal_cause_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 1) {
  field_cause = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_cause=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(7)) {
    field_progress = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_7_force_omit(7, force_omit, MNCC__PDU__Signal_progress_descr_.raw->forceomit);
  decoded_field_length = field_progress().RAW_decode(MNCC__PDU__Signal_progress_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 1) {
  field_progress = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_progress=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(8)) {
    field_useruser = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_8_force_omit(8, force_omit, MNCC__PDU__Signal_useruser_descr_.raw->forceomit);
  decoded_field_length = field_useruser().RAW_decode(MNCC__PDU__Signal_useruser_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 1) {
  field_useruser = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_useruser=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(9)) {
    field_facility = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_9_force_omit(9, force_omit, MNCC__PDU__Signal_facility_descr_.raw->forceomit);
  decoded_field_length = field_facility().RAW_decode(MNCC__PDU__Signal_facility_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 1) {
  field_facility = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_facility=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(10)) {
    field_cccap = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_10_force_omit(10, force_omit, MNCC__PDU__Signal_cccap_descr_.raw->forceomit);
  decoded_field_length = field_cccap().RAW_decode(MNCC__PDU__Signal_cccap_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_10_force_omit);
  if (decoded_field_length < 1) {
  field_cccap = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_cccap=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(11)) {
    field_ssversion = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_11_force_omit(11, force_omit, MNCC__PDU__Signal_ssversion_descr_.raw->forceomit);
  decoded_field_length = field_ssversion().RAW_decode(MNCC__PDU__Signal_ssversion_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_11_force_omit);
  if (decoded_field_length < 1) {
  field_ssversion = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_ssversion=OMIT_VALUE;
  RAW_Force_Omit field_12_force_omit(12, force_omit, MNCC__PDU__Signal_clir__sup_descr_.raw->forceomit);
  decoded_field_length = field_clir__sup.RAW_decode(MNCC__PDU__Signal_clir__sup_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_12_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_13_force_omit(13, force_omit, MNCC__PDU__Signal_clir__inv_descr_.raw->forceomit);
  decoded_field_length = field_clir__inv.RAW_decode(MNCC__PDU__Signal_clir__inv_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_13_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(14)) {
    field_signal = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_14_force_omit(14, force_omit, MNCC__PDU__Signal_signal_descr_.raw->forceomit);
  decoded_field_length = field_signal().RAW_decode(MNCC__PDU__Signal_signal_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_14_force_omit);
  if (decoded_field_length < 1) {
  field_signal = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_signal=OMIT_VALUE;
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(15)) {
    field_keypad = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_15_force_omit(15, force_omit, MNCC__PDU__Signal_keypad_descr_.raw->forceomit);
  decoded_field_length = field_keypad().RAW_decode(MNCC__PDU__Signal_keypad_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_15_force_omit);
  if (decoded_field_length < 1) {
  field_keypad = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_keypad=OMIT_VALUE;
  RAW_Force_Omit field_16_force_omit(16, force_omit, MNCC__PDU__Signal_more_descr_.raw->forceomit);
  decoded_field_length = field_more.RAW_decode(MNCC__PDU__Signal_more_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_16_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_17_force_omit(17, force_omit, MNCC__PDU__Signal_notify_descr_.raw->forceomit);
  decoded_field_length = field_notify.RAW_decode(MNCC__PDU__Signal_notify_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_17_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  if (force_omit != NULL && (*force_omit)(18)) {
    field_emergency = OMIT_VALUE;
  }
  else {
  size_t fl_start_pos = p_buf.get_pos_bit();
  RAW_Force_Omit field_18_force_omit(18, force_omit, MNCC__PDU__Signal_emergency_descr_.raw->forceomit);
  decoded_field_length = field_emergency().RAW_decode(MNCC__PDU__Signal_emergency_descr_, p_buf, limit, local_top_order, TRUE, -1, TRUE, &field_18_force_omit);
  if (decoded_field_length < 1) {
  field_emergency = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  }
  else field_emergency=OMIT_VALUE;
  RAW_Force_Omit field_19_force_omit(19, force_omit, MNCC__PDU__Signal_imsi_descr_.raw->forceomit);
  decoded_field_length = field_imsi.RAW_decode(MNCC__PDU__Signal_imsi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_19_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_20_force_omit(20, force_omit, MNCC__PDU__Signal_lchan__type_descr_.raw->forceomit);
  decoded_field_length = field_lchan__type.RAW_decode(MNCC__PDU__Signal_lchan__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_20_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_21_force_omit(21, force_omit, MNCC__PDU__Signal_lchan__mode_descr_.raw->forceomit);
  decoded_field_length = field_lchan__mode.RAW_decode(MNCC__PDU__Signal_lchan__mode_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_21_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__PDU__Signal::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 22;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(22);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__PDU__Signal_callref_descr_.raw);
  if (field_bearer__cap.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__PDU__Signal_bearer__cap_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_called.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__PDU__Signal_called_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  if (field_calling.ispresent()) {
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__PDU__Signal_calling_descr_.raw);
  }
  else myleaf.body.node.nodes[3] = NULL;
  if (field_redirecting.ispresent()) {
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__PDU__Signal_redirecting_descr_.raw);
  }
  else myleaf.body.node.nodes[4] = NULL;
  if (field_connected.ispresent()) {
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, MNCC__PDU__Signal_connected_descr_.raw);
  }
  else myleaf.body.node.nodes[5] = NULL;
  if (field_cause.ispresent()) {
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, MNCC__PDU__Signal_cause_descr_.raw);
  }
  else myleaf.body.node.nodes[6] = NULL;
  if (field_progress.ispresent()) {
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, MNCC__PDU__Signal_progress_descr_.raw);
  }
  else myleaf.body.node.nodes[7] = NULL;
  if (field_useruser.ispresent()) {
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, MNCC__PDU__Signal_useruser_descr_.raw);
  }
  else myleaf.body.node.nodes[8] = NULL;
  if (field_facility.ispresent()) {
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, MNCC__PDU__Signal_facility_descr_.raw);
  }
  else myleaf.body.node.nodes[9] = NULL;
  if (field_cccap.ispresent()) {
  myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 10, MNCC__PDU__Signal_cccap_descr_.raw);
  }
  else myleaf.body.node.nodes[10] = NULL;
  if (field_ssversion.ispresent()) {
  myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 11, MNCC__PDU__Signal_ssversion_descr_.raw);
  }
  else myleaf.body.node.nodes[11] = NULL;
  myleaf.body.node.nodes[12] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 12, MNCC__PDU__Signal_clir__sup_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 13, MNCC__PDU__Signal_clir__inv_descr_.raw);
  if (field_signal.ispresent()) {
  myleaf.body.node.nodes[14] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 14, MNCC__PDU__Signal_signal_descr_.raw);
  }
  else myleaf.body.node.nodes[14] = NULL;
  if (field_keypad.ispresent()) {
  myleaf.body.node.nodes[15] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 15, MNCC__PDU__Signal_keypad_descr_.raw);
  }
  else myleaf.body.node.nodes[15] = NULL;
  myleaf.body.node.nodes[16] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 16, MNCC__PDU__Signal_more_descr_.raw);
  myleaf.body.node.nodes[17] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 17, MNCC__PDU__Signal_notify_descr_.raw);
  if (field_emergency.ispresent()) {
  myleaf.body.node.nodes[18] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 18, MNCC__PDU__Signal_emergency_descr_.raw);
  }
  else myleaf.body.node.nodes[18] = NULL;
  myleaf.body.node.nodes[19] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 19, MNCC__PDU__Signal_imsi_descr_.raw);
  myleaf.body.node.nodes[20] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 20, MNCC__PDU__Signal_lchan__type_descr_.raw);
  myleaf.body.node.nodes[21] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 21, MNCC__PDU__Signal_lchan__mode_descr_.raw);
  encoded_length += field_callref.RAW_encode(MNCC__PDU__Signal_callref_descr_, *myleaf.body.node.nodes[0]);
  if (field_bearer__cap.ispresent()) {
  encoded_length += field_bearer__cap().RAW_encode(MNCC__PDU__Signal_bearer__cap_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_called.ispresent()) {
  encoded_length += field_called().RAW_encode(MNCC__PDU__Signal_called_descr_, *myleaf.body.node.nodes[2]);
  }
  if (field_calling.ispresent()) {
  encoded_length += field_calling().RAW_encode(MNCC__PDU__Signal_calling_descr_, *myleaf.body.node.nodes[3]);
  }
  if (field_redirecting.ispresent()) {
  encoded_length += field_redirecting().RAW_encode(MNCC__PDU__Signal_redirecting_descr_, *myleaf.body.node.nodes[4]);
  }
  if (field_connected.ispresent()) {
  encoded_length += field_connected().RAW_encode(MNCC__PDU__Signal_connected_descr_, *myleaf.body.node.nodes[5]);
  }
  if (field_cause.ispresent()) {
  encoded_length += field_cause().RAW_encode(MNCC__PDU__Signal_cause_descr_, *myleaf.body.node.nodes[6]);
  }
  if (field_progress.ispresent()) {
  encoded_length += field_progress().RAW_encode(MNCC__PDU__Signal_progress_descr_, *myleaf.body.node.nodes[7]);
  }
  if (field_useruser.ispresent()) {
  encoded_length += field_useruser().RAW_encode(MNCC__PDU__Signal_useruser_descr_, *myleaf.body.node.nodes[8]);
  }
  if (field_facility.ispresent()) {
  encoded_length += field_facility().RAW_encode(MNCC__PDU__Signal_facility_descr_, *myleaf.body.node.nodes[9]);
  }
  if (field_cccap.ispresent()) {
  encoded_length += field_cccap().RAW_encode(MNCC__PDU__Signal_cccap_descr_, *myleaf.body.node.nodes[10]);
  }
  if (field_ssversion.ispresent()) {
  encoded_length += field_ssversion().RAW_encode(MNCC__PDU__Signal_ssversion_descr_, *myleaf.body.node.nodes[11]);
  }
  encoded_length += field_clir__sup.RAW_encode(MNCC__PDU__Signal_clir__sup_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_clir__inv.RAW_encode(MNCC__PDU__Signal_clir__inv_descr_, *myleaf.body.node.nodes[13]);
  if (field_signal.ispresent()) {
  encoded_length += field_signal().RAW_encode(MNCC__PDU__Signal_signal_descr_, *myleaf.body.node.nodes[14]);
  }
  if (field_keypad.ispresent()) {
  encoded_length += field_keypad().RAW_encode(MNCC__PDU__Signal_keypad_descr_, *myleaf.body.node.nodes[15]);
  }
  encoded_length += field_more.RAW_encode(MNCC__PDU__Signal_more_descr_, *myleaf.body.node.nodes[16]);
  encoded_length += field_notify.RAW_encode(MNCC__PDU__Signal_notify_descr_, *myleaf.body.node.nodes[17]);
  if (field_emergency.ispresent()) {
  encoded_length += field_emergency().RAW_encode(MNCC__PDU__Signal_emergency_descr_, *myleaf.body.node.nodes[18]);
  }
  encoded_length += field_imsi.RAW_encode(MNCC__PDU__Signal_imsi_descr_, *myleaf.body.node.nodes[19]);
  encoded_length += field_lchan__type.RAW_encode(MNCC__PDU__Signal_lchan__type_descr_, *myleaf.body.node.nodes[20]);
  encoded_length += field_lchan__mode.RAW_encode(MNCC__PDU__Signal_lchan__mode_descr_, *myleaf.body.node.nodes[21]);
  return myleaf.length = encoded_length;
}

struct MNCC__PDU__Signal_template::single_value_struct {
INTEGER_template field_callref;
MNCC__bearer__cap_template field_bearer__cap;
MNCC__number_template field_called;
MNCC__number_template field_calling;
MNCC__number_template field_redirecting;
MNCC__number_template field_connected;
MNCC__cause_template field_cause;
MNCC__progress_template field_progress;
MNCC__useruser_template field_useruser;
CHARSTRING_template field_facility;
MNCC__cccap_template field_cccap;
CHARSTRING_template field_ssversion;
INTEGER_template field_clir__sup;
INTEGER_template field_clir__inv;
INTEGER_template field_signal;
CHARSTRING_template field_keypad;
INTEGER_template field_more;
INTEGER_template field_notify;
INTEGER_template field_emergency;
CHARSTRING_template field_imsi;
INTEGER_template field_lchan__type;
INTEGER_template field_lchan__mode;
};

void MNCC__PDU__Signal_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_callref = ANY_VALUE;
single_value->field_bearer__cap = ANY_OR_OMIT;
single_value->field_called = ANY_OR_OMIT;
single_value->field_calling = ANY_OR_OMIT;
single_value->field_redirecting = ANY_OR_OMIT;
single_value->field_connected = ANY_OR_OMIT;
single_value->field_cause = ANY_OR_OMIT;
single_value->field_progress = ANY_OR_OMIT;
single_value->field_useruser = ANY_OR_OMIT;
single_value->field_facility = ANY_OR_OMIT;
single_value->field_cccap = ANY_OR_OMIT;
single_value->field_ssversion = ANY_OR_OMIT;
single_value->field_clir__sup = ANY_VALUE;
single_value->field_clir__inv = ANY_VALUE;
single_value->field_signal = ANY_OR_OMIT;
single_value->field_keypad = ANY_OR_OMIT;
single_value->field_more = ANY_VALUE;
single_value->field_notify = ANY_VALUE;
single_value->field_emergency = ANY_OR_OMIT;
single_value->field_imsi = ANY_VALUE;
single_value->field_lchan__type = ANY_VALUE;
single_value->field_lchan__mode = ANY_VALUE;
}
}
}

void MNCC__PDU__Signal_template::copy_value(const MNCC__PDU__Signal& other_value)
{
single_value = new single_value_struct;
if (other_value.callref().is_bound()) {
  single_value->field_callref = other_value.callref();
} else {
  single_value->field_callref.clean_up();
}
if (other_value.bearer__cap().is_bound()) {
  if (other_value.bearer__cap().ispresent()) single_value->field_bearer__cap = other_value.bearer__cap()();
  else single_value->field_bearer__cap = OMIT_VALUE;
} else {
  single_value->field_bearer__cap.clean_up();
}
if (other_value.called().is_bound()) {
  if (other_value.called().ispresent()) single_value->field_called = other_value.called()();
  else single_value->field_called = OMIT_VALUE;
} else {
  single_value->field_called.clean_up();
}
if (other_value.calling().is_bound()) {
  if (other_value.calling().ispresent()) single_value->field_calling = other_value.calling()();
  else single_value->field_calling = OMIT_VALUE;
} else {
  single_value->field_calling.clean_up();
}
if (other_value.redirecting().is_bound()) {
  if (other_value.redirecting().ispresent()) single_value->field_redirecting = other_value.redirecting()();
  else single_value->field_redirecting = OMIT_VALUE;
} else {
  single_value->field_redirecting.clean_up();
}
if (other_value.connected().is_bound()) {
  if (other_value.connected().ispresent()) single_value->field_connected = other_value.connected()();
  else single_value->field_connected = OMIT_VALUE;
} else {
  single_value->field_connected.clean_up();
}
if (other_value.cause().is_bound()) {
  if (other_value.cause().ispresent()) single_value->field_cause = other_value.cause()();
  else single_value->field_cause = OMIT_VALUE;
} else {
  single_value->field_cause.clean_up();
}
if (other_value.progress().is_bound()) {
  if (other_value.progress().ispresent()) single_value->field_progress = other_value.progress()();
  else single_value->field_progress = OMIT_VALUE;
} else {
  single_value->field_progress.clean_up();
}
if (other_value.useruser().is_bound()) {
  if (other_value.useruser().ispresent()) single_value->field_useruser = other_value.useruser()();
  else single_value->field_useruser = OMIT_VALUE;
} else {
  single_value->field_useruser.clean_up();
}
if (other_value.facility().is_bound()) {
  if (other_value.facility().ispresent()) single_value->field_facility = other_value.facility()();
  else single_value->field_facility = OMIT_VALUE;
} else {
  single_value->field_facility.clean_up();
}
if (other_value.cccap().is_bound()) {
  if (other_value.cccap().ispresent()) single_value->field_cccap = other_value.cccap()();
  else single_value->field_cccap = OMIT_VALUE;
} else {
  single_value->field_cccap.clean_up();
}
if (other_value.ssversion().is_bound()) {
  if (other_value.ssversion().ispresent()) single_value->field_ssversion = other_value.ssversion()();
  else single_value->field_ssversion = OMIT_VALUE;
} else {
  single_value->field_ssversion.clean_up();
}
if (other_value.clir__sup().is_bound()) {
  single_value->field_clir__sup = other_value.clir__sup();
} else {
  single_value->field_clir__sup.clean_up();
}
if (other_value.clir__inv().is_bound()) {
  single_value->field_clir__inv = other_value.clir__inv();
} else {
  single_value->field_clir__inv.clean_up();
}
if (other_value.signal().is_bound()) {
  if (other_value.signal().ispresent()) single_value->field_signal = other_value.signal()();
  else single_value->field_signal = OMIT_VALUE;
} else {
  single_value->field_signal.clean_up();
}
if (other_value.keypad().is_bound()) {
  if (other_value.keypad().ispresent()) single_value->field_keypad = other_value.keypad()();
  else single_value->field_keypad = OMIT_VALUE;
} else {
  single_value->field_keypad.clean_up();
}
if (other_value.more().is_bound()) {
  single_value->field_more = other_value.more();
} else {
  single_value->field_more.clean_up();
}
if (other_value.notify().is_bound()) {
  single_value->field_notify = other_value.notify();
} else {
  single_value->field_notify.clean_up();
}
if (other_value.emergency().is_bound()) {
  if (other_value.emergency().ispresent()) single_value->field_emergency = other_value.emergency()();
  else single_value->field_emergency = OMIT_VALUE;
} else {
  single_value->field_emergency.clean_up();
}
if (other_value.imsi().is_bound()) {
  single_value->field_imsi = other_value.imsi();
} else {
  single_value->field_imsi.clean_up();
}
if (other_value.lchan__type().is_bound()) {
  single_value->field_lchan__type = other_value.lchan__type();
} else {
  single_value->field_lchan__type.clean_up();
}
if (other_value.lchan__mode().is_bound()) {
  single_value->field_lchan__mode = other_value.lchan__mode();
} else {
  single_value->field_lchan__mode.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__PDU__Signal_template::copy_template(const MNCC__PDU__Signal_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.callref().get_selection()) {
single_value->field_callref = other_value.callref();
} else {
single_value->field_callref.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.bearer__cap().get_selection()) {
single_value->field_bearer__cap = other_value.bearer__cap();
} else {
single_value->field_bearer__cap.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.called().get_selection()) {
single_value->field_called = other_value.called();
} else {
single_value->field_called.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.calling().get_selection()) {
single_value->field_calling = other_value.calling();
} else {
single_value->field_calling.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.redirecting().get_selection()) {
single_value->field_redirecting = other_value.redirecting();
} else {
single_value->field_redirecting.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connected().get_selection()) {
single_value->field_connected = other_value.connected();
} else {
single_value->field_connected.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cause().get_selection()) {
single_value->field_cause = other_value.cause();
} else {
single_value->field_cause.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.progress().get_selection()) {
single_value->field_progress = other_value.progress();
} else {
single_value->field_progress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.useruser().get_selection()) {
single_value->field_useruser = other_value.useruser();
} else {
single_value->field_useruser.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.facility().get_selection()) {
single_value->field_facility = other_value.facility();
} else {
single_value->field_facility.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cccap().get_selection()) {
single_value->field_cccap = other_value.cccap();
} else {
single_value->field_cccap.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ssversion().get_selection()) {
single_value->field_ssversion = other_value.ssversion();
} else {
single_value->field_ssversion.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.clir__sup().get_selection()) {
single_value->field_clir__sup = other_value.clir__sup();
} else {
single_value->field_clir__sup.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.clir__inv().get_selection()) {
single_value->field_clir__inv = other_value.clir__inv();
} else {
single_value->field_clir__inv.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signal().get_selection()) {
single_value->field_signal = other_value.signal();
} else {
single_value->field_signal.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.keypad().get_selection()) {
single_value->field_keypad = other_value.keypad();
} else {
single_value->field_keypad.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.more().get_selection()) {
single_value->field_more = other_value.more();
} else {
single_value->field_more.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.notify().get_selection()) {
single_value->field_notify = other_value.notify();
} else {
single_value->field_notify.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergency().get_selection()) {
single_value->field_emergency = other_value.emergency();
} else {
single_value->field_emergency.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.imsi().get_selection()) {
single_value->field_imsi = other_value.imsi();
} else {
single_value->field_imsi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lchan__type().get_selection()) {
single_value->field_lchan__type = other_value.lchan__type();
} else {
single_value->field_lchan__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lchan__mode().get_selection()) {
single_value->field_lchan__mode = other_value.lchan__mode();
} else {
single_value->field_lchan__mode.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__PDU__Signal_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Signal.");
break;
}
set_selection(other_value);
}

MNCC__PDU__Signal_template::MNCC__PDU__Signal_template()
{
}

MNCC__PDU__Signal_template::MNCC__PDU__Signal_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__PDU__Signal_template::MNCC__PDU__Signal_template(const MNCC__PDU__Signal& other_value)
{
copy_value(other_value);
}

MNCC__PDU__Signal_template::MNCC__PDU__Signal_template(const OPTIONAL<MNCC__PDU__Signal>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Signal&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_PDU_Signal from an unbound optional field.");
}
}

MNCC__PDU__Signal_template::MNCC__PDU__Signal_template(const MNCC__PDU__Signal_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__PDU__Signal_template::~MNCC__PDU__Signal_template()
{
clean_up();
}

MNCC__PDU__Signal_template& MNCC__PDU__Signal_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__PDU__Signal_template& MNCC__PDU__Signal_template::operator=(const MNCC__PDU__Signal& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__PDU__Signal_template& MNCC__PDU__Signal_template::operator=(const OPTIONAL<MNCC__PDU__Signal>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Signal&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_PDU_Signal.");
}
return *this;
}

MNCC__PDU__Signal_template& MNCC__PDU__Signal_template::operator=(const MNCC__PDU__Signal_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__PDU__Signal_template::match(const MNCC__PDU__Signal& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.callref().is_bound()) return FALSE;
if(!single_value->field_callref.match(other_value.callref(), legacy))return FALSE;
if(!other_value.bearer__cap().is_bound()) return FALSE;
if((other_value.bearer__cap().ispresent() ? !single_value->field_bearer__cap.match((const MNCC__bearer__cap&)other_value.bearer__cap(), legacy) : !single_value->field_bearer__cap.match_omit(legacy)))return FALSE;
if(!other_value.called().is_bound()) return FALSE;
if((other_value.called().ispresent() ? !single_value->field_called.match((const MNCC__number&)other_value.called(), legacy) : !single_value->field_called.match_omit(legacy)))return FALSE;
if(!other_value.calling().is_bound()) return FALSE;
if((other_value.calling().ispresent() ? !single_value->field_calling.match((const MNCC__number&)other_value.calling(), legacy) : !single_value->field_calling.match_omit(legacy)))return FALSE;
if(!other_value.redirecting().is_bound()) return FALSE;
if((other_value.redirecting().ispresent() ? !single_value->field_redirecting.match((const MNCC__number&)other_value.redirecting(), legacy) : !single_value->field_redirecting.match_omit(legacy)))return FALSE;
if(!other_value.connected().is_bound()) return FALSE;
if((other_value.connected().ispresent() ? !single_value->field_connected.match((const MNCC__number&)other_value.connected(), legacy) : !single_value->field_connected.match_omit(legacy)))return FALSE;
if(!other_value.cause().is_bound()) return FALSE;
if((other_value.cause().ispresent() ? !single_value->field_cause.match((const MNCC__cause&)other_value.cause(), legacy) : !single_value->field_cause.match_omit(legacy)))return FALSE;
if(!other_value.progress().is_bound()) return FALSE;
if((other_value.progress().ispresent() ? !single_value->field_progress.match((const MNCC__progress&)other_value.progress(), legacy) : !single_value->field_progress.match_omit(legacy)))return FALSE;
if(!other_value.useruser().is_bound()) return FALSE;
if((other_value.useruser().ispresent() ? !single_value->field_useruser.match((const MNCC__useruser&)other_value.useruser(), legacy) : !single_value->field_useruser.match_omit(legacy)))return FALSE;
if(!other_value.facility().is_bound()) return FALSE;
if((other_value.facility().ispresent() ? !single_value->field_facility.match((const CHARSTRING&)other_value.facility(), legacy) : !single_value->field_facility.match_omit(legacy)))return FALSE;
if(!other_value.cccap().is_bound()) return FALSE;
if((other_value.cccap().ispresent() ? !single_value->field_cccap.match((const MNCC__cccap&)other_value.cccap(), legacy) : !single_value->field_cccap.match_omit(legacy)))return FALSE;
if(!other_value.ssversion().is_bound()) return FALSE;
if((other_value.ssversion().ispresent() ? !single_value->field_ssversion.match((const CHARSTRING&)other_value.ssversion(), legacy) : !single_value->field_ssversion.match_omit(legacy)))return FALSE;
if(!other_value.clir__sup().is_bound()) return FALSE;
if(!single_value->field_clir__sup.match(other_value.clir__sup(), legacy))return FALSE;
if(!other_value.clir__inv().is_bound()) return FALSE;
if(!single_value->field_clir__inv.match(other_value.clir__inv(), legacy))return FALSE;
if(!other_value.signal().is_bound()) return FALSE;
if((other_value.signal().ispresent() ? !single_value->field_signal.match((const INTEGER&)other_value.signal(), legacy) : !single_value->field_signal.match_omit(legacy)))return FALSE;
if(!other_value.keypad().is_bound()) return FALSE;
if((other_value.keypad().ispresent() ? !single_value->field_keypad.match((const CHARSTRING&)other_value.keypad(), legacy) : !single_value->field_keypad.match_omit(legacy)))return FALSE;
if(!other_value.more().is_bound()) return FALSE;
if(!single_value->field_more.match(other_value.more(), legacy))return FALSE;
if(!other_value.notify().is_bound()) return FALSE;
if(!single_value->field_notify.match(other_value.notify(), legacy))return FALSE;
if(!other_value.emergency().is_bound()) return FALSE;
if((other_value.emergency().ispresent() ? !single_value->field_emergency.match((const INTEGER&)other_value.emergency(), legacy) : !single_value->field_emergency.match_omit(legacy)))return FALSE;
if(!other_value.imsi().is_bound()) return FALSE;
if(!single_value->field_imsi.match(other_value.imsi(), legacy))return FALSE;
if(!other_value.lchan__type().is_bound()) return FALSE;
if(!single_value->field_lchan__type.match(other_value.lchan__type(), legacy))return FALSE;
if(!other_value.lchan__mode().is_bound()) return FALSE;
if(!single_value->field_lchan__mode.match(other_value.lchan__mode(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Signal.");
}
return FALSE;
}

boolean MNCC__PDU__Signal_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_callref.is_bound()) return TRUE;
if (single_value->field_bearer__cap.is_omit() || single_value->field_bearer__cap.is_bound()) return TRUE;
if (single_value->field_called.is_omit() || single_value->field_called.is_bound()) return TRUE;
if (single_value->field_calling.is_omit() || single_value->field_calling.is_bound()) return TRUE;
if (single_value->field_redirecting.is_omit() || single_value->field_redirecting.is_bound()) return TRUE;
if (single_value->field_connected.is_omit() || single_value->field_connected.is_bound()) return TRUE;
if (single_value->field_cause.is_omit() || single_value->field_cause.is_bound()) return TRUE;
if (single_value->field_progress.is_omit() || single_value->field_progress.is_bound()) return TRUE;
if (single_value->field_useruser.is_omit() || single_value->field_useruser.is_bound()) return TRUE;
if (single_value->field_facility.is_omit() || single_value->field_facility.is_bound()) return TRUE;
if (single_value->field_cccap.is_omit() || single_value->field_cccap.is_bound()) return TRUE;
if (single_value->field_ssversion.is_omit() || single_value->field_ssversion.is_bound()) return TRUE;
if (single_value->field_clir__sup.is_bound()) return TRUE;
if (single_value->field_clir__inv.is_bound()) return TRUE;
if (single_value->field_signal.is_omit() || single_value->field_signal.is_bound()) return TRUE;
if (single_value->field_keypad.is_omit() || single_value->field_keypad.is_bound()) return TRUE;
if (single_value->field_more.is_bound()) return TRUE;
if (single_value->field_notify.is_bound()) return TRUE;
if (single_value->field_emergency.is_omit() || single_value->field_emergency.is_bound()) return TRUE;
if (single_value->field_imsi.is_bound()) return TRUE;
if (single_value->field_lchan__type.is_bound()) return TRUE;
if (single_value->field_lchan__mode.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__PDU__Signal_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_callref.is_value()) return FALSE;
if (!single_value->field_bearer__cap.is_omit() && !single_value->field_bearer__cap.is_value()) return FALSE;
if (!single_value->field_called.is_omit() && !single_value->field_called.is_value()) return FALSE;
if (!single_value->field_calling.is_omit() && !single_value->field_calling.is_value()) return FALSE;
if (!single_value->field_redirecting.is_omit() && !single_value->field_redirecting.is_value()) return FALSE;
if (!single_value->field_connected.is_omit() && !single_value->field_connected.is_value()) return FALSE;
if (!single_value->field_cause.is_omit() && !single_value->field_cause.is_value()) return FALSE;
if (!single_value->field_progress.is_omit() && !single_value->field_progress.is_value()) return FALSE;
if (!single_value->field_useruser.is_omit() && !single_value->field_useruser.is_value()) return FALSE;
if (!single_value->field_facility.is_omit() && !single_value->field_facility.is_value()) return FALSE;
if (!single_value->field_cccap.is_omit() && !single_value->field_cccap.is_value()) return FALSE;
if (!single_value->field_ssversion.is_omit() && !single_value->field_ssversion.is_value()) return FALSE;
if (!single_value->field_clir__sup.is_value()) return FALSE;
if (!single_value->field_clir__inv.is_value()) return FALSE;
if (!single_value->field_signal.is_omit() && !single_value->field_signal.is_value()) return FALSE;
if (!single_value->field_keypad.is_omit() && !single_value->field_keypad.is_value()) return FALSE;
if (!single_value->field_more.is_value()) return FALSE;
if (!single_value->field_notify.is_value()) return FALSE;
if (!single_value->field_emergency.is_omit() && !single_value->field_emergency.is_value()) return FALSE;
if (!single_value->field_imsi.is_value()) return FALSE;
if (!single_value->field_lchan__type.is_value()) return FALSE;
if (!single_value->field_lchan__mode.is_value()) return FALSE;
return TRUE;
}

void MNCC__PDU__Signal_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__PDU__Signal MNCC__PDU__Signal_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
MNCC__PDU__Signal ret_val;
if (single_value->field_callref.is_bound()) {
ret_val.callref() = single_value->field_callref.valueof();
}
if (single_value->field_bearer__cap.is_omit()) ret_val.bearer__cap() = OMIT_VALUE;
else if (single_value->field_bearer__cap.is_bound()) {
ret_val.bearer__cap() = single_value->field_bearer__cap.valueof();
}
if (single_value->field_called.is_omit()) ret_val.called() = OMIT_VALUE;
else if (single_value->field_called.is_bound()) {
ret_val.called() = single_value->field_called.valueof();
}
if (single_value->field_calling.is_omit()) ret_val.calling() = OMIT_VALUE;
else if (single_value->field_calling.is_bound()) {
ret_val.calling() = single_value->field_calling.valueof();
}
if (single_value->field_redirecting.is_omit()) ret_val.redirecting() = OMIT_VALUE;
else if (single_value->field_redirecting.is_bound()) {
ret_val.redirecting() = single_value->field_redirecting.valueof();
}
if (single_value->field_connected.is_omit()) ret_val.connected() = OMIT_VALUE;
else if (single_value->field_connected.is_bound()) {
ret_val.connected() = single_value->field_connected.valueof();
}
if (single_value->field_cause.is_omit()) ret_val.cause() = OMIT_VALUE;
else if (single_value->field_cause.is_bound()) {
ret_val.cause() = single_value->field_cause.valueof();
}
if (single_value->field_progress.is_omit()) ret_val.progress() = OMIT_VALUE;
else if (single_value->field_progress.is_bound()) {
ret_val.progress() = single_value->field_progress.valueof();
}
if (single_value->field_useruser.is_omit()) ret_val.useruser() = OMIT_VALUE;
else if (single_value->field_useruser.is_bound()) {
ret_val.useruser() = single_value->field_useruser.valueof();
}
if (single_value->field_facility.is_omit()) ret_val.facility() = OMIT_VALUE;
else if (single_value->field_facility.is_bound()) {
ret_val.facility() = single_value->field_facility.valueof();
}
if (single_value->field_cccap.is_omit()) ret_val.cccap() = OMIT_VALUE;
else if (single_value->field_cccap.is_bound()) {
ret_val.cccap() = single_value->field_cccap.valueof();
}
if (single_value->field_ssversion.is_omit()) ret_val.ssversion() = OMIT_VALUE;
else if (single_value->field_ssversion.is_bound()) {
ret_val.ssversion() = single_value->field_ssversion.valueof();
}
if (single_value->field_clir__sup.is_bound()) {
ret_val.clir__sup() = single_value->field_clir__sup.valueof();
}
if (single_value->field_clir__inv.is_bound()) {
ret_val.clir__inv() = single_value->field_clir__inv.valueof();
}
if (single_value->field_signal.is_omit()) ret_val.signal() = OMIT_VALUE;
else if (single_value->field_signal.is_bound()) {
ret_val.signal() = single_value->field_signal.valueof();
}
if (single_value->field_keypad.is_omit()) ret_val.keypad() = OMIT_VALUE;
else if (single_value->field_keypad.is_bound()) {
ret_val.keypad() = single_value->field_keypad.valueof();
}
if (single_value->field_more.is_bound()) {
ret_val.more() = single_value->field_more.valueof();
}
if (single_value->field_notify.is_bound()) {
ret_val.notify() = single_value->field_notify.valueof();
}
if (single_value->field_emergency.is_omit()) ret_val.emergency() = OMIT_VALUE;
else if (single_value->field_emergency.is_bound()) {
ret_val.emergency() = single_value->field_emergency.valueof();
}
if (single_value->field_imsi.is_bound()) {
ret_val.imsi() = single_value->field_imsi.valueof();
}
if (single_value->field_lchan__type.is_bound()) {
ret_val.lchan__type() = single_value->field_lchan__type.valueof();
}
if (single_value->field_lchan__mode.is_bound()) {
ret_val.lchan__mode() = single_value->field_lchan__mode.valueof();
}
return ret_val;
}

void MNCC__PDU__Signal_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_PDU_Signal.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__PDU__Signal_template[list_length];
}

MNCC__PDU__Signal_template& MNCC__PDU__Signal_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_PDU_Signal.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_PDU_Signal.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__PDU__Signal_template::callref()
{
set_specific();
return single_value->field_callref;
}

const INTEGER_template& MNCC__PDU__Signal_template::callref() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field callref of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_callref;
}

MNCC__bearer__cap_template& MNCC__PDU__Signal_template::bearer__cap()
{
set_specific();
return single_value->field_bearer__cap;
}

const MNCC__bearer__cap_template& MNCC__PDU__Signal_template::bearer__cap() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bearer_cap of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_bearer__cap;
}

MNCC__number_template& MNCC__PDU__Signal_template::called()
{
set_specific();
return single_value->field_called;
}

const MNCC__number_template& MNCC__PDU__Signal_template::called() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field called of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_called;
}

MNCC__number_template& MNCC__PDU__Signal_template::calling()
{
set_specific();
return single_value->field_calling;
}

const MNCC__number_template& MNCC__PDU__Signal_template::calling() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field calling of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_calling;
}

MNCC__number_template& MNCC__PDU__Signal_template::redirecting()
{
set_specific();
return single_value->field_redirecting;
}

const MNCC__number_template& MNCC__PDU__Signal_template::redirecting() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field redirecting of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_redirecting;
}

MNCC__number_template& MNCC__PDU__Signal_template::connected()
{
set_specific();
return single_value->field_connected;
}

const MNCC__number_template& MNCC__PDU__Signal_template::connected() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connected of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_connected;
}

MNCC__cause_template& MNCC__PDU__Signal_template::cause()
{
set_specific();
return single_value->field_cause;
}

const MNCC__cause_template& MNCC__PDU__Signal_template::cause() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cause of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_cause;
}

MNCC__progress_template& MNCC__PDU__Signal_template::progress()
{
set_specific();
return single_value->field_progress;
}

const MNCC__progress_template& MNCC__PDU__Signal_template::progress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field progress of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_progress;
}

MNCC__useruser_template& MNCC__PDU__Signal_template::useruser()
{
set_specific();
return single_value->field_useruser;
}

const MNCC__useruser_template& MNCC__PDU__Signal_template::useruser() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field useruser of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_useruser;
}

CHARSTRING_template& MNCC__PDU__Signal_template::facility()
{
set_specific();
return single_value->field_facility;
}

const CHARSTRING_template& MNCC__PDU__Signal_template::facility() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field facility of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_facility;
}

MNCC__cccap_template& MNCC__PDU__Signal_template::cccap()
{
set_specific();
return single_value->field_cccap;
}

const MNCC__cccap_template& MNCC__PDU__Signal_template::cccap() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cccap of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_cccap;
}

CHARSTRING_template& MNCC__PDU__Signal_template::ssversion()
{
set_specific();
return single_value->field_ssversion;
}

const CHARSTRING_template& MNCC__PDU__Signal_template::ssversion() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssversion of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_ssversion;
}

INTEGER_template& MNCC__PDU__Signal_template::clir__sup()
{
set_specific();
return single_value->field_clir__sup;
}

const INTEGER_template& MNCC__PDU__Signal_template::clir__sup() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clir_sup of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_clir__sup;
}

INTEGER_template& MNCC__PDU__Signal_template::clir__inv()
{
set_specific();
return single_value->field_clir__inv;
}

const INTEGER_template& MNCC__PDU__Signal_template::clir__inv() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clir_inv of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_clir__inv;
}

INTEGER_template& MNCC__PDU__Signal_template::signal()
{
set_specific();
return single_value->field_signal;
}

const INTEGER_template& MNCC__PDU__Signal_template::signal() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signal of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_signal;
}

CHARSTRING_template& MNCC__PDU__Signal_template::keypad()
{
set_specific();
return single_value->field_keypad;
}

const CHARSTRING_template& MNCC__PDU__Signal_template::keypad() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field keypad of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_keypad;
}

INTEGER_template& MNCC__PDU__Signal_template::more()
{
set_specific();
return single_value->field_more;
}

const INTEGER_template& MNCC__PDU__Signal_template::more() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field more of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_more;
}

INTEGER_template& MNCC__PDU__Signal_template::notify()
{
set_specific();
return single_value->field_notify;
}

const INTEGER_template& MNCC__PDU__Signal_template::notify() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field notify of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_notify;
}

INTEGER_template& MNCC__PDU__Signal_template::emergency()
{
set_specific();
return single_value->field_emergency;
}

const INTEGER_template& MNCC__PDU__Signal_template::emergency() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergency of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_emergency;
}

CHARSTRING_template& MNCC__PDU__Signal_template::imsi()
{
set_specific();
return single_value->field_imsi;
}

const CHARSTRING_template& MNCC__PDU__Signal_template::imsi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field imsi of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_imsi;
}

INTEGER_template& MNCC__PDU__Signal_template::lchan__type()
{
set_specific();
return single_value->field_lchan__type;
}

const INTEGER_template& MNCC__PDU__Signal_template::lchan__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lchan_type of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_lchan__type;
}

INTEGER_template& MNCC__PDU__Signal_template::lchan__mode()
{
set_specific();
return single_value->field_lchan__mode;
}

const INTEGER_template& MNCC__PDU__Signal_template::lchan__mode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lchan_mode of a non-specific template of type @MNCC_Types.MNCC_PDU_Signal.");
return single_value->field_lchan__mode;
}

int MNCC__PDU__Signal_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 8;
      if (single_value->field_bearer__cap.is_present()) ret_val++;
      if (single_value->field_called.is_present()) ret_val++;
      if (single_value->field_calling.is_present()) ret_val++;
      if (single_value->field_redirecting.is_present()) ret_val++;
      if (single_value->field_connected.is_present()) ret_val++;
      if (single_value->field_cause.is_present()) ret_val++;
      if (single_value->field_progress.is_present()) ret_val++;
      if (single_value->field_useruser.is_present()) ret_val++;
      if (single_value->field_facility.is_present()) ret_val++;
      if (single_value->field_cccap.is_present()) ret_val++;
      if (single_value->field_ssversion.is_present()) ret_val++;
      if (single_value->field_signal.is_present()) ret_val++;
      if (single_value->field_keypad.is_present()) ret_val++;
      if (single_value->field_emergency.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Signal containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Signal.");
  }
  return 0;
}

void MNCC__PDU__Signal_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log();
TTCN_Logger::log_event_str(", bearer_cap := ");
single_value->field_bearer__cap.log();
TTCN_Logger::log_event_str(", called := ");
single_value->field_called.log();
TTCN_Logger::log_event_str(", calling := ");
single_value->field_calling.log();
TTCN_Logger::log_event_str(", redirecting := ");
single_value->field_redirecting.log();
TTCN_Logger::log_event_str(", connected := ");
single_value->field_connected.log();
TTCN_Logger::log_event_str(", cause := ");
single_value->field_cause.log();
TTCN_Logger::log_event_str(", progress := ");
single_value->field_progress.log();
TTCN_Logger::log_event_str(", useruser := ");
single_value->field_useruser.log();
TTCN_Logger::log_event_str(", facility := ");
single_value->field_facility.log();
TTCN_Logger::log_event_str(", cccap := ");
single_value->field_cccap.log();
TTCN_Logger::log_event_str(", ssversion := ");
single_value->field_ssversion.log();
TTCN_Logger::log_event_str(", clir_sup := ");
single_value->field_clir__sup.log();
TTCN_Logger::log_event_str(", clir_inv := ");
single_value->field_clir__inv.log();
TTCN_Logger::log_event_str(", signal := ");
single_value->field_signal.log();
TTCN_Logger::log_event_str(", keypad := ");
single_value->field_keypad.log();
TTCN_Logger::log_event_str(", more := ");
single_value->field_more.log();
TTCN_Logger::log_event_str(", notify := ");
single_value->field_notify.log();
TTCN_Logger::log_event_str(", emergency := ");
single_value->field_emergency.log();
TTCN_Logger::log_event_str(", imsi := ");
single_value->field_imsi.log();
TTCN_Logger::log_event_str(", lchan_type := ");
single_value->field_lchan__type.log();
TTCN_Logger::log_event_str(", lchan_mode := ");
single_value->field_lchan__mode.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__PDU__Signal_template::log_match(const MNCC__PDU__Signal& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_callref.match(match_value.callref(), legacy)){
TTCN_Logger::log_logmatch_info(".callref");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.bearer__cap().ispresent()){
if(!single_value->field_bearer__cap.match(match_value.bearer__cap(), legacy)){
TTCN_Logger::log_logmatch_info(".bearer_cap");
single_value->field_bearer__cap.log_match(match_value.bearer__cap(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_bearer__cap.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".bearer_cap := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_bearer__cap.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.called().ispresent()){
if(!single_value->field_called.match(match_value.called(), legacy)){
TTCN_Logger::log_logmatch_info(".called");
single_value->field_called.log_match(match_value.called(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_called.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".called := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_called.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.calling().ispresent()){
if(!single_value->field_calling.match(match_value.calling(), legacy)){
TTCN_Logger::log_logmatch_info(".calling");
single_value->field_calling.log_match(match_value.calling(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_calling.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".calling := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_calling.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.redirecting().ispresent()){
if(!single_value->field_redirecting.match(match_value.redirecting(), legacy)){
TTCN_Logger::log_logmatch_info(".redirecting");
single_value->field_redirecting.log_match(match_value.redirecting(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_redirecting.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".redirecting := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_redirecting.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.connected().ispresent()){
if(!single_value->field_connected.match(match_value.connected(), legacy)){
TTCN_Logger::log_logmatch_info(".connected");
single_value->field_connected.log_match(match_value.connected(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_connected.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".connected := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_connected.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.cause().ispresent()){
if(!single_value->field_cause.match(match_value.cause(), legacy)){
TTCN_Logger::log_logmatch_info(".cause");
single_value->field_cause.log_match(match_value.cause(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_cause.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".cause := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_cause.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.progress().ispresent()){
if(!single_value->field_progress.match(match_value.progress(), legacy)){
TTCN_Logger::log_logmatch_info(".progress");
single_value->field_progress.log_match(match_value.progress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_progress.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".progress := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_progress.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.useruser().ispresent()){
if(!single_value->field_useruser.match(match_value.useruser(), legacy)){
TTCN_Logger::log_logmatch_info(".useruser");
single_value->field_useruser.log_match(match_value.useruser(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_useruser.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".useruser := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_useruser.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.facility().ispresent()){
if(!single_value->field_facility.match(match_value.facility(), legacy)){
TTCN_Logger::log_logmatch_info(".facility");
single_value->field_facility.log_match(match_value.facility(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_facility.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".facility := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_facility.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.cccap().ispresent()){
if(!single_value->field_cccap.match(match_value.cccap(), legacy)){
TTCN_Logger::log_logmatch_info(".cccap");
single_value->field_cccap.log_match(match_value.cccap(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_cccap.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".cccap := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_cccap.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ssversion().ispresent()){
if(!single_value->field_ssversion.match(match_value.ssversion(), legacy)){
TTCN_Logger::log_logmatch_info(".ssversion");
single_value->field_ssversion.log_match(match_value.ssversion(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssversion.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssversion := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssversion.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_clir__sup.match(match_value.clir__sup(), legacy)){
TTCN_Logger::log_logmatch_info(".clir_sup");
single_value->field_clir__sup.log_match(match_value.clir__sup(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_clir__inv.match(match_value.clir__inv(), legacy)){
TTCN_Logger::log_logmatch_info(".clir_inv");
single_value->field_clir__inv.log_match(match_value.clir__inv(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.signal().ispresent()){
if(!single_value->field_signal.match(match_value.signal(), legacy)){
TTCN_Logger::log_logmatch_info(".signal");
single_value->field_signal.log_match(match_value.signal(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_signal.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".signal := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_signal.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.keypad().ispresent()){
if(!single_value->field_keypad.match(match_value.keypad(), legacy)){
TTCN_Logger::log_logmatch_info(".keypad");
single_value->field_keypad.log_match(match_value.keypad(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_keypad.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".keypad := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_keypad.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_more.match(match_value.more(), legacy)){
TTCN_Logger::log_logmatch_info(".more");
single_value->field_more.log_match(match_value.more(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_notify.match(match_value.notify(), legacy)){
TTCN_Logger::log_logmatch_info(".notify");
single_value->field_notify.log_match(match_value.notify(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.emergency().ispresent()){
if(!single_value->field_emergency.match(match_value.emergency(), legacy)){
TTCN_Logger::log_logmatch_info(".emergency");
single_value->field_emergency.log_match(match_value.emergency(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_emergency.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".emergency := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_emergency.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_imsi.match(match_value.imsi(), legacy)){
TTCN_Logger::log_logmatch_info(".imsi");
single_value->field_imsi.log_match(match_value.imsi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lchan__type.match(match_value.lchan__type(), legacy)){
TTCN_Logger::log_logmatch_info(".lchan_type");
single_value->field_lchan__type.log_match(match_value.lchan__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lchan__mode.match(match_value.lchan__mode(), legacy)){
TTCN_Logger::log_logmatch_info(".lchan_mode");
single_value->field_lchan__mode.log_match(match_value.lchan__mode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::log_event_str(", bearer_cap := ");
if (match_value.bearer__cap().ispresent()) single_value->field_bearer__cap.log_match(match_value.bearer__cap(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_bearer__cap.log();
if (single_value->field_bearer__cap.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", called := ");
if (match_value.called().ispresent()) single_value->field_called.log_match(match_value.called(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_called.log();
if (single_value->field_called.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", calling := ");
if (match_value.calling().ispresent()) single_value->field_calling.log_match(match_value.calling(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_calling.log();
if (single_value->field_calling.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", redirecting := ");
if (match_value.redirecting().ispresent()) single_value->field_redirecting.log_match(match_value.redirecting(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_redirecting.log();
if (single_value->field_redirecting.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", connected := ");
if (match_value.connected().ispresent()) single_value->field_connected.log_match(match_value.connected(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_connected.log();
if (single_value->field_connected.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", cause := ");
if (match_value.cause().ispresent()) single_value->field_cause.log_match(match_value.cause(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_cause.log();
if (single_value->field_cause.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", progress := ");
if (match_value.progress().ispresent()) single_value->field_progress.log_match(match_value.progress(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_progress.log();
if (single_value->field_progress.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", useruser := ");
if (match_value.useruser().ispresent()) single_value->field_useruser.log_match(match_value.useruser(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_useruser.log();
if (single_value->field_useruser.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", facility := ");
if (match_value.facility().ispresent()) single_value->field_facility.log_match(match_value.facility(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_facility.log();
if (single_value->field_facility.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", cccap := ");
if (match_value.cccap().ispresent()) single_value->field_cccap.log_match(match_value.cccap(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_cccap.log();
if (single_value->field_cccap.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ssversion := ");
if (match_value.ssversion().ispresent()) single_value->field_ssversion.log_match(match_value.ssversion(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssversion.log();
if (single_value->field_ssversion.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", clir_sup := ");
single_value->field_clir__sup.log_match(match_value.clir__sup(), legacy);
TTCN_Logger::log_event_str(", clir_inv := ");
single_value->field_clir__inv.log_match(match_value.clir__inv(), legacy);
TTCN_Logger::log_event_str(", signal := ");
if (match_value.signal().ispresent()) single_value->field_signal.log_match(match_value.signal(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_signal.log();
if (single_value->field_signal.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", keypad := ");
if (match_value.keypad().ispresent()) single_value->field_keypad.log_match(match_value.keypad(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_keypad.log();
if (single_value->field_keypad.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", more := ");
single_value->field_more.log_match(match_value.more(), legacy);
TTCN_Logger::log_event_str(", notify := ");
single_value->field_notify.log_match(match_value.notify(), legacy);
TTCN_Logger::log_event_str(", emergency := ");
if (match_value.emergency().ispresent()) single_value->field_emergency.log_match(match_value.emergency(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_emergency.log();
if (single_value->field_emergency.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", imsi := ");
single_value->field_imsi.log_match(match_value.imsi(), legacy);
TTCN_Logger::log_event_str(", lchan_type := ");
single_value->field_lchan__type.log_match(match_value.lchan__type(), legacy);
TTCN_Logger::log_event_str(", lchan_mode := ");
single_value->field_lchan__mode.log_match(match_value.lchan__mode(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__PDU__Signal_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_callref.encode_text(text_buf);
single_value->field_bearer__cap.encode_text(text_buf);
single_value->field_called.encode_text(text_buf);
single_value->field_calling.encode_text(text_buf);
single_value->field_redirecting.encode_text(text_buf);
single_value->field_connected.encode_text(text_buf);
single_value->field_cause.encode_text(text_buf);
single_value->field_progress.encode_text(text_buf);
single_value->field_useruser.encode_text(text_buf);
single_value->field_facility.encode_text(text_buf);
single_value->field_cccap.encode_text(text_buf);
single_value->field_ssversion.encode_text(text_buf);
single_value->field_clir__sup.encode_text(text_buf);
single_value->field_clir__inv.encode_text(text_buf);
single_value->field_signal.encode_text(text_buf);
single_value->field_keypad.encode_text(text_buf);
single_value->field_more.encode_text(text_buf);
single_value->field_notify.encode_text(text_buf);
single_value->field_emergency.encode_text(text_buf);
single_value->field_imsi.encode_text(text_buf);
single_value->field_lchan__type.encode_text(text_buf);
single_value->field_lchan__mode.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Signal.");
}
}

void MNCC__PDU__Signal_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_callref.decode_text(text_buf);
single_value->field_bearer__cap.decode_text(text_buf);
single_value->field_called.decode_text(text_buf);
single_value->field_calling.decode_text(text_buf);
single_value->field_redirecting.decode_text(text_buf);
single_value->field_connected.decode_text(text_buf);
single_value->field_cause.decode_text(text_buf);
single_value->field_progress.decode_text(text_buf);
single_value->field_useruser.decode_text(text_buf);
single_value->field_facility.decode_text(text_buf);
single_value->field_cccap.decode_text(text_buf);
single_value->field_ssversion.decode_text(text_buf);
single_value->field_clir__sup.decode_text(text_buf);
single_value->field_clir__inv.decode_text(text_buf);
single_value->field_signal.decode_text(text_buf);
single_value->field_keypad.decode_text(text_buf);
single_value->field_more.decode_text(text_buf);
single_value->field_notify.decode_text(text_buf);
single_value->field_emergency.decode_text(text_buf);
single_value->field_imsi.decode_text(text_buf);
single_value->field_lchan__type.decode_text(text_buf);
single_value->field_lchan__mode.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__PDU__Signal_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_PDU_Signal.");
}
}

void MNCC__PDU__Signal_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__PDU__Signal_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (22<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_PDU_Signal has 22 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) bearer__cap().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) called().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) calling().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) redirecting().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) connected().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) cause().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) progress().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) useruser().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) facility().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) cccap().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) ssversion().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) clir__sup().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) clir__inv().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) signal().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) keypad().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) more().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) notify().set_param(*param.get_elem(17));
    if (param.get_size()>18 && param.get_elem(18)->get_type()!=Module_Param::MP_NotUsed) emergency().set_param(*param.get_elem(18));
    if (param.get_size()>19 && param.get_elem(19)->get_type()!=Module_Param::MP_NotUsed) imsi().set_param(*param.get_elem(19));
    if (param.get_size()>20 && param.get_elem(20)->get_type()!=Module_Param::MP_NotUsed) lchan__type().set_param(*param.get_elem(20));
    if (param.get_size()>21 && param.get_elem(21)->get_type()!=Module_Param::MP_NotUsed) lchan__mode().set_param(*param.get_elem(21));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bearer_cap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bearer__cap().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "called")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          called().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "calling")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          calling().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "redirecting")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          redirecting().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connected")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connected().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cause().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "progress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          progress().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "useruser")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          useruser().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "facility")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          facility().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cccap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cccap().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssversion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssversion().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clir_sup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clir__sup().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clir_inv")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clir__inv().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "keypad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          keypad().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "more")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          more().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "notify")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          notify().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "imsi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          imsi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_mode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__mode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Signal: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_PDU_Signal");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__PDU__Signal_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_callref.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_bearer__cap.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_called.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_calling.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_redirecting.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_connected.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_cause.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_progress.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_useruser.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_facility.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_cccap.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_ssversion.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_clir__sup.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_clir__inv.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_signal.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_keypad.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_more.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_notify.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_emergency.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_imsi.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_lchan__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
single_value->field_lchan__mode.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_PDU_Signal");
}

boolean MNCC__PDU__Signal_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__PDU__Signal_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__PDU__Data::MNCC__PDU__Data()
{
}

MNCC__PDU__Data::MNCC__PDU__Data(const INTEGER& par_callref,
    const OCTETSTRING& par_data)
  :   field_callref(par_callref),
  field_data(par_data)
{
}

MNCC__PDU__Data::MNCC__PDU__Data(const MNCC__PDU__Data& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_PDU_Data.");
if (other_value.callref().is_bound()) field_callref = other_value.callref();
else field_callref.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void MNCC__PDU__Data::clean_up()
{
field_callref.clean_up();
field_data.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__PDU__Data::get_descriptor() const { return &MNCC__PDU__Data_descr_; }
MNCC__PDU__Data& MNCC__PDU__Data::operator=(const MNCC__PDU__Data& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_PDU_Data.");
  if (other_value.callref().is_bound()) field_callref = other_value.callref();
  else field_callref.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean MNCC__PDU__Data::operator==(const MNCC__PDU__Data& other_value) const
{
return field_callref==other_value.field_callref
  && field_data==other_value.field_data;
}

boolean MNCC__PDU__Data::is_bound() const
{
if(field_callref.is_bound()) return TRUE;
if(field_data.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__PDU__Data::is_value() const
{
if(!field_callref.is_value()) return FALSE;
if(!field_data.is_value()) return FALSE;
return TRUE;
}
void MNCC__PDU__Data::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ callref := ");
field_callref.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__PDU__Data::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_PDU_Data has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_PDU_Data");
  }
}

void MNCC__PDU__Data::set_implicit_omit()
{
if (callref().is_bound()) callref().set_implicit_omit();
if (data().is_bound()) data().set_implicit_omit();
}

void MNCC__PDU__Data::encode_text(Text_Buf& text_buf) const
{
field_callref.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void MNCC__PDU__Data::decode_text(Text_Buf& text_buf)
{
field_callref.decode_text(text_buf);
field_data.decode_text(text_buf);
}

void MNCC__PDU__Data::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__PDU__Data::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__PDU__Data::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__PDU__Data_callref_descr_.raw->forceomit);
  decoded_field_length = field_callref.RAW_decode(MNCC__PDU__Data_callref_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__PDU__Data_data_descr_.raw->forceomit);
  decoded_field_length = field_data.RAW_decode(MNCC__PDU__Data_data_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__PDU__Data::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__PDU__Data_callref_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__PDU__Data_data_descr_.raw);
  encoded_length += field_callref.RAW_encode(MNCC__PDU__Data_callref_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_data.RAW_encode(MNCC__PDU__Data_data_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

struct MNCC__PDU__Data_template::single_value_struct {
INTEGER_template field_callref;
OCTETSTRING_template field_data;
};

void MNCC__PDU__Data_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_callref = ANY_VALUE;
single_value->field_data = ANY_VALUE;
}
}
}

void MNCC__PDU__Data_template::copy_value(const MNCC__PDU__Data& other_value)
{
single_value = new single_value_struct;
if (other_value.callref().is_bound()) {
  single_value->field_callref = other_value.callref();
} else {
  single_value->field_callref.clean_up();
}
if (other_value.data().is_bound()) {
  single_value->field_data = other_value.data();
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__PDU__Data_template::copy_template(const MNCC__PDU__Data_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.callref().get_selection()) {
single_value->field_callref = other_value.callref();
} else {
single_value->field_callref.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__PDU__Data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Data.");
break;
}
set_selection(other_value);
}

MNCC__PDU__Data_template::MNCC__PDU__Data_template()
{
}

MNCC__PDU__Data_template::MNCC__PDU__Data_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__PDU__Data_template::MNCC__PDU__Data_template(const MNCC__PDU__Data& other_value)
{
copy_value(other_value);
}

MNCC__PDU__Data_template::MNCC__PDU__Data_template(const OPTIONAL<MNCC__PDU__Data>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_PDU_Data from an unbound optional field.");
}
}

MNCC__PDU__Data_template::MNCC__PDU__Data_template(const MNCC__PDU__Data_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__PDU__Data_template::~MNCC__PDU__Data_template()
{
clean_up();
}

MNCC__PDU__Data_template& MNCC__PDU__Data_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__PDU__Data_template& MNCC__PDU__Data_template::operator=(const MNCC__PDU__Data& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__PDU__Data_template& MNCC__PDU__Data_template::operator=(const OPTIONAL<MNCC__PDU__Data>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_PDU_Data.");
}
return *this;
}

MNCC__PDU__Data_template& MNCC__PDU__Data_template::operator=(const MNCC__PDU__Data_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__PDU__Data_template::match(const MNCC__PDU__Data& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.callref().is_bound()) return FALSE;
if(!single_value->field_callref.match(other_value.callref(), legacy))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if(!single_value->field_data.match(other_value.data(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Data.");
}
return FALSE;
}

boolean MNCC__PDU__Data_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_callref.is_bound()) return TRUE;
if (single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__PDU__Data_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_callref.is_value()) return FALSE;
if (!single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void MNCC__PDU__Data_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__PDU__Data MNCC__PDU__Data_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_PDU_Data.");
MNCC__PDU__Data ret_val;
if (single_value->field_callref.is_bound()) {
ret_val.callref() = single_value->field_callref.valueof();
}
if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void MNCC__PDU__Data_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_PDU_Data.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__PDU__Data_template[list_length];
}

MNCC__PDU__Data_template& MNCC__PDU__Data_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_PDU_Data.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_PDU_Data.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__PDU__Data_template::callref()
{
set_specific();
return single_value->field_callref;
}

const INTEGER_template& MNCC__PDU__Data_template::callref() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field callref of a non-specific template of type @MNCC_Types.MNCC_PDU_Data.");
return single_value->field_callref;
}

OCTETSTRING_template& MNCC__PDU__Data_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& MNCC__PDU__Data_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @MNCC_Types.MNCC_PDU_Data.");
return single_value->field_data;
}

int MNCC__PDU__Data_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Data containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Data.");
  }
  return 0;
}

void MNCC__PDU__Data_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__PDU__Data_template::log_match(const MNCC__PDU__Data& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_callref.match(match_value.callref(), legacy)){
TTCN_Logger::log_logmatch_info(".callref");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_data.match(match_value.data(), legacy)){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__PDU__Data_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_callref.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Data.");
}
}

void MNCC__PDU__Data_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_callref.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__PDU__Data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_PDU_Data.");
}
}

void MNCC__PDU__Data_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__PDU__Data_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_PDU_Data has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_PDU_Data");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__PDU__Data_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_callref.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Data");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Data");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_PDU_Data");
}

boolean MNCC__PDU__Data_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__PDU__Data_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__PDU__Rtp::MNCC__PDU__Rtp()
{
}

MNCC__PDU__Rtp::MNCC__PDU__Rtp(const INTEGER& par_callref,
    const INTEGER& par_ip,
    const INTEGER& par_rtp__port,
    const INTEGER& par_payload__type,
    const INTEGER& par_payload__msg__type)
  :   field_callref(par_callref),
  field_ip(par_ip),
  field_rtp__port(par_rtp__port),
  field_payload__type(par_payload__type),
  field_payload__msg__type(par_payload__msg__type)
{
}

MNCC__PDU__Rtp::MNCC__PDU__Rtp(const MNCC__PDU__Rtp& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_PDU_Rtp.");
if (other_value.callref().is_bound()) field_callref = other_value.callref();
else field_callref.clean_up();
if (other_value.ip().is_bound()) field_ip = other_value.ip();
else field_ip.clean_up();
if (other_value.rtp__port().is_bound()) field_rtp__port = other_value.rtp__port();
else field_rtp__port.clean_up();
if (other_value.payload__type().is_bound()) field_payload__type = other_value.payload__type();
else field_payload__type.clean_up();
if (other_value.payload__msg__type().is_bound()) field_payload__msg__type = other_value.payload__msg__type();
else field_payload__msg__type.clean_up();
}

void MNCC__PDU__Rtp::clean_up()
{
field_callref.clean_up();
field_ip.clean_up();
field_rtp__port.clean_up();
field_payload__type.clean_up();
field_payload__msg__type.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__PDU__Rtp::get_descriptor() const { return &MNCC__PDU__Rtp_descr_; }
MNCC__PDU__Rtp& MNCC__PDU__Rtp::operator=(const MNCC__PDU__Rtp& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_PDU_Rtp.");
  if (other_value.callref().is_bound()) field_callref = other_value.callref();
  else field_callref.clean_up();
  if (other_value.ip().is_bound()) field_ip = other_value.ip();
  else field_ip.clean_up();
  if (other_value.rtp__port().is_bound()) field_rtp__port = other_value.rtp__port();
  else field_rtp__port.clean_up();
  if (other_value.payload__type().is_bound()) field_payload__type = other_value.payload__type();
  else field_payload__type.clean_up();
  if (other_value.payload__msg__type().is_bound()) field_payload__msg__type = other_value.payload__msg__type();
  else field_payload__msg__type.clean_up();
}
return *this;
}

boolean MNCC__PDU__Rtp::operator==(const MNCC__PDU__Rtp& other_value) const
{
return field_callref==other_value.field_callref
  && field_ip==other_value.field_ip
  && field_rtp__port==other_value.field_rtp__port
  && field_payload__type==other_value.field_payload__type
  && field_payload__msg__type==other_value.field_payload__msg__type;
}

boolean MNCC__PDU__Rtp::is_bound() const
{
if(field_callref.is_bound()) return TRUE;
if(field_ip.is_bound()) return TRUE;
if(field_rtp__port.is_bound()) return TRUE;
if(field_payload__type.is_bound()) return TRUE;
if(field_payload__msg__type.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__PDU__Rtp::is_value() const
{
if(!field_callref.is_value()) return FALSE;
if(!field_ip.is_value()) return FALSE;
if(!field_rtp__port.is_value()) return FALSE;
if(!field_payload__type.is_value()) return FALSE;
if(!field_payload__msg__type.is_value()) return FALSE;
return TRUE;
}
void MNCC__PDU__Rtp::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ callref := ");
field_callref.log();
TTCN_Logger::log_event_str(", ip := ");
field_ip.log();
TTCN_Logger::log_event_str(", rtp_port := ");
field_rtp__port.log();
TTCN_Logger::log_event_str(", payload_type := ");
field_payload__type.log();
TTCN_Logger::log_event_str(", payload_msg_type := ");
field_payload__msg__type.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__PDU__Rtp::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_PDU_Rtp has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ip().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rtp__port().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload__type().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) payload__msg__type().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ip")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ip().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtp_port")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtp__port().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Rtp: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_PDU_Rtp");
  }
}

void MNCC__PDU__Rtp::set_implicit_omit()
{
if (callref().is_bound()) callref().set_implicit_omit();
if (ip().is_bound()) ip().set_implicit_omit();
if (rtp__port().is_bound()) rtp__port().set_implicit_omit();
if (payload__type().is_bound()) payload__type().set_implicit_omit();
if (payload__msg__type().is_bound()) payload__msg__type().set_implicit_omit();
}

void MNCC__PDU__Rtp::encode_text(Text_Buf& text_buf) const
{
field_callref.encode_text(text_buf);
field_ip.encode_text(text_buf);
field_rtp__port.encode_text(text_buf);
field_payload__type.encode_text(text_buf);
field_payload__msg__type.encode_text(text_buf);
}

void MNCC__PDU__Rtp::decode_text(Text_Buf& text_buf)
{
field_callref.decode_text(text_buf);
field_ip.decode_text(text_buf);
field_rtp__port.decode_text(text_buf);
field_payload__type.decode_text(text_buf);
field_payload__msg__type.decode_text(text_buf);
}

void MNCC__PDU__Rtp::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__PDU__Rtp::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__PDU__Rtp::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__PDU__Rtp_callref_descr_.raw->forceomit);
  decoded_field_length = field_callref.RAW_decode(MNCC__PDU__Rtp_callref_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__PDU__Rtp_ip_descr_.raw->forceomit);
  decoded_field_length = field_ip.RAW_decode(MNCC__PDU__Rtp_ip_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__PDU__Rtp_rtp__port_descr_.raw->forceomit);
  decoded_field_length = field_rtp__port.RAW_decode(MNCC__PDU__Rtp_rtp__port_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__PDU__Rtp_payload__type_descr_.raw->forceomit);
  decoded_field_length = field_payload__type.RAW_decode(MNCC__PDU__Rtp_payload__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__PDU__Rtp_payload__msg__type_descr_.raw->forceomit);
  decoded_field_length = field_payload__msg__type.RAW_decode(MNCC__PDU__Rtp_payload__msg__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__PDU__Rtp::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__PDU__Rtp_callref_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__PDU__Rtp_ip_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__PDU__Rtp_rtp__port_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__PDU__Rtp_payload__type_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__PDU__Rtp_payload__msg__type_descr_.raw);
  encoded_length += field_callref.RAW_encode(MNCC__PDU__Rtp_callref_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_ip.RAW_encode(MNCC__PDU__Rtp_ip_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_rtp__port.RAW_encode(MNCC__PDU__Rtp_rtp__port_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_payload__type.RAW_encode(MNCC__PDU__Rtp_payload__type_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_payload__msg__type.RAW_encode(MNCC__PDU__Rtp_payload__msg__type_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

struct MNCC__PDU__Rtp_template::single_value_struct {
INTEGER_template field_callref;
INTEGER_template field_ip;
INTEGER_template field_rtp__port;
INTEGER_template field_payload__type;
INTEGER_template field_payload__msg__type;
};

void MNCC__PDU__Rtp_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_callref = ANY_VALUE;
single_value->field_ip = ANY_VALUE;
single_value->field_rtp__port = ANY_VALUE;
single_value->field_payload__type = ANY_VALUE;
single_value->field_payload__msg__type = ANY_VALUE;
}
}
}

void MNCC__PDU__Rtp_template::copy_value(const MNCC__PDU__Rtp& other_value)
{
single_value = new single_value_struct;
if (other_value.callref().is_bound()) {
  single_value->field_callref = other_value.callref();
} else {
  single_value->field_callref.clean_up();
}
if (other_value.ip().is_bound()) {
  single_value->field_ip = other_value.ip();
} else {
  single_value->field_ip.clean_up();
}
if (other_value.rtp__port().is_bound()) {
  single_value->field_rtp__port = other_value.rtp__port();
} else {
  single_value->field_rtp__port.clean_up();
}
if (other_value.payload__type().is_bound()) {
  single_value->field_payload__type = other_value.payload__type();
} else {
  single_value->field_payload__type.clean_up();
}
if (other_value.payload__msg__type().is_bound()) {
  single_value->field_payload__msg__type = other_value.payload__msg__type();
} else {
  single_value->field_payload__msg__type.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__PDU__Rtp_template::copy_template(const MNCC__PDU__Rtp_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.callref().get_selection()) {
single_value->field_callref = other_value.callref();
} else {
single_value->field_callref.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ip().get_selection()) {
single_value->field_ip = other_value.ip();
} else {
single_value->field_ip.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rtp__port().get_selection()) {
single_value->field_rtp__port = other_value.rtp__port();
} else {
single_value->field_rtp__port.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__type().get_selection()) {
single_value->field_payload__type = other_value.payload__type();
} else {
single_value->field_payload__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__msg__type().get_selection()) {
single_value->field_payload__msg__type = other_value.payload__msg__type();
} else {
single_value->field_payload__msg__type.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__PDU__Rtp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Rtp.");
break;
}
set_selection(other_value);
}

MNCC__PDU__Rtp_template::MNCC__PDU__Rtp_template()
{
}

MNCC__PDU__Rtp_template::MNCC__PDU__Rtp_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__PDU__Rtp_template::MNCC__PDU__Rtp_template(const MNCC__PDU__Rtp& other_value)
{
copy_value(other_value);
}

MNCC__PDU__Rtp_template::MNCC__PDU__Rtp_template(const OPTIONAL<MNCC__PDU__Rtp>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Rtp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_PDU_Rtp from an unbound optional field.");
}
}

MNCC__PDU__Rtp_template::MNCC__PDU__Rtp_template(const MNCC__PDU__Rtp_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__PDU__Rtp_template::~MNCC__PDU__Rtp_template()
{
clean_up();
}

MNCC__PDU__Rtp_template& MNCC__PDU__Rtp_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__PDU__Rtp_template& MNCC__PDU__Rtp_template::operator=(const MNCC__PDU__Rtp& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__PDU__Rtp_template& MNCC__PDU__Rtp_template::operator=(const OPTIONAL<MNCC__PDU__Rtp>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Rtp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_PDU_Rtp.");
}
return *this;
}

MNCC__PDU__Rtp_template& MNCC__PDU__Rtp_template::operator=(const MNCC__PDU__Rtp_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__PDU__Rtp_template::match(const MNCC__PDU__Rtp& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.callref().is_bound()) return FALSE;
if(!single_value->field_callref.match(other_value.callref(), legacy))return FALSE;
if(!other_value.ip().is_bound()) return FALSE;
if(!single_value->field_ip.match(other_value.ip(), legacy))return FALSE;
if(!other_value.rtp__port().is_bound()) return FALSE;
if(!single_value->field_rtp__port.match(other_value.rtp__port(), legacy))return FALSE;
if(!other_value.payload__type().is_bound()) return FALSE;
if(!single_value->field_payload__type.match(other_value.payload__type(), legacy))return FALSE;
if(!other_value.payload__msg__type().is_bound()) return FALSE;
if(!single_value->field_payload__msg__type.match(other_value.payload__msg__type(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Rtp.");
}
return FALSE;
}

boolean MNCC__PDU__Rtp_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_callref.is_bound()) return TRUE;
if (single_value->field_ip.is_bound()) return TRUE;
if (single_value->field_rtp__port.is_bound()) return TRUE;
if (single_value->field_payload__type.is_bound()) return TRUE;
if (single_value->field_payload__msg__type.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__PDU__Rtp_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_callref.is_value()) return FALSE;
if (!single_value->field_ip.is_value()) return FALSE;
if (!single_value->field_rtp__port.is_value()) return FALSE;
if (!single_value->field_payload__type.is_value()) return FALSE;
if (!single_value->field_payload__msg__type.is_value()) return FALSE;
return TRUE;
}

void MNCC__PDU__Rtp_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__PDU__Rtp MNCC__PDU__Rtp_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
MNCC__PDU__Rtp ret_val;
if (single_value->field_callref.is_bound()) {
ret_val.callref() = single_value->field_callref.valueof();
}
if (single_value->field_ip.is_bound()) {
ret_val.ip() = single_value->field_ip.valueof();
}
if (single_value->field_rtp__port.is_bound()) {
ret_val.rtp__port() = single_value->field_rtp__port.valueof();
}
if (single_value->field_payload__type.is_bound()) {
ret_val.payload__type() = single_value->field_payload__type.valueof();
}
if (single_value->field_payload__msg__type.is_bound()) {
ret_val.payload__msg__type() = single_value->field_payload__msg__type.valueof();
}
return ret_val;
}

void MNCC__PDU__Rtp_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_PDU_Rtp.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__PDU__Rtp_template[list_length];
}

MNCC__PDU__Rtp_template& MNCC__PDU__Rtp_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_PDU_Rtp.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_PDU_Rtp.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__PDU__Rtp_template::callref()
{
set_specific();
return single_value->field_callref;
}

const INTEGER_template& MNCC__PDU__Rtp_template::callref() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field callref of a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
return single_value->field_callref;
}

INTEGER_template& MNCC__PDU__Rtp_template::ip()
{
set_specific();
return single_value->field_ip;
}

const INTEGER_template& MNCC__PDU__Rtp_template::ip() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ip of a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
return single_value->field_ip;
}

INTEGER_template& MNCC__PDU__Rtp_template::rtp__port()
{
set_specific();
return single_value->field_rtp__port;
}

const INTEGER_template& MNCC__PDU__Rtp_template::rtp__port() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rtp_port of a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
return single_value->field_rtp__port;
}

INTEGER_template& MNCC__PDU__Rtp_template::payload__type()
{
set_specific();
return single_value->field_payload__type;
}

const INTEGER_template& MNCC__PDU__Rtp_template::payload__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_type of a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
return single_value->field_payload__type;
}

INTEGER_template& MNCC__PDU__Rtp_template::payload__msg__type()
{
set_specific();
return single_value->field_payload__msg__type;
}

const INTEGER_template& MNCC__PDU__Rtp_template::payload__msg__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_msg_type of a non-specific template of type @MNCC_Types.MNCC_PDU_Rtp.");
return single_value->field_payload__msg__type;
}

int MNCC__PDU__Rtp_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Rtp containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Rtp.");
  }
  return 0;
}

void MNCC__PDU__Rtp_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log();
TTCN_Logger::log_event_str(", ip := ");
single_value->field_ip.log();
TTCN_Logger::log_event_str(", rtp_port := ");
single_value->field_rtp__port.log();
TTCN_Logger::log_event_str(", payload_type := ");
single_value->field_payload__type.log();
TTCN_Logger::log_event_str(", payload_msg_type := ");
single_value->field_payload__msg__type.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__PDU__Rtp_template::log_match(const MNCC__PDU__Rtp& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_callref.match(match_value.callref(), legacy)){
TTCN_Logger::log_logmatch_info(".callref");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ip.match(match_value.ip(), legacy)){
TTCN_Logger::log_logmatch_info(".ip");
single_value->field_ip.log_match(match_value.ip(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rtp__port.match(match_value.rtp__port(), legacy)){
TTCN_Logger::log_logmatch_info(".rtp_port");
single_value->field_rtp__port.log_match(match_value.rtp__port(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__type.match(match_value.payload__type(), legacy)){
TTCN_Logger::log_logmatch_info(".payload_type");
single_value->field_payload__type.log_match(match_value.payload__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__msg__type.match(match_value.payload__msg__type(), legacy)){
TTCN_Logger::log_logmatch_info(".payload_msg_type");
single_value->field_payload__msg__type.log_match(match_value.payload__msg__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ callref := ");
single_value->field_callref.log_match(match_value.callref(), legacy);
TTCN_Logger::log_event_str(", ip := ");
single_value->field_ip.log_match(match_value.ip(), legacy);
TTCN_Logger::log_event_str(", rtp_port := ");
single_value->field_rtp__port.log_match(match_value.rtp__port(), legacy);
TTCN_Logger::log_event_str(", payload_type := ");
single_value->field_payload__type.log_match(match_value.payload__type(), legacy);
TTCN_Logger::log_event_str(", payload_msg_type := ");
single_value->field_payload__msg__type.log_match(match_value.payload__msg__type(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__PDU__Rtp_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_callref.encode_text(text_buf);
single_value->field_ip.encode_text(text_buf);
single_value->field_rtp__port.encode_text(text_buf);
single_value->field_payload__type.encode_text(text_buf);
single_value->field_payload__msg__type.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Rtp.");
}
}

void MNCC__PDU__Rtp_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_callref.decode_text(text_buf);
single_value->field_ip.decode_text(text_buf);
single_value->field_rtp__port.decode_text(text_buf);
single_value->field_payload__type.decode_text(text_buf);
single_value->field_payload__msg__type.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__PDU__Rtp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_PDU_Rtp.");
}
}

void MNCC__PDU__Rtp_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__PDU__Rtp_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_PDU_Rtp has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) callref().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ip().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rtp__port().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload__type().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) payload__msg__type().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "callref")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          callref().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ip")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ip().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtp_port")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtp__port().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Rtp: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_PDU_Rtp");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__PDU__Rtp_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_callref.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
single_value->field_ip.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
single_value->field_rtp__port.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
single_value->field_payload__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
single_value->field_payload__msg__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_PDU_Rtp");
}

boolean MNCC__PDU__Rtp_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__PDU__Rtp_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MNCC__PDU__Hello::MNCC__PDU__Hello()
{
}

MNCC__PDU__Hello::MNCC__PDU__Hello(const INTEGER& par_version,
    const INTEGER& par_mncc__size,
    const INTEGER& par_data__frame__size,
    const INTEGER& par_called__offset,
    const INTEGER& par_signal__offset,
    const INTEGER& par_emergency__offset,
    const INTEGER& par_lchan__type__offset)
  :   field_version(par_version),
  field_mncc__size(par_mncc__size),
  field_data__frame__size(par_data__frame__size),
  field_called__offset(par_called__offset),
  field_signal__offset(par_signal__offset),
  field_emergency__offset(par_emergency__offset),
  field_lchan__type__offset(par_lchan__type__offset)
{
}

MNCC__PDU__Hello::MNCC__PDU__Hello(const MNCC__PDU__Hello& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_PDU_Hello.");
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.mncc__size().is_bound()) field_mncc__size = other_value.mncc__size();
else field_mncc__size.clean_up();
if (other_value.data__frame__size().is_bound()) field_data__frame__size = other_value.data__frame__size();
else field_data__frame__size.clean_up();
if (other_value.called__offset().is_bound()) field_called__offset = other_value.called__offset();
else field_called__offset.clean_up();
if (other_value.signal__offset().is_bound()) field_signal__offset = other_value.signal__offset();
else field_signal__offset.clean_up();
if (other_value.emergency__offset().is_bound()) field_emergency__offset = other_value.emergency__offset();
else field_emergency__offset.clean_up();
if (other_value.lchan__type__offset().is_bound()) field_lchan__type__offset = other_value.lchan__type__offset();
else field_lchan__type__offset.clean_up();
}

void MNCC__PDU__Hello::clean_up()
{
field_version.clean_up();
field_mncc__size.clean_up();
field_data__frame__size.clean_up();
field_called__offset.clean_up();
field_signal__offset.clean_up();
field_emergency__offset.clean_up();
field_lchan__type__offset.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__PDU__Hello::get_descriptor() const { return &MNCC__PDU__Hello_descr_; }
MNCC__PDU__Hello& MNCC__PDU__Hello::operator=(const MNCC__PDU__Hello& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_PDU_Hello.");
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.mncc__size().is_bound()) field_mncc__size = other_value.mncc__size();
  else field_mncc__size.clean_up();
  if (other_value.data__frame__size().is_bound()) field_data__frame__size = other_value.data__frame__size();
  else field_data__frame__size.clean_up();
  if (other_value.called__offset().is_bound()) field_called__offset = other_value.called__offset();
  else field_called__offset.clean_up();
  if (other_value.signal__offset().is_bound()) field_signal__offset = other_value.signal__offset();
  else field_signal__offset.clean_up();
  if (other_value.emergency__offset().is_bound()) field_emergency__offset = other_value.emergency__offset();
  else field_emergency__offset.clean_up();
  if (other_value.lchan__type__offset().is_bound()) field_lchan__type__offset = other_value.lchan__type__offset();
  else field_lchan__type__offset.clean_up();
}
return *this;
}

boolean MNCC__PDU__Hello::operator==(const MNCC__PDU__Hello& other_value) const
{
return field_version==other_value.field_version
  && field_mncc__size==other_value.field_mncc__size
  && field_data__frame__size==other_value.field_data__frame__size
  && field_called__offset==other_value.field_called__offset
  && field_signal__offset==other_value.field_signal__offset
  && field_emergency__offset==other_value.field_emergency__offset
  && field_lchan__type__offset==other_value.field_lchan__type__offset;
}

boolean MNCC__PDU__Hello::is_bound() const
{
if(field_version.is_bound()) return TRUE;
if(field_mncc__size.is_bound()) return TRUE;
if(field_data__frame__size.is_bound()) return TRUE;
if(field_called__offset.is_bound()) return TRUE;
if(field_signal__offset.is_bound()) return TRUE;
if(field_emergency__offset.is_bound()) return TRUE;
if(field_lchan__type__offset.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__PDU__Hello::is_value() const
{
if(!field_version.is_value()) return FALSE;
if(!field_mncc__size.is_value()) return FALSE;
if(!field_data__frame__size.is_value()) return FALSE;
if(!field_called__offset.is_value()) return FALSE;
if(!field_signal__offset.is_value()) return FALSE;
if(!field_emergency__offset.is_value()) return FALSE;
if(!field_lchan__type__offset.is_value()) return FALSE;
return TRUE;
}
void MNCC__PDU__Hello::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", mncc_size := ");
field_mncc__size.log();
TTCN_Logger::log_event_str(", data_frame_size := ");
field_data__frame__size.log();
TTCN_Logger::log_event_str(", called_offset := ");
field_called__offset.log();
TTCN_Logger::log_event_str(", signal_offset := ");
field_signal__offset.log();
TTCN_Logger::log_event_str(", emergency_offset := ");
field_emergency__offset.log();
TTCN_Logger::log_event_str(", lchan_type_offset := ");
field_lchan__type__offset.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__PDU__Hello::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_PDU_Hello has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mncc__size().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data__frame__size().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) called__offset().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) signal__offset().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) emergency__offset().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) lchan__type__offset().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mncc_size")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mncc__size().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data_frame_size")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data__frame__size().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "called_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          called__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_type_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__type__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Hello: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_PDU_Hello");
  }
}

void MNCC__PDU__Hello::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (mncc__size().is_bound()) mncc__size().set_implicit_omit();
if (data__frame__size().is_bound()) data__frame__size().set_implicit_omit();
if (called__offset().is_bound()) called__offset().set_implicit_omit();
if (signal__offset().is_bound()) signal__offset().set_implicit_omit();
if (emergency__offset().is_bound()) emergency__offset().set_implicit_omit();
if (lchan__type__offset().is_bound()) lchan__type__offset().set_implicit_omit();
}

void MNCC__PDU__Hello::encode_text(Text_Buf& text_buf) const
{
field_version.encode_text(text_buf);
field_mncc__size.encode_text(text_buf);
field_data__frame__size.encode_text(text_buf);
field_called__offset.encode_text(text_buf);
field_signal__offset.encode_text(text_buf);
field_emergency__offset.encode_text(text_buf);
field_lchan__type__offset.encode_text(text_buf);
}

void MNCC__PDU__Hello::decode_text(Text_Buf& text_buf)
{
field_version.decode_text(text_buf);
field_mncc__size.decode_text(text_buf);
field_data__frame__size.decode_text(text_buf);
field_called__offset.decode_text(text_buf);
field_signal__offset.decode_text(text_buf);
field_emergency__offset.decode_text(text_buf);
field_lchan__type__offset.decode_text(text_buf);
}

void MNCC__PDU__Hello::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__PDU__Hello::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__PDU__Hello::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__PDU__Hello_version_descr_.raw->forceomit);
  decoded_field_length = field_version.RAW_decode(MNCC__PDU__Hello_version_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__PDU__Hello_mncc__size_descr_.raw->forceomit);
  decoded_field_length = field_mncc__size.RAW_decode(MNCC__PDU__Hello_mncc__size_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__PDU__Hello_data__frame__size_descr_.raw->forceomit);
  decoded_field_length = field_data__frame__size.RAW_decode(MNCC__PDU__Hello_data__frame__size_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__PDU__Hello_called__offset_descr_.raw->forceomit);
  decoded_field_length = field_called__offset.RAW_decode(MNCC__PDU__Hello_called__offset_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, MNCC__PDU__Hello_signal__offset_descr_.raw->forceomit);
  decoded_field_length = field_signal__offset.RAW_decode(MNCC__PDU__Hello_signal__offset_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, MNCC__PDU__Hello_emergency__offset_descr_.raw->forceomit);
  decoded_field_length = field_emergency__offset.RAW_decode(MNCC__PDU__Hello_emergency__offset_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, MNCC__PDU__Hello_lchan__type__offset_descr_.raw->forceomit);
  decoded_field_length = field_lchan__type__offset.RAW_decode(MNCC__PDU__Hello_lchan__type__offset_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__PDU__Hello::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__PDU__Hello_version_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__PDU__Hello_mncc__size_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, MNCC__PDU__Hello_data__frame__size_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, MNCC__PDU__Hello_called__offset_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, MNCC__PDU__Hello_signal__offset_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, MNCC__PDU__Hello_emergency__offset_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, MNCC__PDU__Hello_lchan__type__offset_descr_.raw);
  encoded_length += field_version.RAW_encode(MNCC__PDU__Hello_version_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_mncc__size.RAW_encode(MNCC__PDU__Hello_mncc__size_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_data__frame__size.RAW_encode(MNCC__PDU__Hello_data__frame__size_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_called__offset.RAW_encode(MNCC__PDU__Hello_called__offset_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_signal__offset.RAW_encode(MNCC__PDU__Hello_signal__offset_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_emergency__offset.RAW_encode(MNCC__PDU__Hello_emergency__offset_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_lchan__type__offset.RAW_encode(MNCC__PDU__Hello_lchan__type__offset_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

struct MNCC__PDU__Hello_template::single_value_struct {
INTEGER_template field_version;
INTEGER_template field_mncc__size;
INTEGER_template field_data__frame__size;
INTEGER_template field_called__offset;
INTEGER_template field_signal__offset;
INTEGER_template field_emergency__offset;
INTEGER_template field_lchan__type__offset;
};

void MNCC__PDU__Hello_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_mncc__size = ANY_VALUE;
single_value->field_data__frame__size = ANY_VALUE;
single_value->field_called__offset = ANY_VALUE;
single_value->field_signal__offset = ANY_VALUE;
single_value->field_emergency__offset = ANY_VALUE;
single_value->field_lchan__type__offset = ANY_VALUE;
}
}
}

void MNCC__PDU__Hello_template::copy_value(const MNCC__PDU__Hello& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.mncc__size().is_bound()) {
  single_value->field_mncc__size = other_value.mncc__size();
} else {
  single_value->field_mncc__size.clean_up();
}
if (other_value.data__frame__size().is_bound()) {
  single_value->field_data__frame__size = other_value.data__frame__size();
} else {
  single_value->field_data__frame__size.clean_up();
}
if (other_value.called__offset().is_bound()) {
  single_value->field_called__offset = other_value.called__offset();
} else {
  single_value->field_called__offset.clean_up();
}
if (other_value.signal__offset().is_bound()) {
  single_value->field_signal__offset = other_value.signal__offset();
} else {
  single_value->field_signal__offset.clean_up();
}
if (other_value.emergency__offset().is_bound()) {
  single_value->field_emergency__offset = other_value.emergency__offset();
} else {
  single_value->field_emergency__offset.clean_up();
}
if (other_value.lchan__type__offset().is_bound()) {
  single_value->field_lchan__type__offset = other_value.lchan__type__offset();
} else {
  single_value->field_lchan__type__offset.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__PDU__Hello_template::copy_template(const MNCC__PDU__Hello_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mncc__size().get_selection()) {
single_value->field_mncc__size = other_value.mncc__size();
} else {
single_value->field_mncc__size.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data__frame__size().get_selection()) {
single_value->field_data__frame__size = other_value.data__frame__size();
} else {
single_value->field_data__frame__size.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.called__offset().get_selection()) {
single_value->field_called__offset = other_value.called__offset();
} else {
single_value->field_called__offset.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signal__offset().get_selection()) {
single_value->field_signal__offset = other_value.signal__offset();
} else {
single_value->field_signal__offset.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergency__offset().get_selection()) {
single_value->field_emergency__offset = other_value.emergency__offset();
} else {
single_value->field_emergency__offset.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lchan__type__offset().get_selection()) {
single_value->field_lchan__type__offset = other_value.lchan__type__offset();
} else {
single_value->field_lchan__type__offset.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__PDU__Hello_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Hello.");
break;
}
set_selection(other_value);
}

MNCC__PDU__Hello_template::MNCC__PDU__Hello_template()
{
}

MNCC__PDU__Hello_template::MNCC__PDU__Hello_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__PDU__Hello_template::MNCC__PDU__Hello_template(const MNCC__PDU__Hello& other_value)
{
copy_value(other_value);
}

MNCC__PDU__Hello_template::MNCC__PDU__Hello_template(const OPTIONAL<MNCC__PDU__Hello>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Hello&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_PDU_Hello from an unbound optional field.");
}
}

MNCC__PDU__Hello_template::MNCC__PDU__Hello_template(const MNCC__PDU__Hello_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__PDU__Hello_template::~MNCC__PDU__Hello_template()
{
clean_up();
}

MNCC__PDU__Hello_template& MNCC__PDU__Hello_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__PDU__Hello_template& MNCC__PDU__Hello_template::operator=(const MNCC__PDU__Hello& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__PDU__Hello_template& MNCC__PDU__Hello_template::operator=(const OPTIONAL<MNCC__PDU__Hello>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU__Hello&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_PDU_Hello.");
}
return *this;
}

MNCC__PDU__Hello_template& MNCC__PDU__Hello_template::operator=(const MNCC__PDU__Hello_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__PDU__Hello_template::match(const MNCC__PDU__Hello& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.mncc__size().is_bound()) return FALSE;
if(!single_value->field_mncc__size.match(other_value.mncc__size(), legacy))return FALSE;
if(!other_value.data__frame__size().is_bound()) return FALSE;
if(!single_value->field_data__frame__size.match(other_value.data__frame__size(), legacy))return FALSE;
if(!other_value.called__offset().is_bound()) return FALSE;
if(!single_value->field_called__offset.match(other_value.called__offset(), legacy))return FALSE;
if(!other_value.signal__offset().is_bound()) return FALSE;
if(!single_value->field_signal__offset.match(other_value.signal__offset(), legacy))return FALSE;
if(!other_value.emergency__offset().is_bound()) return FALSE;
if(!single_value->field_emergency__offset.match(other_value.emergency__offset(), legacy))return FALSE;
if(!other_value.lchan__type__offset().is_bound()) return FALSE;
if(!single_value->field_lchan__type__offset.match(other_value.lchan__type__offset(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Hello.");
}
return FALSE;
}

boolean MNCC__PDU__Hello_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_mncc__size.is_bound()) return TRUE;
if (single_value->field_data__frame__size.is_bound()) return TRUE;
if (single_value->field_called__offset.is_bound()) return TRUE;
if (single_value->field_signal__offset.is_bound()) return TRUE;
if (single_value->field_emergency__offset.is_bound()) return TRUE;
if (single_value->field_lchan__type__offset.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__PDU__Hello_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_mncc__size.is_value()) return FALSE;
if (!single_value->field_data__frame__size.is_value()) return FALSE;
if (!single_value->field_called__offset.is_value()) return FALSE;
if (!single_value->field_signal__offset.is_value()) return FALSE;
if (!single_value->field_emergency__offset.is_value()) return FALSE;
if (!single_value->field_lchan__type__offset.is_value()) return FALSE;
return TRUE;
}

void MNCC__PDU__Hello_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__PDU__Hello MNCC__PDU__Hello_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
MNCC__PDU__Hello ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_mncc__size.is_bound()) {
ret_val.mncc__size() = single_value->field_mncc__size.valueof();
}
if (single_value->field_data__frame__size.is_bound()) {
ret_val.data__frame__size() = single_value->field_data__frame__size.valueof();
}
if (single_value->field_called__offset.is_bound()) {
ret_val.called__offset() = single_value->field_called__offset.valueof();
}
if (single_value->field_signal__offset.is_bound()) {
ret_val.signal__offset() = single_value->field_signal__offset.valueof();
}
if (single_value->field_emergency__offset.is_bound()) {
ret_val.emergency__offset() = single_value->field_emergency__offset.valueof();
}
if (single_value->field_lchan__type__offset.is_bound()) {
ret_val.lchan__type__offset() = single_value->field_lchan__type__offset.valueof();
}
return ret_val;
}

void MNCC__PDU__Hello_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_PDU_Hello.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__PDU__Hello_template[list_length];
}

MNCC__PDU__Hello_template& MNCC__PDU__Hello_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_PDU_Hello.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_PDU_Hello.");
return value_list.list_value[list_index];
}

INTEGER_template& MNCC__PDU__Hello_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& MNCC__PDU__Hello_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_version;
}

INTEGER_template& MNCC__PDU__Hello_template::mncc__size()
{
set_specific();
return single_value->field_mncc__size;
}

const INTEGER_template& MNCC__PDU__Hello_template::mncc__size() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mncc_size of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_mncc__size;
}

INTEGER_template& MNCC__PDU__Hello_template::data__frame__size()
{
set_specific();
return single_value->field_data__frame__size;
}

const INTEGER_template& MNCC__PDU__Hello_template::data__frame__size() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data_frame_size of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_data__frame__size;
}

INTEGER_template& MNCC__PDU__Hello_template::called__offset()
{
set_specific();
return single_value->field_called__offset;
}

const INTEGER_template& MNCC__PDU__Hello_template::called__offset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field called_offset of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_called__offset;
}

INTEGER_template& MNCC__PDU__Hello_template::signal__offset()
{
set_specific();
return single_value->field_signal__offset;
}

const INTEGER_template& MNCC__PDU__Hello_template::signal__offset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signal_offset of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_signal__offset;
}

INTEGER_template& MNCC__PDU__Hello_template::emergency__offset()
{
set_specific();
return single_value->field_emergency__offset;
}

const INTEGER_template& MNCC__PDU__Hello_template::emergency__offset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergency_offset of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_emergency__offset;
}

INTEGER_template& MNCC__PDU__Hello_template::lchan__type__offset()
{
set_specific();
return single_value->field_lchan__type__offset;
}

const INTEGER_template& MNCC__PDU__Hello_template::lchan__type__offset() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lchan_type_offset of a non-specific template of type @MNCC_Types.MNCC_PDU_Hello.");
return single_value->field_lchan__type__offset;
}

int MNCC__PDU__Hello_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU_Hello containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Hello.");
  }
  return 0;
}

void MNCC__PDU__Hello_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", mncc_size := ");
single_value->field_mncc__size.log();
TTCN_Logger::log_event_str(", data_frame_size := ");
single_value->field_data__frame__size.log();
TTCN_Logger::log_event_str(", called_offset := ");
single_value->field_called__offset.log();
TTCN_Logger::log_event_str(", signal_offset := ");
single_value->field_signal__offset.log();
TTCN_Logger::log_event_str(", emergency_offset := ");
single_value->field_emergency__offset.log();
TTCN_Logger::log_event_str(", lchan_type_offset := ");
single_value->field_lchan__type__offset.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__PDU__Hello_template::log_match(const MNCC__PDU__Hello& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mncc__size.match(match_value.mncc__size(), legacy)){
TTCN_Logger::log_logmatch_info(".mncc_size");
single_value->field_mncc__size.log_match(match_value.mncc__size(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_data__frame__size.match(match_value.data__frame__size(), legacy)){
TTCN_Logger::log_logmatch_info(".data_frame_size");
single_value->field_data__frame__size.log_match(match_value.data__frame__size(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_called__offset.match(match_value.called__offset(), legacy)){
TTCN_Logger::log_logmatch_info(".called_offset");
single_value->field_called__offset.log_match(match_value.called__offset(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signal__offset.match(match_value.signal__offset(), legacy)){
TTCN_Logger::log_logmatch_info(".signal_offset");
single_value->field_signal__offset.log_match(match_value.signal__offset(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_emergency__offset.match(match_value.emergency__offset(), legacy)){
TTCN_Logger::log_logmatch_info(".emergency_offset");
single_value->field_emergency__offset.log_match(match_value.emergency__offset(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lchan__type__offset.match(match_value.lchan__type__offset(), legacy)){
TTCN_Logger::log_logmatch_info(".lchan_type_offset");
single_value->field_lchan__type__offset.log_match(match_value.lchan__type__offset(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", mncc_size := ");
single_value->field_mncc__size.log_match(match_value.mncc__size(), legacy);
TTCN_Logger::log_event_str(", data_frame_size := ");
single_value->field_data__frame__size.log_match(match_value.data__frame__size(), legacy);
TTCN_Logger::log_event_str(", called_offset := ");
single_value->field_called__offset.log_match(match_value.called__offset(), legacy);
TTCN_Logger::log_event_str(", signal_offset := ");
single_value->field_signal__offset.log_match(match_value.signal__offset(), legacy);
TTCN_Logger::log_event_str(", emergency_offset := ");
single_value->field_emergency__offset.log_match(match_value.emergency__offset(), legacy);
TTCN_Logger::log_event_str(", lchan_type_offset := ");
single_value->field_lchan__type__offset.log_match(match_value.lchan__type__offset(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__PDU__Hello_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_mncc__size.encode_text(text_buf);
single_value->field_data__frame__size.encode_text(text_buf);
single_value->field_called__offset.encode_text(text_buf);
single_value->field_signal__offset.encode_text(text_buf);
single_value->field_emergency__offset.encode_text(text_buf);
single_value->field_lchan__type__offset.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU_Hello.");
}
}

void MNCC__PDU__Hello_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_mncc__size.decode_text(text_buf);
single_value->field_data__frame__size.decode_text(text_buf);
single_value->field_called__offset.decode_text(text_buf);
single_value->field_signal__offset.decode_text(text_buf);
single_value->field_emergency__offset.decode_text(text_buf);
single_value->field_lchan__type__offset.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__PDU__Hello_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_PDU_Hello.");
}
}

void MNCC__PDU__Hello_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__PDU__Hello_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_PDU_Hello has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mncc__size().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data__frame__size().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) called__offset().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) signal__offset().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) emergency__offset().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) lchan__type__offset().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mncc_size")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mncc__size().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data_frame_size")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data__frame__size().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "called_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          called__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lchan_type_offset")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lchan__type__offset().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU_Hello: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_PDU_Hello");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__PDU__Hello_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_mncc__size.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_data__frame__size.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_called__offset.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_signal__offset.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_emergency__offset.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
single_value->field_lchan__type__offset.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_PDU_Hello");
}

boolean MNCC__PDU__Hello_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__PDU__Hello_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MNCC__MsgUnion::copy_value(const MNCC__MsgUnion& other_value)
{
switch (other_value.union_selection) {
case ALT_signal:
field_signal = new MNCC__PDU__Signal(*other_value.field_signal);
break;
case ALT_data:
field_data = new MNCC__PDU__Data(*other_value.field_data);
break;
case ALT_rtp:
field_rtp = new MNCC__PDU__Rtp(*other_value.field_rtp);
break;
case ALT_hello:
field_hello = new MNCC__PDU__Hello(*other_value.field_hello);
break;
default:
TTCN_error("Assignment of an unbound union value of type @MNCC_Types.MNCC_MsgUnion.");
}
union_selection = other_value.union_selection;
}

MNCC__MsgUnion::MNCC__MsgUnion()
{
union_selection = UNBOUND_VALUE;
}

MNCC__MsgUnion::MNCC__MsgUnion(const MNCC__MsgUnion& other_value)
: Base_Type(){
copy_value(other_value);
}

MNCC__MsgUnion::~MNCC__MsgUnion()
{
clean_up();
}

MNCC__MsgUnion& MNCC__MsgUnion::operator=(const MNCC__MsgUnion& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean MNCC__MsgUnion::operator==(const MNCC__MsgUnion& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @MNCC_Types.MNCC_MsgUnion.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @MNCC_Types.MNCC_MsgUnion.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_signal:
return *field_signal == *other_value.field_signal;
case ALT_data:
return *field_data == *other_value.field_data;
case ALT_rtp:
return *field_rtp == *other_value.field_rtp;
case ALT_hello:
return *field_hello == *other_value.field_hello;
default:
return FALSE;
}
}

MNCC__PDU__Signal& MNCC__MsgUnion::signal()
{
if (union_selection != ALT_signal) {
clean_up();
field_signal = new MNCC__PDU__Signal;
union_selection = ALT_signal;
}
return *field_signal;
}

const MNCC__PDU__Signal& MNCC__MsgUnion::signal() const
{
if (union_selection != ALT_signal) TTCN_error("Using non-selected field signal in a value of union type @MNCC_Types.MNCC_MsgUnion.");
return *field_signal;
}

MNCC__PDU__Data& MNCC__MsgUnion::data()
{
if (union_selection != ALT_data) {
clean_up();
field_data = new MNCC__PDU__Data;
union_selection = ALT_data;
}
return *field_data;
}

const MNCC__PDU__Data& MNCC__MsgUnion::data() const
{
if (union_selection != ALT_data) TTCN_error("Using non-selected field data in a value of union type @MNCC_Types.MNCC_MsgUnion.");
return *field_data;
}

MNCC__PDU__Rtp& MNCC__MsgUnion::rtp()
{
if (union_selection != ALT_rtp) {
clean_up();
field_rtp = new MNCC__PDU__Rtp;
union_selection = ALT_rtp;
}
return *field_rtp;
}

const MNCC__PDU__Rtp& MNCC__MsgUnion::rtp() const
{
if (union_selection != ALT_rtp) TTCN_error("Using non-selected field rtp in a value of union type @MNCC_Types.MNCC_MsgUnion.");
return *field_rtp;
}

MNCC__PDU__Hello& MNCC__MsgUnion::hello()
{
if (union_selection != ALT_hello) {
clean_up();
field_hello = new MNCC__PDU__Hello;
union_selection = ALT_hello;
}
return *field_hello;
}

const MNCC__PDU__Hello& MNCC__MsgUnion::hello() const
{
if (union_selection != ALT_hello) TTCN_error("Using non-selected field hello in a value of union type @MNCC_Types.MNCC_MsgUnion.");
return *field_hello;
}

boolean MNCC__MsgUnion::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @MNCC_Types.MNCC_MsgUnion.");
return union_selection == checked_selection;
}

boolean MNCC__MsgUnion::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean MNCC__MsgUnion::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_signal: return field_signal->is_value();
case ALT_data: return field_data->is_value();
case ALT_rtp: return field_rtp->is_value();
case ALT_hello: return field_hello->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void MNCC__MsgUnion::clean_up()
{
switch (union_selection) {
case ALT_signal:
  delete field_signal;
  break;
case ALT_data:
  delete field_data;
  break;
case ALT_rtp:
  delete field_rtp;
  break;
case ALT_hello:
  delete field_hello;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void MNCC__MsgUnion::log() const
{
switch (union_selection) {
case ALT_signal:
TTCN_Logger::log_event_str("{ signal := ");
field_signal->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data:
TTCN_Logger::log_event_str("{ data := ");
field_data->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rtp:
TTCN_Logger::log_event_str("{ rtp := ");
field_rtp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_hello:
TTCN_Logger::log_event_str("{ hello := ");
field_hello->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void MNCC__MsgUnion::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  char* last_name = mp_last->get_id()->get_name();
  if (!strcmp(last_name, "signal")) {
    signal().set_param(*mp_last);
    if (!signal().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "data")) {
    data().set_param(*mp_last);
    if (!data().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "rtp")) {
    rtp().set_param(*mp_last);
    if (!rtp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "hello")) {
    hello().set_param(*mp_last);
    if (!hello().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @MNCC_Types.MNCC_MsgUnion.", last_name);
}

void MNCC__MsgUnion::set_implicit_omit()
{
switch (union_selection) {
case ALT_signal:
field_signal->set_implicit_omit(); break;
case ALT_data:
field_data->set_implicit_omit(); break;
case ALT_rtp:
field_rtp->set_implicit_omit(); break;
case ALT_hello:
field_hello->set_implicit_omit(); break;
default: break;
}
}

void MNCC__MsgUnion::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_signal:
field_signal->encode_text(text_buf);
break;
case ALT_data:
field_data->encode_text(text_buf);
break;
case ALT_rtp:
field_rtp->encode_text(text_buf);
break;
case ALT_hello:
field_hello->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @MNCC_Types.MNCC_MsgUnion.");
}
}

void MNCC__MsgUnion::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_signal:
signal().decode_text(text_buf);
break;
case ALT_data:
data().decode_text(text_buf);
break;
case ALT_rtp:
rtp().decode_text(text_buf);
break;
case ALT_hello:
hello().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @MNCC_Types.MNCC_MsgUnion.");
}
}

void MNCC__MsgUnion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__MsgUnion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__MsgUnion::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean, const RAW_Force_Omit* force_omit)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0: {
      RAW_Force_Omit field_force_omit(0, force_omit, MNCC__MsgUnion_signal_descr_.raw->forceomit);
      decoded_length = signal().RAW_decode(MNCC__MsgUnion_signal_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 1: {
      RAW_Force_Omit field_force_omit(1, force_omit, MNCC__MsgUnion_data_descr_.raw->forceomit);
      decoded_length = data().RAW_decode(MNCC__MsgUnion_data_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 2: {
      RAW_Force_Omit field_force_omit(2, force_omit, MNCC__MsgUnion_rtp_descr_.raw->forceomit);
      decoded_length = rtp().RAW_decode(MNCC__MsgUnion_rtp_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 3: {
      RAW_Force_Omit field_force_omit(3, force_omit, MNCC__MsgUnion_hello_descr_.raw->forceomit);
      decoded_length = hello().RAW_decode(MNCC__MsgUnion_hello_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__MsgUnion_signal_descr_.raw->forceomit);
      decoded_length = signal().RAW_decode(MNCC__MsgUnion_signal_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_0_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__MsgUnion_data_descr_.raw->forceomit);
      decoded_length = data().RAW_decode(MNCC__MsgUnion_data_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_1_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_2_force_omit(2, force_omit, MNCC__MsgUnion_rtp_descr_.raw->forceomit);
      decoded_length = rtp().RAW_decode(MNCC__MsgUnion_rtp_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_2_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_3_force_omit(3, force_omit, MNCC__MsgUnion_hello_descr_.raw->forceomit);
      decoded_length = hello().RAW_decode(MNCC__MsgUnion_hello_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_3_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int MNCC__MsgUnion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 4;  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  memset(myleaf.body.node.nodes, 0, 4 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_signal:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, MNCC__MsgUnion_signal_descr_.raw);
    encoded_length = field_signal->RAW_encode(MNCC__MsgUnion_signal_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &MNCC__MsgUnion_signal_descr_;
    break;
  case ALT_data:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, MNCC__MsgUnion_data_descr_.raw);
    encoded_length = field_data->RAW_encode(MNCC__MsgUnion_data_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &MNCC__MsgUnion_data_descr_;
    break;
  case ALT_rtp:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, MNCC__MsgUnion_rtp_descr_.raw);
    encoded_length = field_rtp->RAW_encode(MNCC__MsgUnion_rtp_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &MNCC__MsgUnion_rtp_descr_;
    break;
  case ALT_hello:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, MNCC__MsgUnion_hello_descr_.raw);
    encoded_length = field_hello->RAW_encode(MNCC__MsgUnion_hello_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &MNCC__MsgUnion_hello_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

void MNCC__MsgUnion_template::copy_value(const MNCC__MsgUnion& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
single_value.field_signal = new MNCC__PDU__Signal_template(other_value.signal());
break;
case MNCC__MsgUnion::ALT_data:
single_value.field_data = new MNCC__PDU__Data_template(other_value.data());
break;
case MNCC__MsgUnion::ALT_rtp:
single_value.field_rtp = new MNCC__PDU__Rtp_template(other_value.rtp());
break;
case MNCC__MsgUnion::ALT_hello:
single_value.field_hello = new MNCC__PDU__Hello_template(other_value.hello());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @MNCC_Types.MNCC_MsgUnion.");
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__MsgUnion_template::copy_template(const MNCC__MsgUnion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
single_value.field_signal = new MNCC__PDU__Signal_template(*other_value.single_value.field_signal);
break;
case MNCC__MsgUnion::ALT_data:
single_value.field_data = new MNCC__PDU__Data_template(*other_value.single_value.field_data);
break;
case MNCC__MsgUnion::ALT_rtp:
single_value.field_rtp = new MNCC__PDU__Rtp_template(*other_value.single_value.field_rtp);
break;
case MNCC__MsgUnion::ALT_hello:
single_value.field_hello = new MNCC__PDU__Hello_template(*other_value.single_value.field_hello);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @MNCC_Types.MNCC_MsgUnion.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__MsgUnion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @MNCC_Types.MNCC_MsgUnion.");
}
set_selection(other_value);
}

MNCC__MsgUnion_template::MNCC__MsgUnion_template()
{
}

MNCC__MsgUnion_template::MNCC__MsgUnion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__MsgUnion_template::MNCC__MsgUnion_template(const MNCC__MsgUnion& other_value)
{
copy_value(other_value);
}

MNCC__MsgUnion_template::MNCC__MsgUnion_template(const OPTIONAL<MNCC__MsgUnion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__MsgUnion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @MNCC_Types.MNCC_MsgUnion from an unbound optional field.");
}
}

MNCC__MsgUnion_template::MNCC__MsgUnion_template(const MNCC__MsgUnion_template& other_value)
: Base_Template(){
copy_template(other_value);
}

MNCC__MsgUnion_template::~MNCC__MsgUnion_template()
{
clean_up();
}

void MNCC__MsgUnion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
delete single_value.field_signal;
break;
case MNCC__MsgUnion::ALT_data:
delete single_value.field_data;
break;
case MNCC__MsgUnion::ALT_rtp:
delete single_value.field_rtp;
break;
case MNCC__MsgUnion::ALT_hello:
delete single_value.field_hello;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__MsgUnion_template& MNCC__MsgUnion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__MsgUnion_template& MNCC__MsgUnion_template::operator=(const MNCC__MsgUnion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__MsgUnion_template& MNCC__MsgUnion_template::operator=(const OPTIONAL<MNCC__MsgUnion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__MsgUnion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
return *this;
}

MNCC__MsgUnion_template& MNCC__MsgUnion_template::operator=(const MNCC__MsgUnion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__MsgUnion_template::match(const MNCC__MsgUnion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
MNCC__MsgUnion::union_selection_type value_selection = other_value.get_selection();
if (value_selection == MNCC__MsgUnion::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case MNCC__MsgUnion::ALT_signal:
return single_value.field_signal->match(other_value.signal(), legacy);
case MNCC__MsgUnion::ALT_data:
return single_value.field_data->match(other_value.data(), legacy);
case MNCC__MsgUnion::ALT_rtp:
return single_value.field_rtp->match(other_value.rtp(), legacy);
case MNCC__MsgUnion::ALT_hello:
return single_value.field_hello->match(other_value.hello(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @MNCC_Types.MNCC_MsgUnion.");
}
return FALSE;
}

boolean MNCC__MsgUnion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
return single_value.field_signal->is_value();
case MNCC__MsgUnion::ALT_data:
return single_value.field_data->is_value();
case MNCC__MsgUnion::ALT_rtp:
return single_value.field_rtp->is_value();
case MNCC__MsgUnion::ALT_hello:
return single_value.field_hello->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
}

MNCC__MsgUnion MNCC__MsgUnion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @MNCC_Types.MNCC_MsgUnion.");
MNCC__MsgUnion ret_val;
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
ret_val.signal() = single_value.field_signal->valueof();
break;
case MNCC__MsgUnion::ALT_data:
ret_val.data() = single_value.field_data->valueof();
break;
case MNCC__MsgUnion::ALT_rtp:
ret_val.rtp() = single_value.field_rtp->valueof();
break;
case MNCC__MsgUnion::ALT_hello:
ret_val.hello() = single_value.field_hello->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
return ret_val;
}

MNCC__MsgUnion_template& MNCC__MsgUnion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @MNCC_Types.MNCC_MsgUnion.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @MNCC_Types.MNCC_MsgUnion.");
return value_list.list_value[list_index];
}
void MNCC__MsgUnion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @MNCC_Types.MNCC_MsgUnion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__MsgUnion_template[list_length];
}

MNCC__PDU__Signal_template& MNCC__MsgUnion_template::signal()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MNCC__MsgUnion::ALT_signal) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_signal = new MNCC__PDU__Signal_template(ANY_VALUE);
else single_value.field_signal = new MNCC__PDU__Signal_template;
single_value.union_selection = MNCC__MsgUnion::ALT_signal;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_signal;
}

const MNCC__PDU__Signal_template& MNCC__MsgUnion_template::signal() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field signal in a non-specific template of union type @MNCC_Types.MNCC_MsgUnion.");
if (single_value.union_selection != MNCC__MsgUnion::ALT_signal) TTCN_error("Accessing non-selected field signal in a template of union type @MNCC_Types.MNCC_MsgUnion.");
return *single_value.field_signal;
}

MNCC__PDU__Data_template& MNCC__MsgUnion_template::data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MNCC__MsgUnion::ALT_data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data = new MNCC__PDU__Data_template(ANY_VALUE);
else single_value.field_data = new MNCC__PDU__Data_template;
single_value.union_selection = MNCC__MsgUnion::ALT_data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data;
}

const MNCC__PDU__Data_template& MNCC__MsgUnion_template::data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data in a non-specific template of union type @MNCC_Types.MNCC_MsgUnion.");
if (single_value.union_selection != MNCC__MsgUnion::ALT_data) TTCN_error("Accessing non-selected field data in a template of union type @MNCC_Types.MNCC_MsgUnion.");
return *single_value.field_data;
}

MNCC__PDU__Rtp_template& MNCC__MsgUnion_template::rtp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MNCC__MsgUnion::ALT_rtp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rtp = new MNCC__PDU__Rtp_template(ANY_VALUE);
else single_value.field_rtp = new MNCC__PDU__Rtp_template;
single_value.union_selection = MNCC__MsgUnion::ALT_rtp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rtp;
}

const MNCC__PDU__Rtp_template& MNCC__MsgUnion_template::rtp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rtp in a non-specific template of union type @MNCC_Types.MNCC_MsgUnion.");
if (single_value.union_selection != MNCC__MsgUnion::ALT_rtp) TTCN_error("Accessing non-selected field rtp in a template of union type @MNCC_Types.MNCC_MsgUnion.");
return *single_value.field_rtp;
}

MNCC__PDU__Hello_template& MNCC__MsgUnion_template::hello()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MNCC__MsgUnion::ALT_hello) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_hello = new MNCC__PDU__Hello_template(ANY_VALUE);
else single_value.field_hello = new MNCC__PDU__Hello_template;
single_value.union_selection = MNCC__MsgUnion::ALT_hello;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_hello;
}

const MNCC__PDU__Hello_template& MNCC__MsgUnion_template::hello() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field hello in a non-specific template of union type @MNCC_Types.MNCC_MsgUnion.");
if (single_value.union_selection != MNCC__MsgUnion::ALT_hello) TTCN_error("Accessing non-selected field hello in a template of union type @MNCC_Types.MNCC_MsgUnion.");
return *single_value.field_hello;
}

boolean MNCC__MsgUnion_template::ischosen(MNCC__MsgUnion::union_selection_type checked_selection) const
{
if (checked_selection == MNCC__MsgUnion::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @MNCC_Types.MNCC_MsgUnion.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == MNCC__MsgUnion::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @MNCC_Types.MNCC_MsgUnion.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @MNCC_Types.MNCC_MsgUnion containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
for (unsigned int list_count = 1; ret_val == TRUE && list_count < value_list.n_values; list_count++) {
ret_val = value_list.list_value[list_count].ischosen(checked_selection);
}
return ret_val;
}
default:
return FALSE;
}
return FALSE;
}

void MNCC__MsgUnion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
TTCN_Logger::log_event_str("{ signal := ");
single_value.field_signal->log();
TTCN_Logger::log_event_str(" }");
break;
case MNCC__MsgUnion::ALT_data:
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log();
TTCN_Logger::log_event_str(" }");
break;
case MNCC__MsgUnion::ALT_rtp:
TTCN_Logger::log_event_str("{ rtp := ");
single_value.field_rtp->log();
TTCN_Logger::log_event_str(" }");
break;
case MNCC__MsgUnion::ALT_hello:
TTCN_Logger::log_event_str("{ hello := ");
single_value.field_hello->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__MsgUnion_template::log_match(const MNCC__MsgUnion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".signal");
single_value.field_signal->log_match(match_value.signal(), legacy);
} else {
TTCN_Logger::log_event_str("{ signal := ");
single_value.field_signal->log_match(match_value.signal(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MNCC__MsgUnion::ALT_data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data");
single_value.field_data->log_match(match_value.data(), legacy);
} else {
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log_match(match_value.data(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MNCC__MsgUnion::ALT_rtp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rtp");
single_value.field_rtp->log_match(match_value.rtp(), legacy);
} else {
TTCN_Logger::log_event_str("{ rtp := ");
single_value.field_rtp->log_match(match_value.rtp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MNCC__MsgUnion::ALT_hello:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".hello");
single_value.field_hello->log_match(match_value.hello(), legacy);
} else {
TTCN_Logger::log_event_str("{ hello := ");
single_value.field_hello->log_match(match_value.hello(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__MsgUnion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
single_value.field_signal->encode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_data:
single_value.field_data->encode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_rtp:
single_value.field_rtp->encode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_hello:
single_value.field_hello->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @MNCC_Types.MNCC_MsgUnion.");
}
}

void MNCC__MsgUnion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = MNCC__MsgUnion::UNBOUND_VALUE;
MNCC__MsgUnion::union_selection_type new_selection = (MNCC__MsgUnion::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case MNCC__MsgUnion::ALT_signal:
single_value.field_signal = new MNCC__PDU__Signal_template;
single_value.field_signal->decode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_data:
single_value.field_data = new MNCC__PDU__Data_template;
single_value.field_data->decode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_rtp:
single_value.field_rtp = new MNCC__PDU__Rtp_template;
single_value.field_rtp->decode_text(text_buf);
break;
case MNCC__MsgUnion::ALT_hello:
single_value.field_hello = new MNCC__PDU__Hello_template;
single_value.field_hello->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @MNCC_Types.MNCC_MsgUnion.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__MsgUnion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @MNCC_Types.MNCC_MsgUnion.");
}
}

boolean MNCC__MsgUnion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__MsgUnion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MNCC__MsgUnion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@MNCC_Types.MNCC_MsgUnion'");
    }
    if (strcmp("signal", param_field) == 0) {
      signal().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("rtp", param_field) == 0) {
      rtp().set_param(param);
      return;
    } else if (strcmp("hello", param_field) == 0) {
      hello().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@MNCC_Types.MNCC_MsgUnion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__MsgUnion_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@MNCC_Types.MNCC_MsgUnion");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    char* last_name = mp_last->get_id()->get_name();
    if (!strcmp(last_name, "signal")) {
      signal().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "data")) {
      data().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "rtp")) {
      rtp().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "hello")) {
      hello().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @MNCC_Types.MNCC_MsgUnion.", last_name);
  } break;
  default:
    param.type_error("union template", "@MNCC_Types.MNCC_MsgUnion");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__MsgUnion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case MNCC__MsgUnion::ALT_signal:
single_value.field_signal->check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_MsgUnion");
return;
case MNCC__MsgUnion::ALT_data:
single_value.field_data->check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_MsgUnion");
return;
case MNCC__MsgUnion::ALT_rtp:
single_value.field_rtp->check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_MsgUnion");
return;
case MNCC__MsgUnion::ALT_hello:
single_value.field_hello->check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_MsgUnion");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @MNCC_Types.MNCC_MsgUnion.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_MsgUnion");
}

MNCC__PDU::MNCC__PDU()
{
}

MNCC__PDU::MNCC__PDU(const MNCC__MsgType& par_msg__type,
    const MNCC__MsgUnion& par_u)
  :   field_msg__type(par_msg__type),
  field_u(par_u)
{
}

MNCC__PDU::MNCC__PDU(const MNCC__PDU& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @MNCC_Types.MNCC_PDU.");
if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
else field_msg__type.clean_up();
if (other_value.u().is_bound()) field_u = other_value.u();
else field_u.clean_up();
}

void MNCC__PDU::clean_up()
{
field_msg__type.clean_up();
field_u.clean_up();
}

const TTCN_Typedescriptor_t* MNCC__PDU::get_descriptor() const { return &MNCC__PDU_descr_; }
MNCC__PDU& MNCC__PDU::operator=(const MNCC__PDU& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @MNCC_Types.MNCC_PDU.");
  if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
  else field_msg__type.clean_up();
  if (other_value.u().is_bound()) field_u = other_value.u();
  else field_u.clean_up();
}
return *this;
}

boolean MNCC__PDU::operator==(const MNCC__PDU& other_value) const
{
return field_msg__type==other_value.field_msg__type
  && field_u==other_value.field_u;
}

boolean MNCC__PDU::is_bound() const
{
if(field_msg__type.is_bound()) return TRUE;
if(field_u.is_bound()) return TRUE;
return FALSE;
}
boolean MNCC__PDU::is_value() const
{
if(!field_msg__type.is_value()) return FALSE;
if(!field_u.is_value()) return FALSE;
return TRUE;
}
void MNCC__PDU::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msg_type := ");
field_msg__type.log();
TTCN_Logger::log_event_str(", u := ");
field_u.log();
TTCN_Logger::log_event_str(" }");
}

void MNCC__PDU::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @MNCC_Types.MNCC_PDU has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) u().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "u")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          u().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@MNCC_Types.MNCC_PDU");
  }
}

void MNCC__PDU::set_implicit_omit()
{
if (msg__type().is_bound()) msg__type().set_implicit_omit();
if (u().is_bound()) u().set_implicit_omit();
}

void MNCC__PDU::encode_text(Text_Buf& text_buf) const
{
field_msg__type.encode_text(text_buf);
field_u.encode_text(text_buf);
}

void MNCC__PDU::decode_text(Text_Buf& text_buf)
{
field_msg__type.decode_text(text_buf);
field_u.decode_text(text_buf);
}

void MNCC__PDU::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MNCC__PDU::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int MNCC__PDU::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  int selected_field = -1;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, MNCC__PDU_msg__type_descr_.raw->forceomit);
  decoded_field_length = field_msg__type.RAW_decode(MNCC__PDU_msg__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (field_msg__type == MNCC__MsgType::MNCC__SOCKET__HELLO) selected_field = 3;
  else if (field_msg__type == MNCC__MsgType::MNCC__RTP__CREATE || field_msg__type == MNCC__MsgType::MNCC__RTP__CONNECT || field_msg__type == MNCC__MsgType::MNCC__RTP__FREE) selected_field = 2;
  else if (field_msg__type == MNCC__MsgType::GSM__TCHF__FRAME || field_msg__type == MNCC__MsgType::GSM__TCHF__FRAME__EFR || field_msg__type == MNCC__MsgType::GSM__TCHH__FRAME || field_msg__type == MNCC__MsgType::GSM__TCH__FRAME__AMR || field_msg__type == MNCC__MsgType::GSM__BAD__FRAME) selected_field = 1;
  else selected_field = 0;
  RAW_Force_Omit field_1_force_omit(1, force_omit, MNCC__PDU_u_descr_.raw->forceomit);
  decoded_field_length = field_u.RAW_decode(MNCC__PDU_u_descr_, p_buf, limit, local_top_order, no_err, selected_field, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int MNCC__PDU::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, MNCC__PDU_msg__type_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, MNCC__PDU_u_descr_.raw);
  encoded_length += field_msg__type.RAW_encode(MNCC__PDU_msg__type_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_u.RAW_encode(MNCC__PDU_u_descr_, *myleaf.body.node.nodes[1]);
  switch (field_u.get_selection()) {
  case MNCC__MsgUnion::ALT_hello:
  if (field_msg__type != MNCC__MsgType::MNCC__SOCKET__HELLO) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  MNCC__MsgType new_val(MNCC__MsgType::MNCC__SOCKET__HELLO);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(MNCC__PDU_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case MNCC__MsgUnion::ALT_rtp:
  if (field_msg__type != MNCC__MsgType::MNCC__RTP__CREATE && field_msg__type != MNCC__MsgType::MNCC__RTP__CONNECT && field_msg__type != MNCC__MsgType::MNCC__RTP__FREE) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  MNCC__MsgType new_val(MNCC__MsgType::MNCC__RTP__CREATE);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(MNCC__PDU_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case MNCC__MsgUnion::ALT_data:
  if (field_msg__type != MNCC__MsgType::GSM__TCHF__FRAME && field_msg__type != MNCC__MsgType::GSM__TCHF__FRAME__EFR && field_msg__type != MNCC__MsgType::GSM__TCHH__FRAME && field_msg__type != MNCC__MsgType::GSM__TCH__FRAME__AMR && field_msg__type != MNCC__MsgType::GSM__BAD__FRAME) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  MNCC__MsgType new_val(MNCC__MsgType::GSM__TCHF__FRAME);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(MNCC__PDU_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  return myleaf.length = encoded_length;
}

struct MNCC__PDU_template::single_value_struct {
MNCC__MsgType_template field_msg__type;
MNCC__MsgUnion_template field_u;
};

void MNCC__PDU_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msg__type = ANY_VALUE;
single_value->field_u = ANY_VALUE;
}
}
}

void MNCC__PDU_template::copy_value(const MNCC__PDU& other_value)
{
single_value = new single_value_struct;
if (other_value.msg__type().is_bound()) {
  single_value->field_msg__type = other_value.msg__type();
} else {
  single_value->field_msg__type.clean_up();
}
if (other_value.u().is_bound()) {
  single_value->field_u = other_value.u();
} else {
  single_value->field_u.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MNCC__PDU_template::copy_template(const MNCC__PDU_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msg__type().get_selection()) {
single_value->field_msg__type = other_value.msg__type();
} else {
single_value->field_msg__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.u().get_selection()) {
single_value->field_u = other_value.u();
} else {
single_value->field_u.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MNCC__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU.");
break;
}
set_selection(other_value);
}

MNCC__PDU_template::MNCC__PDU_template()
{
}

MNCC__PDU_template::MNCC__PDU_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MNCC__PDU_template::MNCC__PDU_template(const MNCC__PDU& other_value)
{
copy_value(other_value);
}

MNCC__PDU_template::MNCC__PDU_template(const OPTIONAL<MNCC__PDU>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @MNCC_Types.MNCC_PDU from an unbound optional field.");
}
}

MNCC__PDU_template::MNCC__PDU_template(const MNCC__PDU_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MNCC__PDU_template::~MNCC__PDU_template()
{
clean_up();
}

MNCC__PDU_template& MNCC__PDU_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MNCC__PDU_template& MNCC__PDU_template::operator=(const MNCC__PDU& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MNCC__PDU_template& MNCC__PDU_template::operator=(const OPTIONAL<MNCC__PDU>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MNCC__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @MNCC_Types.MNCC_PDU.");
}
return *this;
}

MNCC__PDU_template& MNCC__PDU_template::operator=(const MNCC__PDU_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MNCC__PDU_template::match(const MNCC__PDU& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msg__type().is_bound()) return FALSE;
if(!single_value->field_msg__type.match(other_value.msg__type(), legacy))return FALSE;
if(!other_value.u().is_bound()) return FALSE;
if(!single_value->field_u.match(other_value.u(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU.");
}
return FALSE;
}

boolean MNCC__PDU_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msg__type.is_bound()) return TRUE;
if (single_value->field_u.is_bound()) return TRUE;
return FALSE;
}

boolean MNCC__PDU_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msg__type.is_value()) return FALSE;
if (!single_value->field_u.is_value()) return FALSE;
return TRUE;
}

void MNCC__PDU_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MNCC__PDU MNCC__PDU_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @MNCC_Types.MNCC_PDU.");
MNCC__PDU ret_val;
if (single_value->field_msg__type.is_bound()) {
ret_val.msg__type() = single_value->field_msg__type.valueof();
}
if (single_value->field_u.is_bound()) {
ret_val.u() = single_value->field_u.valueof();
}
return ret_val;
}

void MNCC__PDU_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @MNCC_Types.MNCC_PDU.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MNCC__PDU_template[list_length];
}

MNCC__PDU_template& MNCC__PDU_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @MNCC_Types.MNCC_PDU.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @MNCC_Types.MNCC_PDU.");
return value_list.list_value[list_index];
}

MNCC__MsgType_template& MNCC__PDU_template::msg__type()
{
set_specific();
return single_value->field_msg__type;
}

const MNCC__MsgType_template& MNCC__PDU_template::msg__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg_type of a non-specific template of type @MNCC_Types.MNCC_PDU.");
return single_value->field_msg__type;
}

MNCC__MsgUnion_template& MNCC__PDU_template::u()
{
set_specific();
return single_value->field_u;
}

const MNCC__MsgUnion_template& MNCC__PDU_template::u() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field u of a non-specific template of type @MNCC_Types.MNCC_PDU.");
return single_value->field_u;
}

int MNCC__PDU_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @MNCC_Types.MNCC_PDU containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU.");
  }
  return 0;
}

void MNCC__PDU_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msg_type := ");
single_value->field_msg__type.log();
TTCN_Logger::log_event_str(", u := ");
single_value->field_u.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MNCC__PDU_template::log_match(const MNCC__PDU& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msg__type.match(match_value.msg__type(), legacy)){
TTCN_Logger::log_logmatch_info(".msg_type");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_u.match(match_value.u(), legacy)){
TTCN_Logger::log_logmatch_info(".u");
single_value->field_u.log_match(match_value.u(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msg_type := ");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::log_event_str(", u := ");
single_value->field_u.log_match(match_value.u(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MNCC__PDU_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msg__type.encode_text(text_buf);
single_value->field_u.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @MNCC_Types.MNCC_PDU.");
}
}

void MNCC__PDU_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msg__type.decode_text(text_buf);
single_value->field_u.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MNCC__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @MNCC_Types.MNCC_PDU.");
}
}

void MNCC__PDU_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MNCC__PDU_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @MNCC_Types.MNCC_PDU has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) u().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "u")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          u().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @MNCC_Types.MNCC_PDU: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@MNCC_Types.MNCC_PDU");
  }
  is_ifpresent = param.get_ifpresent();
}

void MNCC__PDU_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msg__type.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU");
single_value->field_u.check_restriction(t_res, t_name ? t_name : "@MNCC_Types.MNCC_PDU");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@MNCC_Types.MNCC_PDU");
}

boolean MNCC__PDU_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MNCC__PDU_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

void int__encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(int__descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER int__decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(int__descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__ra_encoder(const GSM48__bcap__ra& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_ra' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__ra_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__ra_decoder(OCTETSTRING& input_stream, GSM48__bcap__ra& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_ra' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__ra_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__sig__access_encoder(const GSM48__bcap__sig__access& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_sig_access' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__sig__access_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__sig__access_decoder(OCTETSTRING& input_stream, GSM48__bcap__sig__access& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_sig_access' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__sig__access_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__user__rate_encoder(const GSM48__bcap__user__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_user_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__user__rate_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__user__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__user__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_user_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__user__rate_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__parity_encoder(const GSM48__bcap__parity& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_parity' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__parity_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__parity_decoder(OCTETSTRING& input_stream, GSM48__bcap__parity& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_parity' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__parity_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__interm__rate_encoder(const GSM48__bcap__interm__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_interm_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__interm__rate_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__interm__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__interm__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_interm_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__interm__rate_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__transp_encoder(const GSM48__bcap__transp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_transp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__transp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__transp_decoder(OCTETSTRING& input_stream, GSM48__bcap__transp& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_transp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__transp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__bcap__modem__type_encoder(const GSM48__bcap__modem__type& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_modem_type' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__bcap__modem__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__bcap__modem__type_decoder(OCTETSTRING& input_stream, GSM48__bcap__modem__type& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_modem_type' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__bcap__modem__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgType_encoder(const MNCC__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgType_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgType_decoder(OCTETSTRING& input_stream, MNCC__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgType_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_rate__adaptation_encoder(const GSM48__bcap__ra& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_ra' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_rate__adaptation_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_rate__adaptation_decoder(OCTETSTRING& input_stream, GSM48__bcap__ra& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_ra' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_rate__adaptation_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_sig__access_encoder(const GSM48__bcap__sig__access& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_sig_access' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_sig__access_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_sig__access_decoder(OCTETSTRING& input_stream, GSM48__bcap__sig__access& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_sig_access' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_sig__access_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_async_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_async_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_async_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_async_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_nr__stop__bits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_nr__stop__bits_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_nr__stop__bits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_nr__stop__bits_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_nr__data__bits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_nr__data__bits_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_nr__data__bits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_nr__data__bits_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_user__rate_encoder(const GSM48__bcap__user__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_user_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_user__rate_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_user__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__user__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_user_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_user__rate_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_parity_encoder(const GSM48__bcap__parity& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_parity' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_parity_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_parity_decoder(OCTETSTRING& input_stream, GSM48__bcap__parity& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_parity' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_parity_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_interm__rate_encoder(const GSM48__bcap__interm__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_interm_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_interm__rate_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_interm__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__interm__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_interm_rate' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_interm__rate_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_transp_encoder(const GSM48__bcap__transp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_transp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_transp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_transp_decoder(OCTETSTRING& input_stream, GSM48__bcap__transp& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_transp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_transp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_modem__type_encoder(const GSM48__bcap__modem__type& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_modem_type' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_modem__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_modem__type_decoder(OCTETSTRING& input_stream, GSM48__bcap__modem__type& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_bcap_modem_type' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_modem__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap__data_encoder(const MNCC__bearer__cap__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap__data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap__data_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap__data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__speech__vers_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__speech__vers_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__speech__vers_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__speech__vers_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__speech__vers_encoder(const MNCC__speech__vers& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_speech_vers' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__speech__vers_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__speech__vers_decoder(OCTETSTRING& input_stream, MNCC__speech__vers& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_speech_vers' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__speech__vers_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_transfer_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_transfer_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_transfer_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_transfer_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_mode_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_mode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_mode_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_mode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_coding_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_coding_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_coding_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_coding_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_radio_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_radio_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_radio_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_radio_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_speech__ctm_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_speech__ctm_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_speech__ctm_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_speech__ctm_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_speech__ver_encoder(const MNCC__speech__vers& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_speech_vers' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_speech__ver_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_speech__ver_decoder(OCTETSTRING& input_stream, MNCC__speech__vers& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_speech_vers' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_speech__ver_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_data_encoder(const MNCC__bearer__cap__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_data_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bearer__cap_encoder(const MNCC__bearer__cap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bearer__cap_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bearer__cap_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bearer__cap_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__type__of__number_encoder(const GSM48__type__of__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_type_of_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__type__of__number_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__type__of__number_decoder(OCTETSTRING& input_stream, GSM48__type__of__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_type_of_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__type__of__number_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_number__type_encoder(const GSM48__type__of__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_type_of_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_number__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_number__type_decoder(OCTETSTRING& input_stream, GSM48__type__of__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_type_of_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_number__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__num__plan__ind_encoder(const GSM48__num__plan__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_num_plan_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__num__plan__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__num__plan__ind_decoder(OCTETSTRING& input_stream, GSM48__num__plan__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_num_plan_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__num__plan__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_plan_encoder(const GSM48__num__plan__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_num_plan_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_plan_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_plan_decoder(OCTETSTRING& input_stream, GSM48__num__plan__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_num_plan_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_plan_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__present__ind_encoder(const GSM48__present__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_present_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__present__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__present__ind_decoder(OCTETSTRING& input_stream, GSM48__present__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_present_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__present__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_presence_encoder(const GSM48__present__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_present_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_presence_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_presence_decoder(OCTETSTRING& input_stream, GSM48__present__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_present_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_presence_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__screening__ind_encoder(const GSM48__screening__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_screening_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__screening__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__screening__ind_decoder(OCTETSTRING& input_stream, GSM48__screening__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_screening_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__screening__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_screen_encoder(const GSM48__screening__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_screening_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_screen_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_screen_decoder(OCTETSTRING& input_stream, GSM48__screening__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_screening_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_screen_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_number_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_number_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_number_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_number_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__number_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__number_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__number_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__number_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__cause__coding_encoder(const GSM48__cause__coding& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_coding' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__cause__coding_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__cause__coding_decoder(OCTETSTRING& input_stream, GSM48__cause__coding& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_coding' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__cause__coding_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void GSM48__cause__loc_encoder(const GSM48__cause__loc& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_loc' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(GSM48__cause__loc_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER GSM48__cause__loc_decoder(OCTETSTRING& input_stream, GSM48__cause__loc& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_loc' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(GSM48__cause__loc_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

MNCC__number_template ts__MNCC__number(const CHARSTRING& number, const GSM48__type__of__number& ton, const GSM48__num__plan__ind& npi, const GSM48__present__ind& pres, const GSM48__screening__ind& screen)
{
TTCN_Location current_location("MNCC_Types.ttcn", 248, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_number");
MNCC__number_template ret_val;
ret_val.number__type() = ton;
ret_val.plan() = npi;
ret_val.presence() = pres;
ret_val.screen() = screen;
ret_val.number() = number;
return ret_val;
}

MNCC__number_template tr__MNCC__number(const CHARSTRING_template& number, const GSM48__type__of__number_template& ton, const GSM48__num__plan__ind_template& npi, const GSM48__present__ind_template& pres, const GSM48__screening__ind_template& screen)
{
TTCN_Location current_location("MNCC_Types.ttcn", 260, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_number");
MNCC__number_template ret_val;
ret_val.number__type() = ton;
ret_val.plan() = npi;
ret_val.presence() = pres;
ret_val.screen() = screen;
ret_val.number() = number;
return ret_val;
}

void MNCC__cause_location_encoder(const GSM48__cause__loc& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_loc' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_location_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_location_decoder(OCTETSTRING& input_stream, GSM48__cause__loc& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_loc' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_location_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_coding_encoder(const GSM48__cause__coding& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_coding' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_coding_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_coding_decoder(OCTETSTRING& input_stream, GSM48__cause__coding& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.GSM48_cause_coding' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_coding_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_rec_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_rec_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_rec_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_rec_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_rec__val_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_rec__val_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_rec__val_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_rec__val_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_val_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_val_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_val_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_val_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_diag_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_diag_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_diag_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_diag_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cause_encoder(const MNCC__cause& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cause' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cause_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cause_decoder(OCTETSTRING& input_stream, MNCC__cause& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cause' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cause_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

MNCC__cause_template ts__MNCC__cause(const INTEGER& val, const GSM48__cause__loc& loc, const GSM48__cause__coding& coding, const OCTETSTRING& diag)
{
TTCN_Location current_location("MNCC_Types.ttcn", 284, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_cause");
MNCC__cause_template ret_val;
ret_val.location() = loc;
ret_val.coding() = coding;
ret_val.rec() = 0;
ret_val.rec__val() = 0;
ret_val.val() = val;
ret_val.diag() = diag;
return ret_val;
}

void MNCC__useruser_proto_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__useruser_proto_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__useruser_proto_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__useruser_proto_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__useruser_info_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__useruser_info_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__useruser_info_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__useruser_info_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__useruser_encoder(const MNCC__useruser& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_useruser' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__useruser_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__useruser_decoder(OCTETSTRING& input_stream, MNCC__useruser& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_useruser' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__useruser_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__progress_coding_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__progress_coding_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__progress_coding_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__progress_coding_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__progress_location_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__progress_location_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__progress_location_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__progress_location_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__progress_descr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__progress_descr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__progress_descr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__progress_descr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__progress_encoder(const MNCC__progress& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_progress' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__progress_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__progress_decoder(OCTETSTRING& input_stream, MNCC__progress& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_progress' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__progress_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cccap_dtmf_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cccap_dtmf_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cccap_dtmf_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cccap_dtmf_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cccap_pcp_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cccap_pcp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cccap_pcp_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cccap_pcp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__cccap_encoder(const MNCC__cccap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cccap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__cccap_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__cccap_decoder(OCTETSTRING& input_stream, MNCC__cccap& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cccap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__cccap_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__notify_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__notify_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__notify_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__notify_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__keypad_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__keypad_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__keypad_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__keypad_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__bcap_encoder(const MNCC__bcap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bcap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__bcap_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__bcap_decoder(OCTETSTRING& input_stream, MNCC__bcap& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bcap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__bcap_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_callref_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_callref_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_clir__sup_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_clir__sup_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_clir__sup_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_clir__sup_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_clir__inv_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_clir__inv_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_clir__inv_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_clir__inv_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_more_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_more_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_more_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_more_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_notify_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_notify_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_notify_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_notify_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_imsi_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_imsi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_imsi_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_imsi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_lchan__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_lchan__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_lchan__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_lchan__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_lchan__mode_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_lchan__mode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_lchan__mode_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_lchan__mode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_bearer__cap_encoder(const MNCC__bearer__cap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_bearer__cap_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_bearer__cap_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_bearer_cap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_bearer__cap_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_called_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_called_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_called_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_called_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_calling_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_calling_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_calling_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_calling_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_redirecting_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_redirecting_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_redirecting_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_redirecting_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_connected_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_connected_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_connected_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_number' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_connected_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_cause_encoder(const MNCC__cause& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cause' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_cause_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_cause_decoder(OCTETSTRING& input_stream, MNCC__cause& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cause' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_cause_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_progress_encoder(const MNCC__progress& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_progress' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_progress_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_progress_decoder(OCTETSTRING& input_stream, MNCC__progress& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_progress' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_progress_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_useruser_encoder(const MNCC__useruser& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_useruser' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_useruser_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_useruser_decoder(OCTETSTRING& input_stream, MNCC__useruser& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_useruser' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_useruser_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_facility_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_facility_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_facility_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_facility_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_cccap_encoder(const MNCC__cccap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cccap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_cccap_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_cccap_decoder(OCTETSTRING& input_stream, MNCC__cccap& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_cccap' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_cccap_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_ssversion_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_ssversion_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_ssversion_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_ssversion_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_signal_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_signal_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_signal_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_signal_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_keypad_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_keypad_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_keypad_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_keypad_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_emergency_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_emergency_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_emergency_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_emergency_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Signal_encoder(const MNCC__PDU__Signal& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Signal' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Signal_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Signal_decoder(OCTETSTRING& input_stream, MNCC__PDU__Signal& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Signal' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Signal_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Data_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Data_callref_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Data_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Data_callref_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Data_data_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Data_data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Data_data_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Data_data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Data_encoder(const MNCC__PDU__Data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Data_decoder(OCTETSTRING& input_stream, MNCC__PDU__Data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_callref_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_callref_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_ip_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_ip_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_ip_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_ip_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_rtp__port_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_rtp__port_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_rtp__port_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_rtp__port_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_payload__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_payload__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_payload__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_payload__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_payload__msg__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_payload__msg__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_payload__msg__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_payload__msg__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Rtp_encoder(const MNCC__PDU__Rtp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Rtp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Rtp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Rtp_decoder(OCTETSTRING& input_stream, MNCC__PDU__Rtp& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Rtp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Rtp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_version_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_version_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_version_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_version_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_mncc__size_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_mncc__size_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_mncc__size_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_mncc__size_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_data__frame__size_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_data__frame__size_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_data__frame__size_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_data__frame__size_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_called__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_called__offset_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_called__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_called__offset_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_signal__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_signal__offset_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_signal__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_signal__offset_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_emergency__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_emergency__offset_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_emergency__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_emergency__offset_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_lchan__type__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_lchan__type__offset_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_lchan__type__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_lchan__type__offset_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU__Hello_encoder(const MNCC__PDU__Hello& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Hello' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU__Hello_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU__Hello_decoder(OCTETSTRING& input_stream, MNCC__PDU__Hello& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Hello' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU__Hello_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgUnion_signal_encoder(const MNCC__PDU__Signal& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Signal' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgUnion_signal_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgUnion_signal_decoder(OCTETSTRING& input_stream, MNCC__PDU__Signal& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Signal' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgUnion_signal_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgUnion_data_encoder(const MNCC__PDU__Data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgUnion_data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgUnion_data_decoder(OCTETSTRING& input_stream, MNCC__PDU__Data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgUnion_data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgUnion_rtp_encoder(const MNCC__PDU__Rtp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Rtp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgUnion_rtp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgUnion_rtp_decoder(OCTETSTRING& input_stream, MNCC__PDU__Rtp& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Rtp' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgUnion_rtp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgUnion_hello_encoder(const MNCC__PDU__Hello& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Hello' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgUnion_hello_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgUnion_hello_decoder(OCTETSTRING& input_stream, MNCC__PDU__Hello& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU_Hello' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgUnion_hello_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__MsgUnion_encoder(const MNCC__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__MsgUnion_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__MsgUnion_decoder(OCTETSTRING& input_stream, MNCC__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__MsgUnion_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU_msg__type_encoder(const MNCC__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU_msg__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU_msg__type_decoder(OCTETSTRING& input_stream, MNCC__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU_msg__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU_u_encoder(const MNCC__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU_u_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU_u_decoder(OCTETSTRING& input_stream, MNCC__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU_u_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void MNCC__PDU_encoder(const MNCC__PDU& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(MNCC__PDU_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER MNCC__PDU_decoder(OCTETSTRING& input_stream, MNCC__PDU& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@MNCC_Types.MNCC_PDU' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(MNCC__PDU_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

MNCC__PDU_template ts__MNCC__HELLO(const INTEGER& version)
{
TTCN_Location current_location("MNCC_Types.ttcn", 408, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_HELLO");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SOCKET__HELLO;
{
MNCC__PDU__Hello_template& tmp_1 = ret_val.u().hello();
tmp_1.version() = version;
tmp_1.mncc__size() = 836;
tmp_1.data__frame__size() = 8;
tmp_1.called__offset() = 104;
tmp_1.signal__offset() = 796;
tmp_1.emergency__offset() = 812;
tmp_1.lchan__type__offset() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__Sign(const MNCC__MsgType& msg__type, const MNCC__PDU__Signal& sign)
{
TTCN_Location current_location("MNCC_Types.ttcn", 423, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_Sign");
MNCC__PDU_template ret_val;
ret_val.msg__type() = msg__type;
ret_val.u().signal() = sign;
return ret_val;
}

MNCC__PDU_template ts__MNCC__SIMPLE(const MNCC__MsgType& msg__type, const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 430, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SIMPLE");
MNCC__PDU_template ret_val;
ret_val.msg__type() = msg__type;
{
MNCC__PDU__Signal_template& tmp_2 = ret_val.u().signal();
tmp_2.callref() = call__id;
tmp_2.bearer__cap() = OMIT_VALUE;
tmp_2.called() = OMIT_VALUE;
tmp_2.calling() = OMIT_VALUE;
tmp_2.redirecting() = OMIT_VALUE;
tmp_2.connected() = OMIT_VALUE;
tmp_2.cause() = OMIT_VALUE;
tmp_2.progress() = OMIT_VALUE;
tmp_2.useruser() = OMIT_VALUE;
tmp_2.facility() = OMIT_VALUE;
tmp_2.cccap() = OMIT_VALUE;
tmp_2.ssversion() = OMIT_VALUE;
tmp_2.clir__sup() = 0;
tmp_2.clir__inv() = 0;
tmp_2.signal() = OMIT_VALUE;
tmp_2.keypad() = OMIT_VALUE;
tmp_2.more() = 0;
tmp_2.notify() = 0;
tmp_2.emergency() = OMIT_VALUE;
tmp_2.imsi() = cs_0;
tmp_2.lchan__type() = 0;
tmp_2.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SIMPLE(const MNCC__MsgType_template& msg__type, const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 460, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SIMPLE");
MNCC__PDU_template ret_val;
ret_val.msg__type() = msg__type;
{
MNCC__PDU__Signal_template& tmp_3 = ret_val.u().signal();
tmp_3.callref() = call__id;
tmp_3.bearer__cap() = OMIT_VALUE;
tmp_3.called() = OMIT_VALUE;
tmp_3.calling() = OMIT_VALUE;
tmp_3.redirecting() = OMIT_VALUE;
tmp_3.connected() = OMIT_VALUE;
tmp_3.cause() = OMIT_VALUE;
tmp_3.progress() = OMIT_VALUE;
tmp_3.useruser() = OMIT_VALUE;
tmp_3.facility() = OMIT_VALUE;
tmp_3.cccap() = OMIT_VALUE;
tmp_3.ssversion() = OMIT_VALUE;
tmp_3.clir__sup() = 0;
tmp_3.clir__inv() = 0;
tmp_3.signal() = OMIT_VALUE;
tmp_3.keypad() = OMIT_VALUE;
tmp_3.more() = 0;
tmp_3.notify() = 0;
tmp_3.emergency() = ANY_OR_OMIT;
tmp_3.imsi() = ANY_VALUE;
tmp_3.lchan__type() = ANY_VALUE;
tmp_3.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__SETUP__req(const INTEGER& call__id, const CHARSTRING& called, const CHARSTRING& calling, const CHARSTRING& imsi)
{
TTCN_Location current_location("MNCC_Types.ttcn", 493, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SETUP_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__REQ;
{
MNCC__PDU__Signal_template& tmp_4 = ret_val.u().signal();
tmp_4.callref() = call__id;
tmp_4.bearer__cap() = ts__MNCC__bcap__voice;
tmp_4.called() = ts__MNCC__number(called, ts__MNCC__number_ton_defval, ts__MNCC__number_npi_defval, ts__MNCC__number_pres_defval, ts__MNCC__number_screen_defval).valueof();
tmp_4.calling() = ts__MNCC__number(calling, ts__MNCC__number_ton_defval, ts__MNCC__number_npi_defval, ts__MNCC__number_pres_defval, ts__MNCC__number_screen_defval).valueof();
tmp_4.redirecting() = OMIT_VALUE;
tmp_4.connected() = OMIT_VALUE;
tmp_4.cause() = OMIT_VALUE;
tmp_4.progress() = OMIT_VALUE;
tmp_4.useruser() = OMIT_VALUE;
tmp_4.facility() = OMIT_VALUE;
tmp_4.cccap() = OMIT_VALUE;
tmp_4.ssversion() = OMIT_VALUE;
tmp_4.clir__sup() = 0;
tmp_4.clir__inv() = 0;
tmp_4.signal() = OMIT_VALUE;
tmp_4.keypad() = OMIT_VALUE;
tmp_4.more() = 0;
tmp_4.notify() = 0;
tmp_4.emergency() = OMIT_VALUE;
tmp_4.imsi() = imsi;
tmp_4.lchan__type() = 0;
tmp_4.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__req(const INTEGER_template& call__id, const CHARSTRING_template& called, const CHARSTRING_template& calling, const CHARSTRING_template& imsi)
{
TTCN_Location current_location("MNCC_Types.ttcn", 522, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__REQ;
{
MNCC__PDU__Signal_template& tmp_5 = ret_val.u().signal();
tmp_5.callref() = call__id;
tmp_5.bearer__cap() = ANY_OR_OMIT;
tmp_5.called() = tr__MNCC__number(called, tr__MNCC__number_ton_defval, tr__MNCC__number_npi_defval, tr__MNCC__number_pres_defval, tr__MNCC__number_screen_defval);
tmp_5.calling() = tr__MNCC__number(calling, tr__MNCC__number_ton_defval, tr__MNCC__number_npi_defval, tr__MNCC__number_pres_defval, tr__MNCC__number_screen_defval);
tmp_5.redirecting() = ANY_OR_OMIT;
tmp_5.connected() = OMIT_VALUE;
tmp_5.cause() = OMIT_VALUE;
tmp_5.progress() = ANY_OR_OMIT;
tmp_5.useruser() = ANY_OR_OMIT;
tmp_5.facility() = ANY_OR_OMIT;
tmp_5.cccap() = OMIT_VALUE;
tmp_5.ssversion() = OMIT_VALUE;
tmp_5.clir__sup() = 0;
tmp_5.clir__inv() = 0;
tmp_5.signal() = ANY_OR_OMIT;
tmp_5.keypad() = OMIT_VALUE;
tmp_5.more() = 0;
tmp_5.notify() = 0;
tmp_5.emergency() = ANY_OR_OMIT;
tmp_5.imsi() = imsi;
tmp_5.lchan__type() = ANY_VALUE;
tmp_5.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__SETUP__rsp(const INTEGER& call__id, const CHARSTRING& imsi, const MNCC__number_template& connected)
{
TTCN_Location current_location("MNCC_Types.ttcn", 557, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SETUP_rsp");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__RSP;
{
MNCC__PDU__Signal_template& tmp_6 = ret_val.u().signal();
tmp_6.callref() = call__id;
tmp_6.bearer__cap() = OMIT_VALUE;
tmp_6.called() = OMIT_VALUE;
tmp_6.calling() = OMIT_VALUE;
tmp_6.redirecting() = OMIT_VALUE;
tmp_6.connected() = connected;
tmp_6.cause() = OMIT_VALUE;
tmp_6.progress() = OMIT_VALUE;
tmp_6.useruser() = OMIT_VALUE;
tmp_6.facility() = OMIT_VALUE;
tmp_6.cccap() = OMIT_VALUE;
tmp_6.ssversion() = OMIT_VALUE;
tmp_6.clir__sup() = 0;
tmp_6.clir__inv() = 0;
tmp_6.signal() = OMIT_VALUE;
tmp_6.keypad() = OMIT_VALUE;
tmp_6.more() = 0;
tmp_6.notify() = 0;
tmp_6.emergency() = OMIT_VALUE;
tmp_6.imsi() = imsi;
tmp_6.lchan__type() = 0;
tmp_6.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__rsp(const INTEGER_template& call__id, const CHARSTRING_template& imsi, const MNCC__number_template& connected)
{
TTCN_Location current_location("MNCC_Types.ttcn", 587, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_rsp");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__RSP;
{
MNCC__PDU__Signal_template& tmp_7 = ret_val.u().signal();
tmp_7.callref() = call__id;
tmp_7.bearer__cap() = OMIT_VALUE;
tmp_7.called() = OMIT_VALUE;
tmp_7.calling() = OMIT_VALUE;
tmp_7.redirecting() = OMIT_VALUE;
tmp_7.connected() = connected;
tmp_7.cause() = OMIT_VALUE;
tmp_7.progress() = OMIT_VALUE;
tmp_7.useruser() = ANY_OR_OMIT;
tmp_7.facility() = ANY_OR_OMIT;
tmp_7.cccap() = OMIT_VALUE;
tmp_7.ssversion() = ANY_OR_OMIT;
tmp_7.clir__sup() = 0;
tmp_7.clir__inv() = 0;
tmp_7.signal() = OMIT_VALUE;
tmp_7.keypad() = OMIT_VALUE;
tmp_7.more() = 0;
tmp_7.notify() = 0;
tmp_7.emergency() = OMIT_VALUE;
tmp_7.imsi() = imsi;
tmp_7.lchan__type() = ANY_VALUE;
tmp_7.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__ind(const INTEGER_template& call__id, const MNCC__number_template& called, const MNCC__number_template& calling, const CHARSTRING_template& imsi)
{
TTCN_Location current_location("MNCC_Types.ttcn", 621, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__IND;
{
MNCC__PDU__Signal_template& tmp_8 = ret_val.u().signal();
tmp_8.callref() = call__id;
tmp_8.bearer__cap() = ANY_VALUE;
tmp_8.called() = called;
tmp_8.calling() = calling;
tmp_8.redirecting() = OMIT_VALUE;
tmp_8.connected() = OMIT_VALUE;
tmp_8.cause() = OMIT_VALUE;
tmp_8.progress() = OMIT_VALUE;
tmp_8.useruser() = ANY_OR_OMIT;
tmp_8.facility() = ANY_OR_OMIT;
tmp_8.cccap() = ANY_OR_OMIT;
tmp_8.ssversion() = ANY_OR_OMIT;
tmp_8.clir__sup() = ANY_VALUE;
tmp_8.clir__inv() = ANY_VALUE;
tmp_8.signal() = OMIT_VALUE;
tmp_8.keypad() = OMIT_VALUE;
tmp_8.more() = 0;
tmp_8.notify() = 0;
tmp_8.emergency() = ANY_OR_OMIT;
tmp_8.imsi() = imsi;
tmp_8.lchan__type() = ANY_VALUE;
tmp_8.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__SETUP__ind(const INTEGER& call__id, const MNCC__number& called, const MNCC__number_template& calling, const CHARSTRING_template& imsi, const MNCC__bearer__cap_template& bcap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 651, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SETUP_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__IND;
{
MNCC__PDU__Signal_template& tmp_9 = ret_val.u().signal();
tmp_9.callref() = call__id;
tmp_9.bearer__cap() = bcap.valueof();
tmp_9.called() = called;
tmp_9.calling() = calling;
tmp_9.redirecting() = OMIT_VALUE;
tmp_9.connected() = OMIT_VALUE;
tmp_9.cause() = OMIT_VALUE;
tmp_9.progress() = OMIT_VALUE;
tmp_9.useruser() = OMIT_VALUE;
tmp_9.facility() = OMIT_VALUE;
tmp_9.cccap() = OMIT_VALUE;
tmp_9.ssversion() = OMIT_VALUE;
tmp_9.clir__sup() = 0;
tmp_9.clir__inv() = 0;
tmp_9.signal() = OMIT_VALUE;
tmp_9.keypad() = OMIT_VALUE;
tmp_9.more() = 0;
tmp_9.notify() = 0;
tmp_9.emergency() = OMIT_VALUE;
tmp_9.imsi() = imsi;
tmp_9.lchan__type() = 0;
tmp_9.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__SETUP__CNF(const INTEGER& call__id, const MNCC__number_template& connected)
{
TTCN_Location current_location("MNCC_Types.ttcn", 685, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SETUP_CNF");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__CNF;
{
MNCC__PDU__Signal_template& tmp_10 = ret_val.u().signal();
tmp_10.callref() = call__id;
tmp_10.bearer__cap() = OMIT_VALUE;
tmp_10.called() = OMIT_VALUE;
tmp_10.calling() = OMIT_VALUE;
tmp_10.redirecting() = OMIT_VALUE;
tmp_10.connected() = connected;
tmp_10.cause() = OMIT_VALUE;
tmp_10.progress() = OMIT_VALUE;
tmp_10.useruser() = OMIT_VALUE;
tmp_10.facility() = OMIT_VALUE;
tmp_10.cccap() = OMIT_VALUE;
tmp_10.ssversion() = OMIT_VALUE;
tmp_10.clir__sup() = 0;
tmp_10.clir__inv() = 0;
tmp_10.signal() = OMIT_VALUE;
tmp_10.keypad() = OMIT_VALUE;
tmp_10.more() = 0;
tmp_10.notify() = 0;
tmp_10.emergency() = OMIT_VALUE;
tmp_10.imsi() = cs_0;
tmp_10.lchan__type() = 0;
tmp_10.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__cnf(const INTEGER& call__id, const MNCC__number_template& connected)
{
TTCN_Location current_location("MNCC_Types.ttcn", 716, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_cnf");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__SETUP__CNF;
{
MNCC__PDU__Signal_template& tmp_11 = ret_val.u().signal();
tmp_11.callref() = call__id;
tmp_11.bearer__cap() = OMIT_VALUE;
tmp_11.called() = OMIT_VALUE;
tmp_11.calling() = OMIT_VALUE;
tmp_11.redirecting() = OMIT_VALUE;
tmp_11.connected() = connected;
tmp_11.cause() = OMIT_VALUE;
tmp_11.progress() = ANY_OR_OMIT;
tmp_11.useruser() = ANY_OR_OMIT;
tmp_11.facility() = ANY_OR_OMIT;
tmp_11.cccap() = OMIT_VALUE;
tmp_11.ssversion() = OMIT_VALUE;
tmp_11.clir__sup() = 0;
tmp_11.clir__inv() = 0;
tmp_11.signal() = OMIT_VALUE;
tmp_11.keypad() = OMIT_VALUE;
tmp_11.more() = 0;
tmp_11.notify() = 0;
tmp_11.emergency() = ANY_OR_OMIT;
tmp_11.imsi() = ANY_VALUE;
tmp_11.lchan__type() = ANY_VALUE;
tmp_11.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__COMPL__req(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 747, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_COMPL_req");
MNCC__PDU_template ret_val;
ret_val = tr__MNCC__SIMPLE(MNCC__MsgType_template(MNCC__MsgType::MNCC__SETUP__COMPL__REQ), call__id);
return ret_val;
}

MNCC__PDU_template tr__MNCC__SETUP__COMPL__ind(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 751, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_SETUP_COMPL_ind");
MNCC__PDU_template ret_val;
ret_val = tr__MNCC__SIMPLE(MNCC__MsgType_template(MNCC__MsgType::MNCC__SETUP__COMPL__IND), call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__SETUP__COMPL__ind(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 753, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SETUP_COMPL_ind");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE(MNCC__MsgType::MNCC__SETUP__COMPL__IND, call__id);
return ret_val;
}

MNCC__PDU_template tr__MNCC__REJ__req(const INTEGER_template& call__id, const MNCC__cause_template& cause)
{
TTCN_Location current_location("MNCC_Types.ttcn", 757, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_REJ_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REJ__REQ;
{
MNCC__PDU__Signal_template& tmp_12 = ret_val.u().signal();
tmp_12.callref() = call__id;
tmp_12.bearer__cap() = OMIT_VALUE;
tmp_12.called() = OMIT_VALUE;
tmp_12.calling() = OMIT_VALUE;
tmp_12.redirecting() = OMIT_VALUE;
tmp_12.connected() = OMIT_VALUE;
tmp_12.cause() = cause;
tmp_12.progress() = OMIT_VALUE;
tmp_12.useruser() = ANY_OR_OMIT;
tmp_12.facility() = ANY_OR_OMIT;
tmp_12.cccap() = OMIT_VALUE;
tmp_12.ssversion() = OMIT_VALUE;
tmp_12.clir__sup() = 0;
tmp_12.clir__inv() = 0;
tmp_12.signal() = OMIT_VALUE;
tmp_12.keypad() = OMIT_VALUE;
tmp_12.more() = 0;
tmp_12.notify() = 0;
tmp_12.emergency() = OMIT_VALUE;
tmp_12.imsi() = ANY_VALUE;
tmp_12.lchan__type() = ANY_VALUE;
tmp_12.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__REJ__ind(const INTEGER& call__id, const MNCC__cause_template& cause)
{
TTCN_Location current_location("MNCC_Types.ttcn", 788, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_REJ_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REJ__IND;
{
MNCC__PDU__Signal_template& tmp_13 = ret_val.u().signal();
tmp_13.callref() = call__id;
tmp_13.bearer__cap() = OMIT_VALUE;
tmp_13.called() = OMIT_VALUE;
tmp_13.calling() = OMIT_VALUE;
tmp_13.redirecting() = OMIT_VALUE;
tmp_13.connected() = OMIT_VALUE;
tmp_13.cause() = cause;
tmp_13.progress() = OMIT_VALUE;
tmp_13.useruser() = OMIT_VALUE;
tmp_13.facility() = OMIT_VALUE;
tmp_13.cccap() = OMIT_VALUE;
tmp_13.ssversion() = OMIT_VALUE;
tmp_13.clir__sup() = 0;
tmp_13.clir__inv() = 0;
tmp_13.signal() = OMIT_VALUE;
tmp_13.keypad() = OMIT_VALUE;
tmp_13.more() = 0;
tmp_13.notify() = 0;
tmp_13.emergency() = OMIT_VALUE;
tmp_13.imsi() = cs_0;
tmp_13.lchan__type() = 0;
tmp_13.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__CALL__CONF__ind(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__cause_template& cause, const MNCC__cccap_template& cccap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 819, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_CALL_CONF_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__CALL__CONF__IND;
{
MNCC__PDU__Signal_template& tmp_14 = ret_val.u().signal();
tmp_14.callref() = call__id;
tmp_14.bearer__cap() = bcap;
tmp_14.called() = OMIT_VALUE;
tmp_14.calling() = OMIT_VALUE;
tmp_14.redirecting() = OMIT_VALUE;
tmp_14.connected() = OMIT_VALUE;
tmp_14.cause() = cause;
tmp_14.progress() = OMIT_VALUE;
tmp_14.useruser() = OMIT_VALUE;
tmp_14.facility() = OMIT_VALUE;
tmp_14.cccap() = cccap;
tmp_14.ssversion() = OMIT_VALUE;
tmp_14.clir__sup() = 0;
tmp_14.clir__inv() = 0;
tmp_14.signal() = OMIT_VALUE;
tmp_14.keypad() = OMIT_VALUE;
tmp_14.more() = 0;
tmp_14.notify() = 0;
tmp_14.emergency() = OMIT_VALUE;
tmp_14.imsi() = ANY_VALUE;
tmp_14.lchan__type() = ANY_VALUE;
tmp_14.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__CALL__CONF__ind(const INTEGER& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__cause_template& cause, const MNCC__cccap_template& cccap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 850, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_CALL_CONF_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__CALL__CONF__IND;
{
MNCC__PDU__Signal_template& tmp_15 = ret_val.u().signal();
tmp_15.callref() = call__id;
tmp_15.bearer__cap() = bcap;
tmp_15.called() = OMIT_VALUE;
tmp_15.calling() = OMIT_VALUE;
tmp_15.redirecting() = OMIT_VALUE;
tmp_15.connected() = OMIT_VALUE;
tmp_15.cause() = cause;
tmp_15.progress() = OMIT_VALUE;
tmp_15.useruser() = OMIT_VALUE;
tmp_15.facility() = OMIT_VALUE;
tmp_15.cccap() = cccap;
tmp_15.ssversion() = OMIT_VALUE;
tmp_15.clir__sup() = 0;
tmp_15.clir__inv() = 0;
tmp_15.signal() = OMIT_VALUE;
tmp_15.keypad() = OMIT_VALUE;
tmp_15.more() = 0;
tmp_15.notify() = 0;
tmp_15.emergency() = OMIT_VALUE;
tmp_15.imsi() = cs_0;
tmp_15.lchan__type() = 0;
tmp_15.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__CALL__PROC__req(const INTEGER& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__cccap_template& cccap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 885, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_CALL_PROC_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__CALL__PROC__REQ;
{
MNCC__PDU__Signal_template& tmp_16 = ret_val.u().signal();
tmp_16.callref() = call__id;
tmp_16.bearer__cap() = bcap;
tmp_16.called() = OMIT_VALUE;
tmp_16.calling() = OMIT_VALUE;
tmp_16.redirecting() = OMIT_VALUE;
tmp_16.connected() = OMIT_VALUE;
tmp_16.cause() = OMIT_VALUE;
tmp_16.progress() = prog;
tmp_16.useruser() = OMIT_VALUE;
tmp_16.facility() = fac;
tmp_16.cccap() = cccap;
tmp_16.ssversion() = OMIT_VALUE;
tmp_16.clir__sup() = 0;
tmp_16.clir__inv() = 0;
tmp_16.signal() = OMIT_VALUE;
tmp_16.keypad() = OMIT_VALUE;
tmp_16.more() = 0;
tmp_16.notify() = 0;
tmp_16.emergency() = OMIT_VALUE;
tmp_16.imsi() = cs_0;
tmp_16.lchan__type() = 0;
tmp_16.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__CALL__PROC__req(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__cccap_template& cccap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 917, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_CALL_PROC_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__CALL__PROC__REQ;
{
MNCC__PDU__Signal_template& tmp_17 = ret_val.u().signal();
tmp_17.callref() = call__id;
tmp_17.bearer__cap() = bcap;
tmp_17.called() = OMIT_VALUE;
tmp_17.calling() = OMIT_VALUE;
tmp_17.redirecting() = OMIT_VALUE;
tmp_17.connected() = OMIT_VALUE;
tmp_17.cause() = OMIT_VALUE;
tmp_17.progress() = prog;
tmp_17.useruser() = OMIT_VALUE;
tmp_17.facility() = fac;
tmp_17.cccap() = cccap;
tmp_17.ssversion() = OMIT_VALUE;
tmp_17.clir__sup() = 0;
tmp_17.clir__inv() = 0;
tmp_17.signal() = OMIT_VALUE;
tmp_17.keypad() = OMIT_VALUE;
tmp_17.more() = 0;
tmp_17.notify() = 0;
tmp_17.emergency() = OMIT_VALUE;
tmp_17.imsi() = ANY_VALUE;
tmp_17.lchan__type() = ANY_VALUE;
tmp_17.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__PROGRESS__req(const INTEGER& call__id, const MNCC__progress& prog, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 953, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_PROGRESS_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__PROGRESS__REQ;
{
MNCC__PDU__Signal_template& tmp_18 = ret_val.u().signal();
tmp_18.callref() = call__id;
tmp_18.bearer__cap() = OMIT_VALUE;
tmp_18.called() = OMIT_VALUE;
tmp_18.calling() = OMIT_VALUE;
tmp_18.redirecting() = OMIT_VALUE;
tmp_18.connected() = OMIT_VALUE;
tmp_18.cause() = OMIT_VALUE;
tmp_18.progress() = prog;
tmp_18.useruser() = uu;
tmp_18.facility() = OMIT_VALUE;
tmp_18.cccap() = OMIT_VALUE;
tmp_18.ssversion() = OMIT_VALUE;
tmp_18.clir__sup() = 0;
tmp_18.clir__inv() = 0;
tmp_18.signal() = OMIT_VALUE;
tmp_18.keypad() = OMIT_VALUE;
tmp_18.more() = 0;
tmp_18.notify() = 0;
tmp_18.emergency() = OMIT_VALUE;
tmp_18.imsi() = cs_0;
tmp_18.lchan__type() = 0;
tmp_18.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__ALERT__req(const INTEGER& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 985, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_ALERT_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__ALERT__REQ;
{
MNCC__PDU__Signal_template& tmp_19 = ret_val.u().signal();
tmp_19.callref() = call__id;
tmp_19.bearer__cap() = OMIT_VALUE;
tmp_19.called() = OMIT_VALUE;
tmp_19.calling() = OMIT_VALUE;
tmp_19.redirecting() = OMIT_VALUE;
tmp_19.connected() = OMIT_VALUE;
tmp_19.cause() = OMIT_VALUE;
tmp_19.progress() = prog;
tmp_19.useruser() = uu;
tmp_19.facility() = fac;
tmp_19.cccap() = OMIT_VALUE;
tmp_19.ssversion() = OMIT_VALUE;
tmp_19.clir__sup() = 0;
tmp_19.clir__inv() = 0;
tmp_19.signal() = OMIT_VALUE;
tmp_19.keypad() = OMIT_VALUE;
tmp_19.more() = 0;
tmp_19.notify() = 0;
tmp_19.emergency() = OMIT_VALUE;
tmp_19.imsi() = cs_0;
tmp_19.lchan__type() = 0;
tmp_19.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__ALERT__req(const INTEGER_template& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1016, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_ALERT_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__ALERT__REQ;
{
MNCC__PDU__Signal_template& tmp_20 = ret_val.u().signal();
tmp_20.callref() = call__id;
tmp_20.bearer__cap() = OMIT_VALUE;
tmp_20.called() = OMIT_VALUE;
tmp_20.calling() = OMIT_VALUE;
tmp_20.redirecting() = OMIT_VALUE;
tmp_20.connected() = OMIT_VALUE;
tmp_20.cause() = OMIT_VALUE;
tmp_20.progress() = prog;
tmp_20.useruser() = uu;
tmp_20.facility() = fac;
tmp_20.cccap() = OMIT_VALUE;
tmp_20.ssversion() = OMIT_VALUE;
tmp_20.clir__sup() = 0;
tmp_20.clir__inv() = 0;
tmp_20.signal() = OMIT_VALUE;
tmp_20.keypad() = OMIT_VALUE;
tmp_20.more() = 0;
tmp_20.notify() = 0;
tmp_20.emergency() = OMIT_VALUE;
tmp_20.imsi() = ANY_VALUE;
tmp_20.lchan__type() = ANY_VALUE;
tmp_20.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__ALERT__ind(const INTEGER_template& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1052, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_ALERT_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__ALERT__IND;
{
MNCC__PDU__Signal_template& tmp_21 = ret_val.u().signal();
tmp_21.callref() = call__id;
tmp_21.bearer__cap() = OMIT_VALUE;
tmp_21.called() = OMIT_VALUE;
tmp_21.calling() = OMIT_VALUE;
tmp_21.redirecting() = OMIT_VALUE;
tmp_21.connected() = OMIT_VALUE;
tmp_21.cause() = OMIT_VALUE;
tmp_21.progress() = prog;
tmp_21.useruser() = uu;
tmp_21.facility() = fac;
tmp_21.cccap() = OMIT_VALUE;
tmp_21.ssversion() = OMIT_VALUE;
tmp_21.clir__sup() = 0;
tmp_21.clir__inv() = 0;
tmp_21.signal() = OMIT_VALUE;
tmp_21.keypad() = OMIT_VALUE;
tmp_21.more() = 0;
tmp_21.notify() = 0;
tmp_21.emergency() = ANY_OR_OMIT;
tmp_21.imsi() = ANY_VALUE;
tmp_21.lchan__type() = ANY_VALUE;
tmp_21.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__ALERT__ind(const INTEGER& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1083, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_ALERT_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__ALERT__IND;
{
MNCC__PDU__Signal_template& tmp_22 = ret_val.u().signal();
tmp_22.callref() = call__id;
tmp_22.bearer__cap() = OMIT_VALUE;
tmp_22.called() = OMIT_VALUE;
tmp_22.calling() = OMIT_VALUE;
tmp_22.redirecting() = OMIT_VALUE;
tmp_22.connected() = OMIT_VALUE;
tmp_22.cause() = OMIT_VALUE;
tmp_22.progress() = prog;
tmp_22.useruser() = uu;
tmp_22.facility() = fac;
tmp_22.cccap() = OMIT_VALUE;
tmp_22.ssversion() = OMIT_VALUE;
tmp_22.clir__sup() = 0;
tmp_22.clir__inv() = 0;
tmp_22.signal() = OMIT_VALUE;
tmp_22.keypad() = OMIT_VALUE;
tmp_22.more() = 0;
tmp_22.notify() = 0;
tmp_22.emergency() = OMIT_VALUE;
tmp_22.imsi() = cs_0;
tmp_22.lchan__type() = 0;
tmp_22.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__NOTIFY__req(const INTEGER& call__id, const INTEGER& notify)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1118, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_NOTIFY_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__NOTIFY__REQ;
{
MNCC__PDU__Signal_template& tmp_23 = ret_val.u().signal();
tmp_23.callref() = call__id;
tmp_23.bearer__cap() = OMIT_VALUE;
tmp_23.called() = OMIT_VALUE;
tmp_23.calling() = OMIT_VALUE;
tmp_23.redirecting() = OMIT_VALUE;
tmp_23.connected() = OMIT_VALUE;
tmp_23.cause() = OMIT_VALUE;
tmp_23.progress() = OMIT_VALUE;
tmp_23.useruser() = OMIT_VALUE;
tmp_23.facility() = OMIT_VALUE;
tmp_23.cccap() = OMIT_VALUE;
tmp_23.ssversion() = OMIT_VALUE;
tmp_23.clir__sup() = 0;
tmp_23.clir__inv() = 0;
tmp_23.signal() = OMIT_VALUE;
tmp_23.keypad() = OMIT_VALUE;
tmp_23.more() = 0;
tmp_23.notify() = notify;
tmp_23.emergency() = OMIT_VALUE;
tmp_23.imsi() = cs_0;
tmp_23.lchan__type() = 0;
tmp_23.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__NOTIFY__ind(const INTEGER_template& call__id, const INTEGER_template& notify)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1149, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_NOTIFY_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__NOTIFY__IND;
{
MNCC__PDU__Signal_template& tmp_24 = ret_val.u().signal();
tmp_24.callref() = call__id;
tmp_24.bearer__cap() = OMIT_VALUE;
tmp_24.called() = OMIT_VALUE;
tmp_24.calling() = OMIT_VALUE;
tmp_24.redirecting() = OMIT_VALUE;
tmp_24.connected() = OMIT_VALUE;
tmp_24.cause() = OMIT_VALUE;
tmp_24.progress() = OMIT_VALUE;
tmp_24.useruser() = OMIT_VALUE;
tmp_24.facility() = OMIT_VALUE;
tmp_24.cccap() = OMIT_VALUE;
tmp_24.ssversion() = OMIT_VALUE;
tmp_24.clir__sup() = 0;
tmp_24.clir__inv() = 0;
tmp_24.signal() = OMIT_VALUE;
tmp_24.keypad() = OMIT_VALUE;
tmp_24.more() = 0;
tmp_24.notify() = notify;
tmp_24.emergency() = ANY_OR_OMIT;
tmp_24.imsi() = ANY_VALUE;
tmp_24.lchan__type() = ANY_VALUE;
tmp_24.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__DISC__ind(const INTEGER_template& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1180, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_DISC_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__DISC__IND;
{
MNCC__PDU__Signal_template& tmp_25 = ret_val.u().signal();
tmp_25.callref() = call__id;
tmp_25.bearer__cap() = OMIT_VALUE;
tmp_25.called() = OMIT_VALUE;
tmp_25.calling() = OMIT_VALUE;
tmp_25.redirecting() = OMIT_VALUE;
tmp_25.connected() = OMIT_VALUE;
tmp_25.cause() = cause;
tmp_25.progress() = prog;
tmp_25.useruser() = uu;
tmp_25.facility() = fac;
tmp_25.cccap() = OMIT_VALUE;
tmp_25.ssversion() = OMIT_VALUE;
tmp_25.clir__sup() = 0;
tmp_25.clir__inv() = 0;
tmp_25.signal() = OMIT_VALUE;
tmp_25.keypad() = OMIT_VALUE;
tmp_25.more() = 0;
tmp_25.notify() = 0;
tmp_25.emergency() = ANY_OR_OMIT;
tmp_25.imsi() = ANY_VALUE;
tmp_25.lchan__type() = ANY_VALUE;
tmp_25.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__DISC__ind(const INTEGER& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1212, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_DISC_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__DISC__IND;
{
MNCC__PDU__Signal_template& tmp_26 = ret_val.u().signal();
tmp_26.callref() = call__id;
tmp_26.bearer__cap() = OMIT_VALUE;
tmp_26.called() = OMIT_VALUE;
tmp_26.calling() = OMIT_VALUE;
tmp_26.redirecting() = OMIT_VALUE;
tmp_26.connected() = OMIT_VALUE;
tmp_26.cause() = cause;
tmp_26.progress() = prog;
tmp_26.useruser() = uu;
tmp_26.facility() = fac;
tmp_26.cccap() = OMIT_VALUE;
tmp_26.ssversion() = OMIT_VALUE;
tmp_26.clir__sup() = 0;
tmp_26.clir__inv() = 0;
tmp_26.signal() = OMIT_VALUE;
tmp_26.keypad() = OMIT_VALUE;
tmp_26.more() = 0;
tmp_26.notify() = 0;
tmp_26.emergency() = OMIT_VALUE;
tmp_26.imsi() = cs_0;
tmp_26.lchan__type() = 0;
tmp_26.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__DISC__req(const INTEGER& call__id, const MNCC__cause& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1246, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_DISC_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__DISC__REQ;
{
MNCC__PDU__Signal_template& tmp_27 = ret_val.u().signal();
tmp_27.callref() = call__id;
tmp_27.bearer__cap() = OMIT_VALUE;
tmp_27.called() = OMIT_VALUE;
tmp_27.calling() = OMIT_VALUE;
tmp_27.redirecting() = OMIT_VALUE;
tmp_27.connected() = OMIT_VALUE;
tmp_27.cause() = cause;
tmp_27.progress() = prog;
tmp_27.useruser() = uu;
tmp_27.facility() = fac;
tmp_27.cccap() = OMIT_VALUE;
tmp_27.ssversion() = OMIT_VALUE;
tmp_27.clir__sup() = 0;
tmp_27.clir__inv() = 0;
tmp_27.signal() = OMIT_VALUE;
tmp_27.keypad() = OMIT_VALUE;
tmp_27.more() = 0;
tmp_27.notify() = 0;
tmp_27.emergency() = OMIT_VALUE;
tmp_27.imsi() = cs_0;
tmp_27.lchan__type() = 0;
tmp_27.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__DISC__req(const INTEGER_template& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1278, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_DISC_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__DISC__REQ;
{
MNCC__PDU__Signal_template& tmp_28 = ret_val.u().signal();
tmp_28.callref() = call__id;
tmp_28.bearer__cap() = OMIT_VALUE;
tmp_28.called() = OMIT_VALUE;
tmp_28.calling() = OMIT_VALUE;
tmp_28.redirecting() = OMIT_VALUE;
tmp_28.connected() = OMIT_VALUE;
tmp_28.cause() = cause;
tmp_28.progress() = prog;
tmp_28.useruser() = uu;
tmp_28.facility() = fac;
tmp_28.cccap() = OMIT_VALUE;
tmp_28.ssversion() = OMIT_VALUE;
tmp_28.clir__sup() = 0;
tmp_28.clir__inv() = 0;
tmp_28.signal() = OMIT_VALUE;
tmp_28.keypad() = OMIT_VALUE;
tmp_28.more() = 0;
tmp_28.notify() = 0;
tmp_28.emergency() = ANY_OR_OMIT;
tmp_28.imsi() = ANY_VALUE;
tmp_28.lchan__type() = ANY_VALUE;
tmp_28.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__REL__ind(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1314, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_REL_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__IND;
{
MNCC__PDU__Signal_template& tmp_29 = ret_val.u().signal();
tmp_29.callref() = call__id;
tmp_29.bearer__cap() = OMIT_VALUE;
tmp_29.called() = OMIT_VALUE;
tmp_29.calling() = OMIT_VALUE;
tmp_29.redirecting() = OMIT_VALUE;
tmp_29.connected() = OMIT_VALUE;
tmp_29.cause() = cause;
tmp_29.progress() = OMIT_VALUE;
tmp_29.useruser() = uu;
tmp_29.facility() = fac;
tmp_29.cccap() = OMIT_VALUE;
tmp_29.ssversion() = OMIT_VALUE;
tmp_29.clir__sup() = 0;
tmp_29.clir__inv() = 0;
tmp_29.signal() = OMIT_VALUE;
tmp_29.keypad() = OMIT_VALUE;
tmp_29.more() = 0;
tmp_29.notify() = 0;
tmp_29.emergency() = ANY_OR_OMIT;
tmp_29.imsi() = ANY_VALUE;
tmp_29.lchan__type() = ANY_VALUE;
tmp_29.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__REL__ind(const INTEGER& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1344, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_REL_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__IND;
{
MNCC__PDU__Signal_template& tmp_30 = ret_val.u().signal();
tmp_30.callref() = call__id;
tmp_30.bearer__cap() = OMIT_VALUE;
tmp_30.called() = OMIT_VALUE;
tmp_30.calling() = OMIT_VALUE;
tmp_30.redirecting() = OMIT_VALUE;
tmp_30.connected() = OMIT_VALUE;
tmp_30.cause() = cause;
tmp_30.progress() = OMIT_VALUE;
tmp_30.useruser() = uu;
tmp_30.facility() = fac;
tmp_30.cccap() = OMIT_VALUE;
tmp_30.ssversion() = OMIT_VALUE;
tmp_30.clir__sup() = 0;
tmp_30.clir__inv() = 0;
tmp_30.signal() = OMIT_VALUE;
tmp_30.keypad() = OMIT_VALUE;
tmp_30.more() = 0;
tmp_30.notify() = 0;
tmp_30.emergency() = OMIT_VALUE;
tmp_30.imsi() = cs_0;
tmp_30.lchan__type() = 0;
tmp_30.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__REL__req(const INTEGER& call__id, const MNCC__cause& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1378, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_REL_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__REQ;
{
MNCC__PDU__Signal_template& tmp_31 = ret_val.u().signal();
tmp_31.callref() = call__id;
tmp_31.bearer__cap() = OMIT_VALUE;
tmp_31.called() = OMIT_VALUE;
tmp_31.calling() = OMIT_VALUE;
tmp_31.redirecting() = OMIT_VALUE;
tmp_31.connected() = OMIT_VALUE;
tmp_31.cause() = cause;
tmp_31.progress() = OMIT_VALUE;
tmp_31.useruser() = uu;
tmp_31.facility() = fac;
tmp_31.cccap() = OMIT_VALUE;
tmp_31.ssversion() = OMIT_VALUE;
tmp_31.clir__sup() = 0;
tmp_31.clir__inv() = 0;
tmp_31.signal() = OMIT_VALUE;
tmp_31.keypad() = OMIT_VALUE;
tmp_31.more() = 0;
tmp_31.notify() = 0;
tmp_31.emergency() = OMIT_VALUE;
tmp_31.imsi() = cs_0;
tmp_31.lchan__type() = 0;
tmp_31.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__REL__req(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1408, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_REL_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__REQ;
{
MNCC__PDU__Signal_template& tmp_32 = ret_val.u().signal();
tmp_32.callref() = call__id;
tmp_32.bearer__cap() = OMIT_VALUE;
tmp_32.called() = ANY_OR_OMIT;
tmp_32.calling() = ANY_OR_OMIT;
tmp_32.redirecting() = ANY_OR_OMIT;
tmp_32.connected() = ANY_OR_OMIT;
tmp_32.cause() = cause;
tmp_32.progress() = OMIT_VALUE;
tmp_32.useruser() = uu;
tmp_32.facility() = fac;
tmp_32.cccap() = OMIT_VALUE;
tmp_32.ssversion() = OMIT_VALUE;
tmp_32.clir__sup() = 0;
tmp_32.clir__inv() = 0;
tmp_32.signal() = OMIT_VALUE;
tmp_32.keypad() = OMIT_VALUE;
tmp_32.more() = 0;
tmp_32.notify() = 0;
tmp_32.emergency() = OMIT_VALUE;
tmp_32.imsi() = ANY_VALUE;
tmp_32.lchan__type() = 0;
tmp_32.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__REL__cnf(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1441, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_REL_cnf");
MNCC__PDU_template ret_val(tr__MNCC__REL__ind(call__id, cause, fac, uu));
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__CNF;
return ret_val;
}

MNCC__PDU_template ts__MNCC__REL__cnf(const INTEGER& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1446, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_REL_cnf");
MNCC__PDU_template ret_val(ts__MNCC__REL__ind(call__id, cause, fac, uu));
ret_val.msg__type() = MNCC__MsgType::MNCC__REL__CNF;
return ret_val;
}

MNCC__PDU_template ts__MNCC__FACILITY__req(const INTEGER& call__id, const CHARSTRING& fac)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1456, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_FACILITY_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__FACILITY__REQ;
{
MNCC__PDU__Signal_template& tmp_33 = ret_val.u().signal();
tmp_33.callref() = call__id;
tmp_33.bearer__cap() = OMIT_VALUE;
tmp_33.called() = OMIT_VALUE;
tmp_33.calling() = OMIT_VALUE;
tmp_33.redirecting() = OMIT_VALUE;
tmp_33.connected() = OMIT_VALUE;
tmp_33.cause() = OMIT_VALUE;
tmp_33.progress() = OMIT_VALUE;
tmp_33.useruser() = OMIT_VALUE;
tmp_33.facility() = fac;
tmp_33.cccap() = OMIT_VALUE;
tmp_33.ssversion() = OMIT_VALUE;
tmp_33.clir__sup() = 0;
tmp_33.clir__inv() = 0;
tmp_33.signal() = OMIT_VALUE;
tmp_33.keypad() = OMIT_VALUE;
tmp_33.more() = 0;
tmp_33.notify() = 0;
tmp_33.emergency() = OMIT_VALUE;
tmp_33.imsi() = cs_0;
tmp_33.lchan__type() = 0;
tmp_33.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__FACILITY__ind(const INTEGER_template& call__id, const CHARSTRING_template& fac)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1487, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_FACILITY_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__FACILITY__IND;
{
MNCC__PDU__Signal_template& tmp_34 = ret_val.u().signal();
tmp_34.callref() = call__id;
tmp_34.bearer__cap() = OMIT_VALUE;
tmp_34.called() = OMIT_VALUE;
tmp_34.calling() = OMIT_VALUE;
tmp_34.redirecting() = OMIT_VALUE;
tmp_34.connected() = OMIT_VALUE;
tmp_34.cause() = OMIT_VALUE;
tmp_34.progress() = OMIT_VALUE;
tmp_34.useruser() = OMIT_VALUE;
tmp_34.facility() = fac;
tmp_34.cccap() = OMIT_VALUE;
tmp_34.ssversion() = OMIT_VALUE;
tmp_34.clir__sup() = 0;
tmp_34.clir__inv() = 0;
tmp_34.signal() = OMIT_VALUE;
tmp_34.keypad() = OMIT_VALUE;
tmp_34.more() = 0;
tmp_34.notify() = 0;
tmp_34.emergency() = ANY_OR_OMIT;
tmp_34.imsi() = ANY_VALUE;
tmp_34.lchan__type() = ANY_VALUE;
tmp_34.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__START__DTMF__ind(const INTEGER_template& call__id, const CHARSTRING_template& keypad)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1518, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_START_DTMF_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__START__DTMF__IND;
{
MNCC__PDU__Signal_template& tmp_35 = ret_val.u().signal();
tmp_35.callref() = call__id;
tmp_35.bearer__cap() = OMIT_VALUE;
tmp_35.called() = OMIT_VALUE;
tmp_35.calling() = OMIT_VALUE;
tmp_35.redirecting() = OMIT_VALUE;
tmp_35.connected() = OMIT_VALUE;
tmp_35.cause() = OMIT_VALUE;
tmp_35.progress() = OMIT_VALUE;
tmp_35.useruser() = OMIT_VALUE;
tmp_35.facility() = OMIT_VALUE;
tmp_35.cccap() = OMIT_VALUE;
tmp_35.ssversion() = OMIT_VALUE;
tmp_35.clir__sup() = 0;
tmp_35.clir__inv() = 0;
tmp_35.signal() = OMIT_VALUE;
tmp_35.keypad() = keypad;
tmp_35.more() = 0;
tmp_35.notify() = 0;
tmp_35.emergency() = ANY_OR_OMIT;
tmp_35.imsi() = ANY_VALUE;
tmp_35.lchan__type() = ANY_VALUE;
tmp_35.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__START__DTMF__rsp(const INTEGER& call__id, const CHARSTRING& keypad)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1549, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_START_DTMF_rsp");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__START__DTMF__RSP;
{
MNCC__PDU__Signal_template& tmp_36 = ret_val.u().signal();
tmp_36.callref() = call__id;
tmp_36.bearer__cap() = OMIT_VALUE;
tmp_36.called() = OMIT_VALUE;
tmp_36.calling() = OMIT_VALUE;
tmp_36.redirecting() = OMIT_VALUE;
tmp_36.connected() = OMIT_VALUE;
tmp_36.cause() = OMIT_VALUE;
tmp_36.progress() = OMIT_VALUE;
tmp_36.useruser() = OMIT_VALUE;
tmp_36.facility() = OMIT_VALUE;
tmp_36.cccap() = OMIT_VALUE;
tmp_36.ssversion() = OMIT_VALUE;
tmp_36.clir__sup() = 0;
tmp_36.clir__inv() = 0;
tmp_36.signal() = OMIT_VALUE;
tmp_36.keypad() = keypad;
tmp_36.more() = 0;
tmp_36.notify() = 0;
tmp_36.emergency() = OMIT_VALUE;
tmp_36.imsi() = cs_0;
tmp_36.lchan__type() = 0;
tmp_36.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__START__DTMF__rej(const INTEGER& call__id, const MNCC__cause& cause)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1580, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_START_DTMF_rej");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__START__DTMF__REJ;
{
MNCC__PDU__Signal_template& tmp_37 = ret_val.u().signal();
tmp_37.callref() = call__id;
tmp_37.bearer__cap() = OMIT_VALUE;
tmp_37.called() = OMIT_VALUE;
tmp_37.calling() = OMIT_VALUE;
tmp_37.redirecting() = OMIT_VALUE;
tmp_37.connected() = OMIT_VALUE;
tmp_37.cause() = cause;
tmp_37.progress() = OMIT_VALUE;
tmp_37.useruser() = OMIT_VALUE;
tmp_37.facility() = OMIT_VALUE;
tmp_37.cccap() = OMIT_VALUE;
tmp_37.ssversion() = OMIT_VALUE;
tmp_37.clir__sup() = 0;
tmp_37.clir__inv() = 0;
tmp_37.signal() = OMIT_VALUE;
tmp_37.keypad() = OMIT_VALUE;
tmp_37.more() = 0;
tmp_37.notify() = 0;
tmp_37.emergency() = OMIT_VALUE;
tmp_37.imsi() = cs_0;
tmp_37.lchan__type() = 0;
tmp_37.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__STOP__DTMF__ind(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1611, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_STOP_DTMF_ind");
MNCC__PDU_template ret_val;
ret_val = tr__MNCC__SIMPLE(MNCC__MsgType_template(MNCC__MsgType::MNCC__STOP__DTMF__IND), call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__STOP__DTMF__rsp(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1615, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_STOP_DTMF_rsp");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE(MNCC__MsgType::MNCC__STOP__DTMF__RSP, call__id);
return ret_val;
}

MNCC__PDU_template tr__MNCC__MODIFY__ind(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1619, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_MODIFY_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__MODIFY__IND;
{
MNCC__PDU__Signal_template& tmp_38 = ret_val.u().signal();
tmp_38.callref() = call__id;
tmp_38.bearer__cap() = bcap;
tmp_38.called() = OMIT_VALUE;
tmp_38.calling() = OMIT_VALUE;
tmp_38.redirecting() = OMIT_VALUE;
tmp_38.connected() = OMIT_VALUE;
tmp_38.cause() = OMIT_VALUE;
tmp_38.progress() = OMIT_VALUE;
tmp_38.useruser() = OMIT_VALUE;
tmp_38.facility() = OMIT_VALUE;
tmp_38.cccap() = OMIT_VALUE;
tmp_38.ssversion() = OMIT_VALUE;
tmp_38.clir__sup() = 0;
tmp_38.clir__inv() = 0;
tmp_38.signal() = OMIT_VALUE;
tmp_38.keypad() = OMIT_VALUE;
tmp_38.more() = 0;
tmp_38.notify() = 0;
tmp_38.emergency() = ANY_OR_OMIT;
tmp_38.imsi() = ANY_VALUE;
tmp_38.lchan__type() = ANY_VALUE;
tmp_38.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__MODIFY__rsp(const INTEGER& call__id, const MNCC__bearer__cap& bcap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1650, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_MODIFY_rsp");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__MODIFY__RSP;
{
MNCC__PDU__Signal_template& tmp_39 = ret_val.u().signal();
tmp_39.callref() = call__id;
tmp_39.bearer__cap() = bcap;
tmp_39.called() = OMIT_VALUE;
tmp_39.calling() = OMIT_VALUE;
tmp_39.redirecting() = OMIT_VALUE;
tmp_39.connected() = OMIT_VALUE;
tmp_39.cause() = OMIT_VALUE;
tmp_39.progress() = OMIT_VALUE;
tmp_39.useruser() = OMIT_VALUE;
tmp_39.facility() = OMIT_VALUE;
tmp_39.cccap() = OMIT_VALUE;
tmp_39.ssversion() = OMIT_VALUE;
tmp_39.clir__sup() = 0;
tmp_39.clir__inv() = 0;
tmp_39.signal() = OMIT_VALUE;
tmp_39.keypad() = OMIT_VALUE;
tmp_39.more() = 0;
tmp_39.notify() = 0;
tmp_39.emergency() = OMIT_VALUE;
tmp_39.imsi() = cs_0;
tmp_39.lchan__type() = 0;
tmp_39.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__MODIFY__req(const INTEGER& call__id, const MNCC__bearer__cap& bcap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1681, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_MODIFY_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__MODIFY__REQ;
{
MNCC__PDU__Signal_template& tmp_40 = ret_val.u().signal();
tmp_40.callref() = call__id;
tmp_40.bearer__cap() = bcap;
tmp_40.called() = OMIT_VALUE;
tmp_40.calling() = OMIT_VALUE;
tmp_40.redirecting() = OMIT_VALUE;
tmp_40.connected() = OMIT_VALUE;
tmp_40.cause() = OMIT_VALUE;
tmp_40.progress() = OMIT_VALUE;
tmp_40.useruser() = OMIT_VALUE;
tmp_40.facility() = OMIT_VALUE;
tmp_40.cccap() = OMIT_VALUE;
tmp_40.ssversion() = OMIT_VALUE;
tmp_40.clir__sup() = 0;
tmp_40.clir__inv() = 0;
tmp_40.signal() = OMIT_VALUE;
tmp_40.keypad() = OMIT_VALUE;
tmp_40.more() = 0;
tmp_40.notify() = 0;
tmp_40.emergency() = OMIT_VALUE;
tmp_40.imsi() = cs_0;
tmp_40.lchan__type() = 0;
tmp_40.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__MODIFY__cnf(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1712, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_MODIFY_cnf");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__MODIFY__CNF;
{
MNCC__PDU__Signal_template& tmp_41 = ret_val.u().signal();
tmp_41.callref() = call__id;
tmp_41.bearer__cap() = bcap;
tmp_41.called() = OMIT_VALUE;
tmp_41.calling() = OMIT_VALUE;
tmp_41.redirecting() = OMIT_VALUE;
tmp_41.connected() = OMIT_VALUE;
tmp_41.cause() = OMIT_VALUE;
tmp_41.progress() = OMIT_VALUE;
tmp_41.useruser() = OMIT_VALUE;
tmp_41.facility() = OMIT_VALUE;
tmp_41.cccap() = OMIT_VALUE;
tmp_41.ssversion() = OMIT_VALUE;
tmp_41.clir__sup() = 0;
tmp_41.clir__inv() = 0;
tmp_41.signal() = OMIT_VALUE;
tmp_41.keypad() = OMIT_VALUE;
tmp_41.more() = 0;
tmp_41.notify() = 0;
tmp_41.emergency() = ANY_OR_OMIT;
tmp_41.imsi() = ANY_VALUE;
tmp_41.lchan__type() = ANY_VALUE;
tmp_41.lchan__mode() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__USERINFO__req(const INTEGER& call__id, const MNCC__useruser& uu, const INTEGER& more)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1744, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_USERINFO_req");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__USERINFO__REQ;
{
MNCC__PDU__Signal_template& tmp_42 = ret_val.u().signal();
tmp_42.callref() = call__id;
tmp_42.bearer__cap() = OMIT_VALUE;
tmp_42.called() = OMIT_VALUE;
tmp_42.calling() = OMIT_VALUE;
tmp_42.redirecting() = OMIT_VALUE;
tmp_42.connected() = OMIT_VALUE;
tmp_42.cause() = OMIT_VALUE;
tmp_42.progress() = OMIT_VALUE;
tmp_42.useruser() = uu;
tmp_42.facility() = OMIT_VALUE;
tmp_42.cccap() = OMIT_VALUE;
tmp_42.ssversion() = OMIT_VALUE;
tmp_42.clir__sup() = 0;
tmp_42.clir__inv() = 0;
tmp_42.signal() = OMIT_VALUE;
tmp_42.keypad() = OMIT_VALUE;
tmp_42.more() = more;
tmp_42.notify() = 0;
tmp_42.emergency() = OMIT_VALUE;
tmp_42.imsi() = cs_0;
tmp_42.lchan__type() = 0;
tmp_42.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__USERINFO__ind(const INTEGER_template& call__id, const MNCC__useruser_template& uu, const INTEGER& more)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1775, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_USERINFO_ind");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__USERINFO__IND;
{
MNCC__PDU__Signal_template& tmp_43 = ret_val.u().signal();
tmp_43.callref() = call__id;
tmp_43.bearer__cap() = OMIT_VALUE;
tmp_43.called() = OMIT_VALUE;
tmp_43.calling() = OMIT_VALUE;
tmp_43.redirecting() = OMIT_VALUE;
tmp_43.connected() = OMIT_VALUE;
tmp_43.cause() = OMIT_VALUE;
tmp_43.progress() = OMIT_VALUE;
tmp_43.useruser() = uu;
tmp_43.facility() = OMIT_VALUE;
tmp_43.cccap() = OMIT_VALUE;
tmp_43.ssversion() = OMIT_VALUE;
tmp_43.clir__sup() = 0;
tmp_43.clir__inv() = 0;
tmp_43.signal() = OMIT_VALUE;
tmp_43.keypad() = OMIT_VALUE;
tmp_43.more() = more;
tmp_43.notify() = 0;
tmp_43.emergency() = OMIT_VALUE;
tmp_43.imsi() = cs_0;
tmp_43.lchan__type() = 0;
tmp_43.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__HOLD__ind(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1807, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_HOLD_ind");
MNCC__PDU_template ret_val;
ret_val = tr__MNCC__SIMPLE(MNCC__MsgType_template(MNCC__MsgType::MNCC__HOLD__IND), call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__HOLD__cnf(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1811, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_HOLD_cnf");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE(MNCC__MsgType::MNCC__HOLD__CNF, call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__HOLD__rej(const INTEGER& call__id, const MNCC__cause& cause)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1815, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_HOLD_rej");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__HOLD__REJ;
{
MNCC__PDU__Signal_template& tmp_44 = ret_val.u().signal();
tmp_44.callref() = call__id;
tmp_44.bearer__cap() = OMIT_VALUE;
tmp_44.called() = OMIT_VALUE;
tmp_44.calling() = OMIT_VALUE;
tmp_44.redirecting() = OMIT_VALUE;
tmp_44.connected() = OMIT_VALUE;
tmp_44.cause() = cause;
tmp_44.progress() = OMIT_VALUE;
tmp_44.useruser() = OMIT_VALUE;
tmp_44.facility() = OMIT_VALUE;
tmp_44.cccap() = OMIT_VALUE;
tmp_44.ssversion() = OMIT_VALUE;
tmp_44.clir__sup() = 0;
tmp_44.clir__inv() = 0;
tmp_44.signal() = OMIT_VALUE;
tmp_44.keypad() = OMIT_VALUE;
tmp_44.more() = 0;
tmp_44.notify() = 0;
tmp_44.emergency() = OMIT_VALUE;
tmp_44.imsi() = cs_0;
tmp_44.lchan__type() = 0;
tmp_44.lchan__mode() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__RETRIEVE__ind(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1846, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_RETRIEVE_ind");
MNCC__PDU_template ret_val;
ret_val = tr__MNCC__SIMPLE(MNCC__MsgType_template(MNCC__MsgType::MNCC__RETRIEVE__IND), call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__RETRIEVE__cnf(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1850, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_RETRIEVE_cnf");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE(MNCC__MsgType::MNCC__RETRIEVE__CNF, call__id);
return ret_val;
}

MNCC__PDU_template ts__MNCC__RETRIEVE__rej(const INTEGER& call__id, const MNCC__cause& cause)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1854, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_RETRIEVE_rej");
MNCC__PDU_template ret_val(ts__MNCC__HOLD__rej(call__id, cause));
ret_val.msg__type() = MNCC__MsgType::MNCC__RETRIEVE__REJ;
return ret_val;
}

MNCC__PDU_template ts__MNCC__SIMPLE__RTP(const MNCC__MsgType& msg__type, const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1860, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_SIMPLE_RTP");
MNCC__PDU_template ret_val;
ret_val.msg__type() = msg__type;
{
MNCC__PDU__Rtp_template& tmp_45 = ret_val.u().rtp();
tmp_45.callref() = call__id;
tmp_45.ip() = 0;
tmp_45.rtp__port() = 0;
tmp_45.payload__type() = 0;
tmp_45.payload__msg__type() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__RTP__CREATE(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1874, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_RTP_CREATE");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE__RTP(MNCC__MsgType::MNCC__RTP__CREATE, call__id);
return ret_val;
}

MNCC__PDU_template tr__MNCC__RTP__CREATE(const INTEGER_template& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1877, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_RTP_CREATE");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__RTP__CREATE;
{
MNCC__PDU__Rtp_template& tmp_46 = ret_val.u().rtp();
tmp_46.callref() = call__id;
tmp_46.ip() = ANY_VALUE;
tmp_46.rtp__port() = ANY_VALUE;
tmp_46.payload__type() = ANY_VALUE;
tmp_46.payload__msg__type() = ANY_VALUE;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__RTP__CONNECT(const INTEGER& call__id, const INTEGER& ip, const INTEGER& rtp__port, const INTEGER& pt)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1891, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_RTP_CONNECT");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__RTP__CONNECT;
{
MNCC__PDU__Rtp_template& tmp_47 = ret_val.u().rtp();
tmp_47.callref() = call__id;
tmp_47.ip() = ip;
tmp_47.rtp__port() = rtp__port;
tmp_47.payload__type() = pt;
tmp_47.payload__msg__type() = 0;
}
return ret_val;
}

MNCC__PDU_template tr__MNCC__RTP__CONNECT(const INTEGER_template& call__id, const INTEGER_template& ip, const INTEGER_template& rtp__port, const INTEGER_template& pt)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1903, TTCN_Location::LOCATION_TEMPLATE, "tr_MNCC_RTP_CONNECT");
MNCC__PDU_template ret_val;
ret_val.msg__type() = MNCC__MsgType::MNCC__RTP__CONNECT;
{
MNCC__PDU__Rtp_template& tmp_48 = ret_val.u().rtp();
tmp_48.callref() = call__id;
tmp_48.ip() = ip;
tmp_48.rtp__port() = rtp__port;
tmp_48.payload__type() = pt;
tmp_48.payload__msg__type() = 0;
}
return ret_val;
}

MNCC__PDU_template ts__MNCC__RTP__FREE(const INTEGER& call__id)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1921, TTCN_Location::LOCATION_TEMPLATE, "ts_MNCC_RTP_FREE");
MNCC__PDU_template ret_val;
ret_val = ts__MNCC__SIMPLE__RTP(MNCC__MsgType::MNCC__RTP__FREE, call__id);
return ret_val;
}

INTEGER f__mncc__get__call__id(const MNCC__PDU& pdu)
{
TTCN_Location current_location("MNCC_Types.ttcn", 1923, TTCN_Location::LOCATION_FUNCTION, "f_mncc_get_call_id");
current_location.update_lineno(1924);
/* MNCC_Types.ttcn, line 1924 */
{
boolean tmp_52;
{
boolean tmp_49 = pdu.is_bound();
if(tmp_49) {
const MNCC__PDU& tmp_50 = pdu;
const MNCC__MsgUnion& tmp_51 = tmp_50.u();
tmp_49 = tmp_51.is_bound();
if(tmp_49) {
tmp_49 = tmp_51.ischosen(MNCC__MsgUnion::ALT_rtp);
}
}
tmp_52 = tmp_49;
}
if (tmp_52) {
current_location.update_lineno(1925);
/* MNCC_Types.ttcn, line 1925 */
return const_cast< const MNCC__PDU&>(pdu).u().rtp().callref();
}
else {
current_location.update_lineno(1926);
/* MNCC_Types.ttcn, line 1926 */
boolean tmp_56;
{
boolean tmp_53 = pdu.is_bound();
if(tmp_53) {
const MNCC__PDU& tmp_54 = pdu;
const MNCC__MsgUnion& tmp_55 = tmp_54.u();
tmp_53 = tmp_55.is_bound();
if(tmp_53) {
tmp_53 = tmp_55.ischosen(MNCC__MsgUnion::ALT_data);
}
}
tmp_56 = tmp_53;
}
if (tmp_56) {
current_location.update_lineno(1927);
/* MNCC_Types.ttcn, line 1927 */
return const_cast< const MNCC__PDU&>(pdu).u().data().callref();
}
else {
current_location.update_lineno(1928);
/* MNCC_Types.ttcn, line 1928 */
boolean tmp_60;
{
boolean tmp_57 = pdu.is_bound();
if(tmp_57) {
const MNCC__PDU& tmp_58 = pdu;
const MNCC__MsgUnion& tmp_59 = tmp_58.u();
tmp_57 = tmp_59.is_bound();
if(tmp_57) {
tmp_57 = tmp_59.ischosen(MNCC__MsgUnion::ALT_signal);
}
}
tmp_60 = tmp_57;
}
if (tmp_60) {
current_location.update_lineno(1929);
/* MNCC_Types.ttcn, line 1929 */
return const_cast< const MNCC__PDU&>(pdu).u().signal().callref();
}
else {
current_location.update_lineno(1931);
/* MNCC_Types.ttcn, line 1931 */
TTCN_Runtime::setverdict(FAIL,(TTCN_Logger::begin_event_log2str(),TTCN_Logger::log_event_str("Unable to determine Callref for MNCC"),pdu.log(),TTCN_Logger::end_event_log2str()));
current_location.update_lineno(1932);
/* MNCC_Types.ttcn, line 1932 */
TTCN_Runtime::stop_component(MTC_COMPREF);
}
}
}
}
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("MNCC_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "MNCC_Types");
Osmocom__Types::module_object.pre_init_module();
current_location.update_lineno(143);
/* MNCC_Types.ttcn, line 143 */
const_GSM__MAX__FACILITY = 128;
current_location.update_lineno(144);
/* MNCC_Types.ttcn, line 144 */
const_GSM__MAX__SSVERSION = 128;
current_location.update_lineno(145);
/* MNCC_Types.ttcn, line 145 */
const_GSM__MAX__USERUSER = 128;
module_object.add_function("enc_MNCC_PDU", (genericfunc_t)&enc__MNCC__PDU, NULL);
module_object.add_function("dec_MNCC_PDU", (genericfunc_t)&dec__MNCC__PDU, NULL);
module_object.add_function("f_mncc_get_call_id", (genericfunc_t)&f__mncc__get__call__id, NULL);
}

static void post_init_module()
{
TTCN_Location current_location("MNCC_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "MNCC_Types");
Osmocom__Types::module_object.post_init_module();
current_location.update_lineno(173);
/* MNCC_Types.ttcn, line 173 */
template_ts__MNCC__bcap__voice.transfer() = 0;
template_ts__MNCC__bcap__voice.mode() = 0;
template_ts__MNCC__bcap__voice.coding() = 0;
template_ts__MNCC__bcap__voice.radio() = 3;
template_ts__MNCC__bcap__voice.speech__ctm() = 0;
{
MNCC__speech__vers_template& tmp_0 = template_ts__MNCC__bcap__voice.speech__ver();
tmp_0.set_size(6);
tmp_0[0] = 0;
tmp_0[1] = 2;
tmp_0[2] = 4;
tmp_0[3] = 1;
tmp_0[4] = 5;
tmp_0[5] = -1;
}
template_ts__MNCC__bcap__voice.data() = OMIT_VALUE;
const_ts__MNCC__number_ton_defval = GSM48__type__of__number::GSM48__TON__INTERNATIONAL;
const_ts__MNCC__number_npi_defval = GSM48__num__plan__ind::GSM48__NUMPLAN__E164;
const_ts__MNCC__number_pres_defval = GSM48__present__ind::GSM48__PRES__IND__ALLOWED;
const_ts__MNCC__number_screen_defval = GSM48__screening__ind::GSM48__SCR__IND__NOT__SCREENED;
template_tr__MNCC__number_ton_defval = ANY_VALUE;
template_tr__MNCC__number_npi_defval = ANY_VALUE;
template_tr__MNCC__number_pres_defval = ANY_VALUE;
template_tr__MNCC__number_screen_defval = ANY_VALUE;
const_ts__MNCC__cause_loc_defval = GSM48__cause__loc::GSM48__CAUSE__LOC__PUN__S__LU;
const_ts__MNCC__cause_coding_defval = GSM48__cause__coding::GSM48__CAUSE__CS__GSM;
const_ts__MNCC__cause_diag_defval = os_0;
const_ts__MNCC__HELLO_version_defval = 5;
const_ts__MNCC__SETUP__req_imsi_defval = cs_0;
template_tr__MNCC__SETUP__req_call__id_defval = ANY_VALUE;
template_tr__MNCC__SETUP__req_called_defval = ANY_VALUE;
template_tr__MNCC__SETUP__req_calling_defval = ANY_OR_OMIT;
template_tr__MNCC__SETUP__req_imsi_defval = ANY_VALUE;
const_ts__MNCC__SETUP__rsp_imsi_defval = cs_0;
template_ts__MNCC__SETUP__rsp_connected_defval = OMIT_VALUE;
template_tr__MNCC__SETUP__rsp_imsi_defval = ANY_VALUE;
template_tr__MNCC__SETUP__rsp_connected_defval = ANY_OR_OMIT;
template_tr__MNCC__SETUP__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__SETUP__ind_called_defval = ANY_VALUE;
template_tr__MNCC__SETUP__ind_calling_defval = ANY_OR_OMIT;
template_tr__MNCC__SETUP__ind_imsi_defval = ANY_VALUE;
template_ts__MNCC__SETUP__ind_calling_defval = OMIT_VALUE;
template_ts__MNCC__SETUP__ind_imsi_defval = OMIT_VALUE;
template_ts__MNCC__SETUP__ind_bcap_defval = ts__MNCC__bcap__voice;
template_ts__MNCC__SETUP__CNF_connected_defval = OMIT_VALUE;
template_tr__MNCC__SETUP__cnf_connected_defval = ANY_OR_OMIT;
template_tr__MNCC__SETUP__COMPL__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__REJ__req_cause_defval = ANY_OR_OMIT;
template_ts__MNCC__REJ__ind_cause_defval = OMIT_VALUE;
template_tr__MNCC__CALL__CONF__ind_bcap_defval = ANY_OR_OMIT;
template_tr__MNCC__CALL__CONF__ind_cause_defval = ANY_OR_OMIT;
template_tr__MNCC__CALL__CONF__ind_cccap_defval = ANY_OR_OMIT;
template_ts__MNCC__CALL__CONF__ind_bcap_defval = OMIT_VALUE;
template_ts__MNCC__CALL__CONF__ind_cause_defval = OMIT_VALUE;
template_ts__MNCC__CALL__CONF__ind_cccap_defval = OMIT_VALUE;
template_ts__MNCC__CALL__PROC__req_bcap_defval = OMIT_VALUE;
template_ts__MNCC__CALL__PROC__req_prog_defval = OMIT_VALUE;
template_ts__MNCC__CALL__PROC__req_fac_defval = OMIT_VALUE;
template_ts__MNCC__CALL__PROC__req_cccap_defval = OMIT_VALUE;
template_tr__MNCC__CALL__PROC__req_bcap_defval = ANY_OR_OMIT;
template_tr__MNCC__CALL__PROC__req_prog_defval = ANY_OR_OMIT;
template_tr__MNCC__CALL__PROC__req_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__CALL__PROC__req_cccap_defval = ANY_OR_OMIT;
template_ts__MNCC__PROGRESS__req_uu_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__req_prog_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__req_fac_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__req_uu_defval = OMIT_VALUE;
template_tr__MNCC__ALERT__req_prog_defval = ANY_OR_OMIT;
template_tr__MNCC__ALERT__req_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__ALERT__req_uu_defval = ANY_OR_OMIT;
template_tr__MNCC__ALERT__ind_prog_defval = OMIT_VALUE;
template_tr__MNCC__ALERT__ind_fac_defval = OMIT_VALUE;
template_tr__MNCC__ALERT__ind_uu_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__ind_prog_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__ind_fac_defval = OMIT_VALUE;
template_ts__MNCC__ALERT__ind_uu_defval = OMIT_VALUE;
template_tr__MNCC__DISC__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__DISC__ind_cause_defval = ANY_VALUE;
template_tr__MNCC__DISC__ind_prog_defval = ANY_OR_OMIT;
template_tr__MNCC__DISC__ind_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__DISC__ind_uu_defval = ANY_OR_OMIT;
template_ts__MNCC__DISC__ind_prog_defval = OMIT_VALUE;
template_ts__MNCC__DISC__ind_fac_defval = OMIT_VALUE;
template_ts__MNCC__DISC__ind_uu_defval = OMIT_VALUE;
template_ts__MNCC__DISC__req_prog_defval = OMIT_VALUE;
template_ts__MNCC__DISC__req_fac_defval = OMIT_VALUE;
template_ts__MNCC__DISC__req_uu_defval = OMIT_VALUE;
template_tr__MNCC__DISC__req_cause_defval = ANY_OR_OMIT;
template_tr__MNCC__DISC__req_prog_defval = OMIT_VALUE;
template_tr__MNCC__DISC__req_fac_defval = OMIT_VALUE;
template_tr__MNCC__DISC__req_uu_defval = OMIT_VALUE;
template_tr__MNCC__REL__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__REL__ind_cause_defval = ANY_VALUE;
template_tr__MNCC__REL__ind_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__REL__ind_uu_defval = ANY_OR_OMIT;
template_ts__MNCC__REL__ind_fac_defval = OMIT_VALUE;
template_ts__MNCC__REL__ind_uu_defval = OMIT_VALUE;
template_ts__MNCC__REL__req_fac_defval = OMIT_VALUE;
template_ts__MNCC__REL__req_uu_defval = OMIT_VALUE;
template_tr__MNCC__REL__req_cause_defval = ANY_OR_OMIT;
template_tr__MNCC__REL__req_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__REL__req_uu_defval = ANY_OR_OMIT;
template_tr__MNCC__REL__cnf_call__id_defval = ANY_VALUE;
template_tr__MNCC__REL__cnf_cause_defval = ANY_VALUE;
template_tr__MNCC__REL__cnf_fac_defval = ANY_OR_OMIT;
template_tr__MNCC__REL__cnf_uu_defval = ANY_OR_OMIT;
template_ts__MNCC__REL__cnf_fac_defval = OMIT_VALUE;
template_ts__MNCC__REL__cnf_uu_defval = OMIT_VALUE;
template_tr__MNCC__FACILITY__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__FACILITY__ind_fac_defval = ANY_VALUE;
template_tr__MNCC__START__DTMF__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__START__DTMF__ind_keypad_defval = ANY_VALUE;
template_tr__MNCC__STOP__DTMF__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__MODIFY__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__MODIFY__ind_bcap_defval = ANY_VALUE;
template_tr__MNCC__MODIFY__cnf_call__id_defval = ANY_VALUE;
template_tr__MNCC__MODIFY__cnf_bcap_defval = ANY_VALUE;
template_tr__MNCC__USERINFO__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__USERINFO__ind_uu_defval = ANY_VALUE;
template_tr__MNCC__HOLD__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__RETRIEVE__ind_call__id_defval = ANY_VALUE;
template_tr__MNCC__RTP__CREATE_call__id_defval = ANY_VALUE;
template_tr__MNCC__RTP__CONNECT_ip_defval = ANY_VALUE;
template_tr__MNCC__RTP__CONNECT_rtp__port_defval = ANY_VALUE;
template_tr__MNCC__RTP__CONNECT_pt_defval = ANY_VALUE;
}


} /* end of namespace */
