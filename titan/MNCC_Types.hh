// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3B
// for Harald Welte (laforge@nataraja) on Sun Mar 25 21:50:30 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef MNCC__Types_HH
#define MNCC__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "Osmocom_Types.hh"

#if TTCN3_VERSION != 60301
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef MNCC__Types_HH
#endif

namespace MNCC__Types {

/* Forward declarations of classes */

class GSM48__bcap__ra;
class GSM48__bcap__ra_template;
class GSM48__bcap__sig__access;
class GSM48__bcap__sig__access_template;
class GSM48__bcap__user__rate;
class GSM48__bcap__user__rate_template;
class GSM48__bcap__parity;
class GSM48__bcap__parity_template;
class GSM48__bcap__interm__rate;
class GSM48__bcap__interm__rate_template;
class GSM48__bcap__transp;
class GSM48__bcap__transp_template;
class GSM48__bcap__modem__type;
class GSM48__bcap__modem__type_template;
class MNCC__MsgType;
class MNCC__MsgType_template;
class MNCC__bearer__cap__data;
class MNCC__bearer__cap__data_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER MNCC__speech__vers;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template MNCC__speech__vers_template;
class MNCC__bearer__cap;
class MNCC__bearer__cap_template;
class GSM48__type__of__number;
class GSM48__type__of__number_template;
class GSM48__num__plan__ind;
class GSM48__num__plan__ind_template;
class GSM48__present__ind;
class GSM48__present__ind_template;
class GSM48__screening__ind;
class GSM48__screening__ind_template;
class MNCC__number;
class MNCC__number_template;
class GSM48__cause__coding;
class GSM48__cause__coding_template;
class GSM48__cause__loc;
class GSM48__cause__loc_template;
class MNCC__cause;
class MNCC__cause_template;
class MNCC__useruser;
class MNCC__useruser_template;
class MNCC__progress;
class MNCC__progress_template;
class MNCC__cccap;
class MNCC__cccap_template;
class MNCC__bcap;
class MNCC__bcap_template;
class MNCC__PDU__Signal;
class MNCC__PDU__Signal_template;
class MNCC__PDU__Data;
class MNCC__PDU__Data_template;
class MNCC__PDU__Rtp;
class MNCC__PDU__Rtp_template;
class MNCC__PDU__Hello;
class MNCC__PDU__Hello_template;
class MNCC__MsgUnion;
class MNCC__MsgUnion_template;
class MNCC__PDU;
class MNCC__PDU_template;

} /* end of namespace */

#ifndef MNCC__Types_HH
#define MNCC__Types_HH

namespace MNCC__Types {

/* Type definitions */

typedef INTEGER int_;
typedef INTEGER_template int__template;
typedef INTEGER MNCC__notify;
typedef INTEGER_template MNCC__notify_template;
typedef CHARSTRING MNCC__keypad;
typedef CHARSTRING_template MNCC__keypad_template;

/* Class definitions */

class GSM48__bcap__ra : public Base_Type { // enum
friend class GSM48__bcap__ra_template;
public:
enum enum_type { GSM48__BCAP__RA__NONE = 0, GSM48__BCAP__RA__V110__X30 = 1, GSM48__BCAP__RA__X31 = 2, GSM48__BCAP__RA__OTHER = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__bcap__ra();
GSM48__bcap__ra(int other_value);
GSM48__bcap__ra(enum_type other_value);
GSM48__bcap__ra(const GSM48__bcap__ra& other_value);

GSM48__bcap__ra& operator=(int other_value);
GSM48__bcap__ra& operator=(enum_type other_value);
GSM48__bcap__ra& operator=(const GSM48__bcap__ra& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__ra& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__ra& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__ra& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__ra& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__ra& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__ra& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__ra& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__ra_template : public Base_Template {
union {
GSM48__bcap__ra::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__ra_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__ra_template& other_value);

public:
GSM48__bcap__ra_template();
GSM48__bcap__ra_template(template_sel other_value);
GSM48__bcap__ra_template(int other_value);
GSM48__bcap__ra_template(GSM48__bcap__ra::enum_type other_value);
GSM48__bcap__ra_template(const GSM48__bcap__ra& other_value);
GSM48__bcap__ra_template(const OPTIONAL<GSM48__bcap__ra>& other_value);
GSM48__bcap__ra_template(const GSM48__bcap__ra_template& other_value);
~GSM48__bcap__ra_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__ra_template& operator=(template_sel other_value);
GSM48__bcap__ra_template& operator=(int other_value);
GSM48__bcap__ra_template& operator=(GSM48__bcap__ra::enum_type other_value);
GSM48__bcap__ra_template& operator=(const GSM48__bcap__ra& other_value);
GSM48__bcap__ra_template& operator=(const OPTIONAL<GSM48__bcap__ra>& other_value);
GSM48__bcap__ra_template& operator=(const GSM48__bcap__ra_template& other_value);

boolean match(GSM48__bcap__ra::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__ra& other_value, boolean legacy = FALSE) const;
GSM48__bcap__ra::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__ra_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__ra& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__sig__access : public Base_Type { // enum
friend class GSM48__bcap__sig__access_template;
public:
enum enum_type { GSM48__BCAP__SA__NONE = 0, GSM48__BCAP__SA__I440__I450 = 1, GSM48__BCAP__SA__X21 = 2, GSM48__BCAP__SA__X28__DP__IN = 3, GSM48__BCAP__SA__X28__DP__UN = 4, GSM48__BCAP__SA__X28__NDP = 5, GSM48__BCAP__SA__X32 = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
GSM48__bcap__sig__access();
GSM48__bcap__sig__access(int other_value);
GSM48__bcap__sig__access(enum_type other_value);
GSM48__bcap__sig__access(const GSM48__bcap__sig__access& other_value);

GSM48__bcap__sig__access& operator=(int other_value);
GSM48__bcap__sig__access& operator=(enum_type other_value);
GSM48__bcap__sig__access& operator=(const GSM48__bcap__sig__access& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__sig__access& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__sig__access& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__sig__access& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__sig__access& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__sig__access& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__sig__access& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__sig__access& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__sig__access_template : public Base_Template {
union {
GSM48__bcap__sig__access::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__sig__access_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__sig__access_template& other_value);

public:
GSM48__bcap__sig__access_template();
GSM48__bcap__sig__access_template(template_sel other_value);
GSM48__bcap__sig__access_template(int other_value);
GSM48__bcap__sig__access_template(GSM48__bcap__sig__access::enum_type other_value);
GSM48__bcap__sig__access_template(const GSM48__bcap__sig__access& other_value);
GSM48__bcap__sig__access_template(const OPTIONAL<GSM48__bcap__sig__access>& other_value);
GSM48__bcap__sig__access_template(const GSM48__bcap__sig__access_template& other_value);
~GSM48__bcap__sig__access_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__sig__access_template& operator=(template_sel other_value);
GSM48__bcap__sig__access_template& operator=(int other_value);
GSM48__bcap__sig__access_template& operator=(GSM48__bcap__sig__access::enum_type other_value);
GSM48__bcap__sig__access_template& operator=(const GSM48__bcap__sig__access& other_value);
GSM48__bcap__sig__access_template& operator=(const OPTIONAL<GSM48__bcap__sig__access>& other_value);
GSM48__bcap__sig__access_template& operator=(const GSM48__bcap__sig__access_template& other_value);

boolean match(GSM48__bcap__sig__access::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__sig__access& other_value, boolean legacy = FALSE) const;
GSM48__bcap__sig__access::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__sig__access_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__sig__access& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__user__rate : public Base_Type { // enum
friend class GSM48__bcap__user__rate_template;
public:
enum enum_type { GSM48__BCAP__UR__NONE = 0, GSM48__BCAP__UR__300 = 1, GSM48__BCAP__UR__1200 = 2, GSM48__BCAP__UR__2400 = 3, GSM48__BCAP__UR__4800 = 4, GSM48__BCAP__UR__9600 = 5, GSM48__BCAP__UR__12000 = 6, GSM48__BCAP__UR__1200__75 = 7, UNKNOWN_VALUE = 8, UNBOUND_VALUE = 9 };
private:
enum_type enum_value;

public:
GSM48__bcap__user__rate();
GSM48__bcap__user__rate(int other_value);
GSM48__bcap__user__rate(enum_type other_value);
GSM48__bcap__user__rate(const GSM48__bcap__user__rate& other_value);

GSM48__bcap__user__rate& operator=(int other_value);
GSM48__bcap__user__rate& operator=(enum_type other_value);
GSM48__bcap__user__rate& operator=(const GSM48__bcap__user__rate& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__user__rate& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__user__rate& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__user__rate& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__user__rate& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__user__rate& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__user__rate& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__user__rate& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__user__rate_template : public Base_Template {
union {
GSM48__bcap__user__rate::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__user__rate_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__user__rate_template& other_value);

public:
GSM48__bcap__user__rate_template();
GSM48__bcap__user__rate_template(template_sel other_value);
GSM48__bcap__user__rate_template(int other_value);
GSM48__bcap__user__rate_template(GSM48__bcap__user__rate::enum_type other_value);
GSM48__bcap__user__rate_template(const GSM48__bcap__user__rate& other_value);
GSM48__bcap__user__rate_template(const OPTIONAL<GSM48__bcap__user__rate>& other_value);
GSM48__bcap__user__rate_template(const GSM48__bcap__user__rate_template& other_value);
~GSM48__bcap__user__rate_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__user__rate_template& operator=(template_sel other_value);
GSM48__bcap__user__rate_template& operator=(int other_value);
GSM48__bcap__user__rate_template& operator=(GSM48__bcap__user__rate::enum_type other_value);
GSM48__bcap__user__rate_template& operator=(const GSM48__bcap__user__rate& other_value);
GSM48__bcap__user__rate_template& operator=(const OPTIONAL<GSM48__bcap__user__rate>& other_value);
GSM48__bcap__user__rate_template& operator=(const GSM48__bcap__user__rate_template& other_value);

boolean match(GSM48__bcap__user__rate::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__user__rate& other_value, boolean legacy = FALSE) const;
GSM48__bcap__user__rate::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__user__rate_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__user__rate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__parity : public Base_Type { // enum
friend class GSM48__bcap__parity_template;
public:
enum enum_type { GSM48__BCAP__PAR__ODD = 0, GSM48__BCAP__PAR__EVEN = 2, GSM48__BCAP__PAR__NONE = 3, GSM48__BCAP__PAR__ZERO = 4, GSM48__BCAP__PAR__ONE = 5, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
GSM48__bcap__parity();
GSM48__bcap__parity(int other_value);
GSM48__bcap__parity(enum_type other_value);
GSM48__bcap__parity(const GSM48__bcap__parity& other_value);

GSM48__bcap__parity& operator=(int other_value);
GSM48__bcap__parity& operator=(enum_type other_value);
GSM48__bcap__parity& operator=(const GSM48__bcap__parity& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__parity& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__parity& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__parity& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__parity& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__parity& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__parity& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__parity& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__parity_template : public Base_Template {
union {
GSM48__bcap__parity::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__parity_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__parity_template& other_value);

public:
GSM48__bcap__parity_template();
GSM48__bcap__parity_template(template_sel other_value);
GSM48__bcap__parity_template(int other_value);
GSM48__bcap__parity_template(GSM48__bcap__parity::enum_type other_value);
GSM48__bcap__parity_template(const GSM48__bcap__parity& other_value);
GSM48__bcap__parity_template(const OPTIONAL<GSM48__bcap__parity>& other_value);
GSM48__bcap__parity_template(const GSM48__bcap__parity_template& other_value);
~GSM48__bcap__parity_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__parity_template& operator=(template_sel other_value);
GSM48__bcap__parity_template& operator=(int other_value);
GSM48__bcap__parity_template& operator=(GSM48__bcap__parity::enum_type other_value);
GSM48__bcap__parity_template& operator=(const GSM48__bcap__parity& other_value);
GSM48__bcap__parity_template& operator=(const OPTIONAL<GSM48__bcap__parity>& other_value);
GSM48__bcap__parity_template& operator=(const GSM48__bcap__parity_template& other_value);

boolean match(GSM48__bcap__parity::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__parity& other_value, boolean legacy = FALSE) const;
GSM48__bcap__parity::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__parity_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__parity& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__interm__rate : public Base_Type { // enum
friend class GSM48__bcap__interm__rate_template;
public:
enum enum_type { GSM48__BCAP__IR__NONE = 0, GSM48__BCAP__IR__8k = 2, GSM48__BCAP__IR__16k = 3, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
GSM48__bcap__interm__rate();
GSM48__bcap__interm__rate(int other_value);
GSM48__bcap__interm__rate(enum_type other_value);
GSM48__bcap__interm__rate(const GSM48__bcap__interm__rate& other_value);

GSM48__bcap__interm__rate& operator=(int other_value);
GSM48__bcap__interm__rate& operator=(enum_type other_value);
GSM48__bcap__interm__rate& operator=(const GSM48__bcap__interm__rate& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__interm__rate& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__interm__rate& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__interm__rate& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__interm__rate& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__interm__rate& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__interm__rate& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__interm__rate& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__interm__rate_template : public Base_Template {
union {
GSM48__bcap__interm__rate::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__interm__rate_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__interm__rate_template& other_value);

public:
GSM48__bcap__interm__rate_template();
GSM48__bcap__interm__rate_template(template_sel other_value);
GSM48__bcap__interm__rate_template(int other_value);
GSM48__bcap__interm__rate_template(GSM48__bcap__interm__rate::enum_type other_value);
GSM48__bcap__interm__rate_template(const GSM48__bcap__interm__rate& other_value);
GSM48__bcap__interm__rate_template(const OPTIONAL<GSM48__bcap__interm__rate>& other_value);
GSM48__bcap__interm__rate_template(const GSM48__bcap__interm__rate_template& other_value);
~GSM48__bcap__interm__rate_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__interm__rate_template& operator=(template_sel other_value);
GSM48__bcap__interm__rate_template& operator=(int other_value);
GSM48__bcap__interm__rate_template& operator=(GSM48__bcap__interm__rate::enum_type other_value);
GSM48__bcap__interm__rate_template& operator=(const GSM48__bcap__interm__rate& other_value);
GSM48__bcap__interm__rate_template& operator=(const OPTIONAL<GSM48__bcap__interm__rate>& other_value);
GSM48__bcap__interm__rate_template& operator=(const GSM48__bcap__interm__rate_template& other_value);

boolean match(GSM48__bcap__interm__rate::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__interm__rate& other_value, boolean legacy = FALSE) const;
GSM48__bcap__interm__rate::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__interm__rate_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__interm__rate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__transp : public Base_Type { // enum
friend class GSM48__bcap__transp_template;
public:
enum enum_type { GSM48__BCAP__TR__TRANSP = 0, GSM48__BCAP__TR__RLP = 1, GSM48__BCAP__TR__TR__PREF = 2, GSM48__BCAP__TR__RLP__PREF = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__bcap__transp();
GSM48__bcap__transp(int other_value);
GSM48__bcap__transp(enum_type other_value);
GSM48__bcap__transp(const GSM48__bcap__transp& other_value);

GSM48__bcap__transp& operator=(int other_value);
GSM48__bcap__transp& operator=(enum_type other_value);
GSM48__bcap__transp& operator=(const GSM48__bcap__transp& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__transp& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__transp& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__transp& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__transp& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__transp& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__transp& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__transp& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__transp_template : public Base_Template {
union {
GSM48__bcap__transp::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__transp_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__transp_template& other_value);

public:
GSM48__bcap__transp_template();
GSM48__bcap__transp_template(template_sel other_value);
GSM48__bcap__transp_template(int other_value);
GSM48__bcap__transp_template(GSM48__bcap__transp::enum_type other_value);
GSM48__bcap__transp_template(const GSM48__bcap__transp& other_value);
GSM48__bcap__transp_template(const OPTIONAL<GSM48__bcap__transp>& other_value);
GSM48__bcap__transp_template(const GSM48__bcap__transp_template& other_value);
~GSM48__bcap__transp_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__transp_template& operator=(template_sel other_value);
GSM48__bcap__transp_template& operator=(int other_value);
GSM48__bcap__transp_template& operator=(GSM48__bcap__transp::enum_type other_value);
GSM48__bcap__transp_template& operator=(const GSM48__bcap__transp& other_value);
GSM48__bcap__transp_template& operator=(const OPTIONAL<GSM48__bcap__transp>& other_value);
GSM48__bcap__transp_template& operator=(const GSM48__bcap__transp_template& other_value);

boolean match(GSM48__bcap__transp::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__transp& other_value, boolean legacy = FALSE) const;
GSM48__bcap__transp::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__transp_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__transp& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__bcap__modem__type : public Base_Type { // enum
friend class GSM48__bcap__modem__type_template;
public:
enum enum_type { GSM48__BCAP__MT__NONE = 0, GSM48__BCAP__MT__V21 = 1, GSM48__BCAP__MT__V22 = 2, GSM48__BCAP__MT__V22bis = 3, GSM48__BCAP__MT__V23 = 4, GSM48__BCAP__MT__V26ter = 5, GSM48__BCAP__MT__V32 = 6, GSM48__BCAP__MT__UNDEF = 7, GSM48__BCAP__MT__AUTO__1 = 8, UNKNOWN_VALUE = 9, UNBOUND_VALUE = 10 };
private:
enum_type enum_value;

public:
GSM48__bcap__modem__type();
GSM48__bcap__modem__type(int other_value);
GSM48__bcap__modem__type(enum_type other_value);
GSM48__bcap__modem__type(const GSM48__bcap__modem__type& other_value);

GSM48__bcap__modem__type& operator=(int other_value);
GSM48__bcap__modem__type& operator=(enum_type other_value);
GSM48__bcap__modem__type& operator=(const GSM48__bcap__modem__type& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__bcap__modem__type& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__bcap__modem__type& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__bcap__modem__type& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__bcap__modem__type& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__bcap__modem__type& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__bcap__modem__type& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__bcap__modem__type& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__bcap__modem__type_template : public Base_Template {
union {
GSM48__bcap__modem__type::enum_type single_value;
struct {
unsigned int n_values;
GSM48__bcap__modem__type_template *list_value;
} value_list;
};

void copy_template(const GSM48__bcap__modem__type_template& other_value);

public:
GSM48__bcap__modem__type_template();
GSM48__bcap__modem__type_template(template_sel other_value);
GSM48__bcap__modem__type_template(int other_value);
GSM48__bcap__modem__type_template(GSM48__bcap__modem__type::enum_type other_value);
GSM48__bcap__modem__type_template(const GSM48__bcap__modem__type& other_value);
GSM48__bcap__modem__type_template(const OPTIONAL<GSM48__bcap__modem__type>& other_value);
GSM48__bcap__modem__type_template(const GSM48__bcap__modem__type_template& other_value);
~GSM48__bcap__modem__type_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__bcap__modem__type_template& operator=(template_sel other_value);
GSM48__bcap__modem__type_template& operator=(int other_value);
GSM48__bcap__modem__type_template& operator=(GSM48__bcap__modem__type::enum_type other_value);
GSM48__bcap__modem__type_template& operator=(const GSM48__bcap__modem__type& other_value);
GSM48__bcap__modem__type_template& operator=(const OPTIONAL<GSM48__bcap__modem__type>& other_value);
GSM48__bcap__modem__type_template& operator=(const GSM48__bcap__modem__type_template& other_value);

boolean match(GSM48__bcap__modem__type::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__bcap__modem__type& other_value, boolean legacy = FALSE) const;
GSM48__bcap__modem__type::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__bcap__modem__type_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__bcap__modem__type& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__MsgType : public Base_Type { // enum
friend class MNCC__MsgType_template;
public:
enum enum_type { MNCC__SETUP__REQ = 257, MNCC__SETUP__IND = 258, MNCC__SETUP__RSP = 259, MNCC__SETUP__CNF = 260, MNCC__SETUP__COMPL__REQ = 261, MNCC__SETUP__COMPL__IND = 262, MNCC__CALL__CONF__IND = 263, MNCC__CALL__PROC__REQ = 264, MNCC__PROGRESS__REQ = 265, MNCC__ALERT__REQ = 266, MNCC__ALERT__IND = 267, MNCC__NOTIFY__REQ = 268, MNCC__NOTIFY__IND = 269, MNCC__DISC__REQ = 270, MNCC__DISC__IND = 271, MNCC__REL__REQ = 272, MNCC__REL__IND = 273, MNCC__REL__CNF = 274, MNCC__FACILITY__REQ = 275, MNCC__FACILITY__IND = 276, MNCC__START__DTMF__IND = 277, MNCC__START__DTMF__RSP = 278, MNCC__START__DTMF__REJ = 279, MNCC__STOP__DTMF__IND = 280, MNCC__STOP__DTMF__RSP = 281, MNCC__MODIFY__REQ = 282, MNCC__MODIFY__IND = 283, MNCC__MODIFY__RSP = 284, MNCC__MODIFY__CNF = 285, MNCC__MODIFY__REJ = 286, MNCC__HOLD__IND = 287, MNCC__HOLD__CNF = 288, MNCC__HOLD__REJ = 289, MNCC__RETRIEVE__IND = 290, MNCC__RETRIEVE__CNF = 291, MNCC__RETRIEVE__REJ = 292, MNCC__USERINFO__REQ = 293, MNCC__USERINFO__IND = 294, MNCC__REJ__REQ = 295, MNCC__REJ__IND = 296, MNCC__BRIDGE = 512, MNCC__FRAME__RECV = 513, MNCC__FRAME__DROP = 514, MNCC__LCHAN__MODIFY = 515, MNCC__RTP__CREATE = 516, MNCC__RTP__CONNECT = 517, MNCC__RTP__FREE = 518, GSM__TCHF__FRAME = 768, GSM__TCHF__FRAME__EFR = 769, GSM__TCHH__FRAME = 770, GSM__TCH__FRAME__AMR = 771, GSM__BAD__FRAME = 1023, MNCC__SOCKET__HELLO = 1024, UNKNOWN_VALUE = 0, UNBOUND_VALUE = 1 };
private:
enum_type enum_value;

public:
MNCC__MsgType();
MNCC__MsgType(int other_value);
MNCC__MsgType(enum_type other_value);
MNCC__MsgType(const MNCC__MsgType& other_value);

MNCC__MsgType& operator=(int other_value);
MNCC__MsgType& operator=(enum_type other_value);
MNCC__MsgType& operator=(const MNCC__MsgType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MNCC__MsgType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MNCC__MsgType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MNCC__MsgType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MNCC__MsgType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MNCC__MsgType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MNCC__MsgType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MNCC__MsgType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__MsgType_template : public Base_Template {
union {
MNCC__MsgType::enum_type single_value;
struct {
unsigned int n_values;
MNCC__MsgType_template *list_value;
} value_list;
};

void copy_template(const MNCC__MsgType_template& other_value);

public:
MNCC__MsgType_template();
MNCC__MsgType_template(template_sel other_value);
MNCC__MsgType_template(int other_value);
MNCC__MsgType_template(MNCC__MsgType::enum_type other_value);
MNCC__MsgType_template(const MNCC__MsgType& other_value);
MNCC__MsgType_template(const OPTIONAL<MNCC__MsgType>& other_value);
MNCC__MsgType_template(const MNCC__MsgType_template& other_value);
~MNCC__MsgType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__MsgType_template& operator=(template_sel other_value);
MNCC__MsgType_template& operator=(int other_value);
MNCC__MsgType_template& operator=(MNCC__MsgType::enum_type other_value);
MNCC__MsgType_template& operator=(const MNCC__MsgType& other_value);
MNCC__MsgType_template& operator=(const OPTIONAL<MNCC__MsgType>& other_value);
MNCC__MsgType_template& operator=(const MNCC__MsgType_template& other_value);

boolean match(MNCC__MsgType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const MNCC__MsgType& other_value, boolean legacy = FALSE) const;
MNCC__MsgType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__MsgType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MNCC__MsgType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__bearer__cap__data : public Base_Type {
  GSM48__bcap__ra field_rate__adaptation;
  GSM48__bcap__sig__access field_sig__access;
  INTEGER field_async;
  INTEGER field_nr__stop__bits;
  INTEGER field_nr__data__bits;
  GSM48__bcap__user__rate field_user__rate;
  GSM48__bcap__parity field_parity;
  GSM48__bcap__interm__rate field_interm__rate;
  GSM48__bcap__transp field_transp;
  GSM48__bcap__modem__type field_modem__type;
public:
  MNCC__bearer__cap__data();
  MNCC__bearer__cap__data(const GSM48__bcap__ra& par_rate__adaptation,
    const GSM48__bcap__sig__access& par_sig__access,
    const INTEGER& par_async,
    const INTEGER& par_nr__stop__bits,
    const INTEGER& par_nr__data__bits,
    const GSM48__bcap__user__rate& par_user__rate,
    const GSM48__bcap__parity& par_parity,
    const GSM48__bcap__interm__rate& par_interm__rate,
    const GSM48__bcap__transp& par_transp,
    const GSM48__bcap__modem__type& par_modem__type);
  MNCC__bearer__cap__data(const MNCC__bearer__cap__data& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__bearer__cap__data& operator=(const MNCC__bearer__cap__data& other_value);
  boolean operator==(const MNCC__bearer__cap__data& other_value) const;
  inline boolean operator!=(const MNCC__bearer__cap__data& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GSM48__bcap__ra& rate__adaptation()
    {return field_rate__adaptation;}
  inline const GSM48__bcap__ra& rate__adaptation() const
    {return field_rate__adaptation;}
  inline GSM48__bcap__sig__access& sig__access()
    {return field_sig__access;}
  inline const GSM48__bcap__sig__access& sig__access() const
    {return field_sig__access;}
  inline INTEGER& async()
    {return field_async;}
  inline const INTEGER& async() const
    {return field_async;}
  inline INTEGER& nr__stop__bits()
    {return field_nr__stop__bits;}
  inline const INTEGER& nr__stop__bits() const
    {return field_nr__stop__bits;}
  inline INTEGER& nr__data__bits()
    {return field_nr__data__bits;}
  inline const INTEGER& nr__data__bits() const
    {return field_nr__data__bits;}
  inline GSM48__bcap__user__rate& user__rate()
    {return field_user__rate;}
  inline const GSM48__bcap__user__rate& user__rate() const
    {return field_user__rate;}
  inline GSM48__bcap__parity& parity()
    {return field_parity;}
  inline const GSM48__bcap__parity& parity() const
    {return field_parity;}
  inline GSM48__bcap__interm__rate& interm__rate()
    {return field_interm__rate;}
  inline const GSM48__bcap__interm__rate& interm__rate() const
    {return field_interm__rate;}
  inline GSM48__bcap__transp& transp()
    {return field_transp;}
  inline const GSM48__bcap__transp& transp() const
    {return field_transp;}
  inline GSM48__bcap__modem__type& modem__type()
    {return field_modem__type;}
  inline const GSM48__bcap__modem__type& modem__type() const
    {return field_modem__type;}
  inline int size_of() const
    {return 10;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__bearer__cap__data_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__bearer__cap__data_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__bearer__cap__data& other_value);
void copy_template(const MNCC__bearer__cap__data_template& other_value);

public:
MNCC__bearer__cap__data_template();
MNCC__bearer__cap__data_template(template_sel other_value);
MNCC__bearer__cap__data_template(const MNCC__bearer__cap__data& other_value);
MNCC__bearer__cap__data_template(const OPTIONAL<MNCC__bearer__cap__data>& other_value);
MNCC__bearer__cap__data_template(const MNCC__bearer__cap__data_template& other_value);
~MNCC__bearer__cap__data_template();
MNCC__bearer__cap__data_template& operator=(template_sel other_value);
MNCC__bearer__cap__data_template& operator=(const MNCC__bearer__cap__data& other_value);
MNCC__bearer__cap__data_template& operator=(const OPTIONAL<MNCC__bearer__cap__data>& other_value);
MNCC__bearer__cap__data_template& operator=(const MNCC__bearer__cap__data_template& other_value);
boolean match(const MNCC__bearer__cap__data& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__bearer__cap__data valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__bearer__cap__data_template& list_item(unsigned int list_index) const;
GSM48__bcap__ra_template& rate__adaptation();
const GSM48__bcap__ra_template& rate__adaptation() const;
GSM48__bcap__sig__access_template& sig__access();
const GSM48__bcap__sig__access_template& sig__access() const;
INTEGER_template& async();
const INTEGER_template& async() const;
INTEGER_template& nr__stop__bits();
const INTEGER_template& nr__stop__bits() const;
INTEGER_template& nr__data__bits();
const INTEGER_template& nr__data__bits() const;
GSM48__bcap__user__rate_template& user__rate();
const GSM48__bcap__user__rate_template& user__rate() const;
GSM48__bcap__parity_template& parity();
const GSM48__bcap__parity_template& parity() const;
GSM48__bcap__interm__rate_template& interm__rate();
const GSM48__bcap__interm__rate_template& interm__rate() const;
GSM48__bcap__transp_template& transp();
const GSM48__bcap__transp_template& transp() const;
GSM48__bcap__modem__type_template& modem__type();
const GSM48__bcap__modem__type_template& modem__type() const;
int size_of() const;
void log() const;
void log_match(const MNCC__bearer__cap__data& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__bearer__cap : public Base_Type {
  INTEGER field_transfer;
  INTEGER field_mode;
  INTEGER field_coding;
  INTEGER field_radio;
  INTEGER field_speech__ctm;
  MNCC__speech__vers field_speech__ver;
  OPTIONAL<MNCC__bearer__cap__data> field_data;
public:
  MNCC__bearer__cap();
  MNCC__bearer__cap(const INTEGER& par_transfer,
    const INTEGER& par_mode,
    const INTEGER& par_coding,
    const INTEGER& par_radio,
    const INTEGER& par_speech__ctm,
    const MNCC__speech__vers& par_speech__ver,
    const OPTIONAL<MNCC__bearer__cap__data>& par_data);
  MNCC__bearer__cap(const MNCC__bearer__cap& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__bearer__cap& operator=(const MNCC__bearer__cap& other_value);
  boolean operator==(const MNCC__bearer__cap& other_value) const;
  inline boolean operator!=(const MNCC__bearer__cap& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& transfer()
    {return field_transfer;}
  inline const INTEGER& transfer() const
    {return field_transfer;}
  inline INTEGER& mode()
    {return field_mode;}
  inline const INTEGER& mode() const
    {return field_mode;}
  inline INTEGER& coding()
    {return field_coding;}
  inline const INTEGER& coding() const
    {return field_coding;}
  inline INTEGER& radio()
    {return field_radio;}
  inline const INTEGER& radio() const
    {return field_radio;}
  inline INTEGER& speech__ctm()
    {return field_speech__ctm;}
  inline const INTEGER& speech__ctm() const
    {return field_speech__ctm;}
  inline MNCC__speech__vers& speech__ver()
    {return field_speech__ver;}
  inline const MNCC__speech__vers& speech__ver() const
    {return field_speech__ver;}
  inline OPTIONAL<MNCC__bearer__cap__data>& data()
    {return field_data;}
  inline const OPTIONAL<MNCC__bearer__cap__data>& data() const
    {return field_data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__bearer__cap_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__bearer__cap_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__bearer__cap& other_value);
void copy_template(const MNCC__bearer__cap_template& other_value);

public:
MNCC__bearer__cap_template();
MNCC__bearer__cap_template(template_sel other_value);
MNCC__bearer__cap_template(const MNCC__bearer__cap& other_value);
MNCC__bearer__cap_template(const OPTIONAL<MNCC__bearer__cap>& other_value);
MNCC__bearer__cap_template(const MNCC__bearer__cap_template& other_value);
~MNCC__bearer__cap_template();
MNCC__bearer__cap_template& operator=(template_sel other_value);
MNCC__bearer__cap_template& operator=(const MNCC__bearer__cap& other_value);
MNCC__bearer__cap_template& operator=(const OPTIONAL<MNCC__bearer__cap>& other_value);
MNCC__bearer__cap_template& operator=(const MNCC__bearer__cap_template& other_value);
boolean match(const MNCC__bearer__cap& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__bearer__cap valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__bearer__cap_template& list_item(unsigned int list_index) const;
INTEGER_template& transfer();
const INTEGER_template& transfer() const;
INTEGER_template& mode();
const INTEGER_template& mode() const;
INTEGER_template& coding();
const INTEGER_template& coding() const;
INTEGER_template& radio();
const INTEGER_template& radio() const;
INTEGER_template& speech__ctm();
const INTEGER_template& speech__ctm() const;
MNCC__speech__vers_template& speech__ver();
const MNCC__speech__vers_template& speech__ver() const;
MNCC__bearer__cap__data_template& data();
const MNCC__bearer__cap__data_template& data() const;
int size_of() const;
void log() const;
void log_match(const MNCC__bearer__cap& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GSM48__type__of__number : public Base_Type { // enum
friend class GSM48__type__of__number_template;
public:
enum enum_type { GSM48__TON__UNKNOWN = 0, GSM48__TON__INTERNATIONAL = 1, GSM48__TON__NATIONAL = 2, GSM48__TON__NETWORK__SPECIFIC = 3, GSM48__TON__SHORT__CODE = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
GSM48__type__of__number();
GSM48__type__of__number(int other_value);
GSM48__type__of__number(enum_type other_value);
GSM48__type__of__number(const GSM48__type__of__number& other_value);

GSM48__type__of__number& operator=(int other_value);
GSM48__type__of__number& operator=(enum_type other_value);
GSM48__type__of__number& operator=(const GSM48__type__of__number& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__type__of__number& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__type__of__number& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__type__of__number& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__type__of__number& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__type__of__number& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__type__of__number& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__type__of__number& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__type__of__number_template : public Base_Template {
union {
GSM48__type__of__number::enum_type single_value;
struct {
unsigned int n_values;
GSM48__type__of__number_template *list_value;
} value_list;
};

void copy_template(const GSM48__type__of__number_template& other_value);

public:
GSM48__type__of__number_template();
GSM48__type__of__number_template(template_sel other_value);
GSM48__type__of__number_template(int other_value);
GSM48__type__of__number_template(GSM48__type__of__number::enum_type other_value);
GSM48__type__of__number_template(const GSM48__type__of__number& other_value);
GSM48__type__of__number_template(const OPTIONAL<GSM48__type__of__number>& other_value);
GSM48__type__of__number_template(const GSM48__type__of__number_template& other_value);
~GSM48__type__of__number_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__type__of__number_template& operator=(template_sel other_value);
GSM48__type__of__number_template& operator=(int other_value);
GSM48__type__of__number_template& operator=(GSM48__type__of__number::enum_type other_value);
GSM48__type__of__number_template& operator=(const GSM48__type__of__number& other_value);
GSM48__type__of__number_template& operator=(const OPTIONAL<GSM48__type__of__number>& other_value);
GSM48__type__of__number_template& operator=(const GSM48__type__of__number_template& other_value);

boolean match(GSM48__type__of__number::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__type__of__number& other_value, boolean legacy = FALSE) const;
GSM48__type__of__number::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__type__of__number_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__type__of__number& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__num__plan__ind : public Base_Type { // enum
friend class GSM48__num__plan__ind_template;
public:
enum enum_type { GSM48__NUMPLAN__UNKNOWN = 0, GSM48__NUMPLAN__E164 = 1, GSM48__NUMPLAN__X121 = 3, GSM48__NUMPLAN__F69 = 4, GSM48__NUMPLAN__NATIONAL = 8, GSM48__NUMPLAN__PRIVATE = 9, GSM48__NUMPLAN__CTS = 11, GSM48__NUMPLAN__RESERVED = 15, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__num__plan__ind();
GSM48__num__plan__ind(int other_value);
GSM48__num__plan__ind(enum_type other_value);
GSM48__num__plan__ind(const GSM48__num__plan__ind& other_value);

GSM48__num__plan__ind& operator=(int other_value);
GSM48__num__plan__ind& operator=(enum_type other_value);
GSM48__num__plan__ind& operator=(const GSM48__num__plan__ind& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__num__plan__ind& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__num__plan__ind& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__num__plan__ind& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__num__plan__ind& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__num__plan__ind& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__num__plan__ind& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__num__plan__ind& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__num__plan__ind_template : public Base_Template {
union {
GSM48__num__plan__ind::enum_type single_value;
struct {
unsigned int n_values;
GSM48__num__plan__ind_template *list_value;
} value_list;
};

void copy_template(const GSM48__num__plan__ind_template& other_value);

public:
GSM48__num__plan__ind_template();
GSM48__num__plan__ind_template(template_sel other_value);
GSM48__num__plan__ind_template(int other_value);
GSM48__num__plan__ind_template(GSM48__num__plan__ind::enum_type other_value);
GSM48__num__plan__ind_template(const GSM48__num__plan__ind& other_value);
GSM48__num__plan__ind_template(const OPTIONAL<GSM48__num__plan__ind>& other_value);
GSM48__num__plan__ind_template(const GSM48__num__plan__ind_template& other_value);
~GSM48__num__plan__ind_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__num__plan__ind_template& operator=(template_sel other_value);
GSM48__num__plan__ind_template& operator=(int other_value);
GSM48__num__plan__ind_template& operator=(GSM48__num__plan__ind::enum_type other_value);
GSM48__num__plan__ind_template& operator=(const GSM48__num__plan__ind& other_value);
GSM48__num__plan__ind_template& operator=(const OPTIONAL<GSM48__num__plan__ind>& other_value);
GSM48__num__plan__ind_template& operator=(const GSM48__num__plan__ind_template& other_value);

boolean match(GSM48__num__plan__ind::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__num__plan__ind& other_value, boolean legacy = FALSE) const;
GSM48__num__plan__ind::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__num__plan__ind_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__num__plan__ind& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__present__ind : public Base_Type { // enum
friend class GSM48__present__ind_template;
public:
enum enum_type { GSM48__PRES__IND__ALLOWED = 0, GSM48__PRES__IND__RESTRICTED = 1, GSM48__PRES__IND__NUM__NOT__AVAIL = 2, GSM48__PRES__IND__RESERVED = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__present__ind();
GSM48__present__ind(int other_value);
GSM48__present__ind(enum_type other_value);
GSM48__present__ind(const GSM48__present__ind& other_value);

GSM48__present__ind& operator=(int other_value);
GSM48__present__ind& operator=(enum_type other_value);
GSM48__present__ind& operator=(const GSM48__present__ind& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__present__ind& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__present__ind& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__present__ind& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__present__ind& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__present__ind& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__present__ind& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__present__ind& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__present__ind_template : public Base_Template {
union {
GSM48__present__ind::enum_type single_value;
struct {
unsigned int n_values;
GSM48__present__ind_template *list_value;
} value_list;
};

void copy_template(const GSM48__present__ind_template& other_value);

public:
GSM48__present__ind_template();
GSM48__present__ind_template(template_sel other_value);
GSM48__present__ind_template(int other_value);
GSM48__present__ind_template(GSM48__present__ind::enum_type other_value);
GSM48__present__ind_template(const GSM48__present__ind& other_value);
GSM48__present__ind_template(const OPTIONAL<GSM48__present__ind>& other_value);
GSM48__present__ind_template(const GSM48__present__ind_template& other_value);
~GSM48__present__ind_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__present__ind_template& operator=(template_sel other_value);
GSM48__present__ind_template& operator=(int other_value);
GSM48__present__ind_template& operator=(GSM48__present__ind::enum_type other_value);
GSM48__present__ind_template& operator=(const GSM48__present__ind& other_value);
GSM48__present__ind_template& operator=(const OPTIONAL<GSM48__present__ind>& other_value);
GSM48__present__ind_template& operator=(const GSM48__present__ind_template& other_value);

boolean match(GSM48__present__ind::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__present__ind& other_value, boolean legacy = FALSE) const;
GSM48__present__ind::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__present__ind_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__present__ind& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__screening__ind : public Base_Type { // enum
friend class GSM48__screening__ind_template;
public:
enum enum_type { GSM48__SCR__IND__NOT__SCREENED = 0, GSM48__SCR__IND__VERIF__PASSED = 1, GSM48__SCR__IND__VERIF__FAILED = 2, GSM48__SCR__IND__NETW__PROVIDED = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__screening__ind();
GSM48__screening__ind(int other_value);
GSM48__screening__ind(enum_type other_value);
GSM48__screening__ind(const GSM48__screening__ind& other_value);

GSM48__screening__ind& operator=(int other_value);
GSM48__screening__ind& operator=(enum_type other_value);
GSM48__screening__ind& operator=(const GSM48__screening__ind& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__screening__ind& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__screening__ind& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__screening__ind& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__screening__ind& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__screening__ind& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__screening__ind& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__screening__ind& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__screening__ind_template : public Base_Template {
union {
GSM48__screening__ind::enum_type single_value;
struct {
unsigned int n_values;
GSM48__screening__ind_template *list_value;
} value_list;
};

void copy_template(const GSM48__screening__ind_template& other_value);

public:
GSM48__screening__ind_template();
GSM48__screening__ind_template(template_sel other_value);
GSM48__screening__ind_template(int other_value);
GSM48__screening__ind_template(GSM48__screening__ind::enum_type other_value);
GSM48__screening__ind_template(const GSM48__screening__ind& other_value);
GSM48__screening__ind_template(const OPTIONAL<GSM48__screening__ind>& other_value);
GSM48__screening__ind_template(const GSM48__screening__ind_template& other_value);
~GSM48__screening__ind_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__screening__ind_template& operator=(template_sel other_value);
GSM48__screening__ind_template& operator=(int other_value);
GSM48__screening__ind_template& operator=(GSM48__screening__ind::enum_type other_value);
GSM48__screening__ind_template& operator=(const GSM48__screening__ind& other_value);
GSM48__screening__ind_template& operator=(const OPTIONAL<GSM48__screening__ind>& other_value);
GSM48__screening__ind_template& operator=(const GSM48__screening__ind_template& other_value);

boolean match(GSM48__screening__ind::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__screening__ind& other_value, boolean legacy = FALSE) const;
GSM48__screening__ind::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__screening__ind_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__screening__ind& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__number : public Base_Type {
  GSM48__type__of__number field_number__type;
  GSM48__num__plan__ind field_plan;
  GSM48__present__ind field_presence;
  GSM48__screening__ind field_screen;
  CHARSTRING field_number;
public:
  MNCC__number();
  MNCC__number(const GSM48__type__of__number& par_number__type,
    const GSM48__num__plan__ind& par_plan,
    const GSM48__present__ind& par_presence,
    const GSM48__screening__ind& par_screen,
    const CHARSTRING& par_number);
  MNCC__number(const MNCC__number& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__number& operator=(const MNCC__number& other_value);
  boolean operator==(const MNCC__number& other_value) const;
  inline boolean operator!=(const MNCC__number& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GSM48__type__of__number& number__type()
    {return field_number__type;}
  inline const GSM48__type__of__number& number__type() const
    {return field_number__type;}
  inline GSM48__num__plan__ind& plan()
    {return field_plan;}
  inline const GSM48__num__plan__ind& plan() const
    {return field_plan;}
  inline GSM48__present__ind& presence()
    {return field_presence;}
  inline const GSM48__present__ind& presence() const
    {return field_presence;}
  inline GSM48__screening__ind& screen()
    {return field_screen;}
  inline const GSM48__screening__ind& screen() const
    {return field_screen;}
  inline CHARSTRING& number()
    {return field_number;}
  inline const CHARSTRING& number() const
    {return field_number;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__number_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__number_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__number& other_value);
void copy_template(const MNCC__number_template& other_value);

public:
MNCC__number_template();
MNCC__number_template(template_sel other_value);
MNCC__number_template(const MNCC__number& other_value);
MNCC__number_template(const OPTIONAL<MNCC__number>& other_value);
MNCC__number_template(const MNCC__number_template& other_value);
~MNCC__number_template();
MNCC__number_template& operator=(template_sel other_value);
MNCC__number_template& operator=(const MNCC__number& other_value);
MNCC__number_template& operator=(const OPTIONAL<MNCC__number>& other_value);
MNCC__number_template& operator=(const MNCC__number_template& other_value);
boolean match(const MNCC__number& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__number valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__number_template& list_item(unsigned int list_index) const;
GSM48__type__of__number_template& number__type();
const GSM48__type__of__number_template& number__type() const;
GSM48__num__plan__ind_template& plan();
const GSM48__num__plan__ind_template& plan() const;
GSM48__present__ind_template& presence();
const GSM48__present__ind_template& presence() const;
GSM48__screening__ind_template& screen();
const GSM48__screening__ind_template& screen() const;
CHARSTRING_template& number();
const CHARSTRING_template& number() const;
int size_of() const;
void log() const;
void log_match(const MNCC__number& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GSM48__cause__coding : public Base_Type { // enum
friend class GSM48__cause__coding_template;
public:
enum enum_type { GSM48__CAUSE__CS__Q931 = 0, GSM48__CAUSE__CS__RSVD = 1, GSM48__CAUSE__CS__NATIONAL = 2, GSM48__CAUSE__CS__GSM = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GSM48__cause__coding();
GSM48__cause__coding(int other_value);
GSM48__cause__coding(enum_type other_value);
GSM48__cause__coding(const GSM48__cause__coding& other_value);

GSM48__cause__coding& operator=(int other_value);
GSM48__cause__coding& operator=(enum_type other_value);
GSM48__cause__coding& operator=(const GSM48__cause__coding& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__cause__coding& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__cause__coding& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__cause__coding& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__cause__coding& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__cause__coding& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__cause__coding& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__cause__coding& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__cause__coding_template : public Base_Template {
union {
GSM48__cause__coding::enum_type single_value;
struct {
unsigned int n_values;
GSM48__cause__coding_template *list_value;
} value_list;
};

void copy_template(const GSM48__cause__coding_template& other_value);

public:
GSM48__cause__coding_template();
GSM48__cause__coding_template(template_sel other_value);
GSM48__cause__coding_template(int other_value);
GSM48__cause__coding_template(GSM48__cause__coding::enum_type other_value);
GSM48__cause__coding_template(const GSM48__cause__coding& other_value);
GSM48__cause__coding_template(const OPTIONAL<GSM48__cause__coding>& other_value);
GSM48__cause__coding_template(const GSM48__cause__coding_template& other_value);
~GSM48__cause__coding_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__cause__coding_template& operator=(template_sel other_value);
GSM48__cause__coding_template& operator=(int other_value);
GSM48__cause__coding_template& operator=(GSM48__cause__coding::enum_type other_value);
GSM48__cause__coding_template& operator=(const GSM48__cause__coding& other_value);
GSM48__cause__coding_template& operator=(const OPTIONAL<GSM48__cause__coding>& other_value);
GSM48__cause__coding_template& operator=(const GSM48__cause__coding_template& other_value);

boolean match(GSM48__cause__coding::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__cause__coding& other_value, boolean legacy = FALSE) const;
GSM48__cause__coding::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__cause__coding_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__cause__coding& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GSM48__cause__loc : public Base_Type { // enum
friend class GSM48__cause__loc_template;
public:
enum enum_type { GSM48__CAUSE__LOC__USER = 0, GSM48__CAUSE__LOC__PRN__S__LU = 1, GSM48__CAUSE__LOC__PUN__S__LU = 2, GSM48__CAUSE__LOC__TRANS__NET = 3, GSM48__CAUSE__LOC__PUN__S__RU = 4, GSM48__CAUSE__LOC__PRN__S__RU = 5, GSM48__CAUSE__LOC__INN__NET = 7, GSM48__CAUSE__LOC__NET__BEYOND = 10, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
GSM48__cause__loc();
GSM48__cause__loc(int other_value);
GSM48__cause__loc(enum_type other_value);
GSM48__cause__loc(const GSM48__cause__loc& other_value);

GSM48__cause__loc& operator=(int other_value);
GSM48__cause__loc& operator=(enum_type other_value);
GSM48__cause__loc& operator=(const GSM48__cause__loc& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GSM48__cause__loc& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GSM48__cause__loc& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GSM48__cause__loc& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GSM48__cause__loc& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GSM48__cause__loc& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GSM48__cause__loc& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GSM48__cause__loc& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GSM48__cause__loc_template : public Base_Template {
union {
GSM48__cause__loc::enum_type single_value;
struct {
unsigned int n_values;
GSM48__cause__loc_template *list_value;
} value_list;
};

void copy_template(const GSM48__cause__loc_template& other_value);

public:
GSM48__cause__loc_template();
GSM48__cause__loc_template(template_sel other_value);
GSM48__cause__loc_template(int other_value);
GSM48__cause__loc_template(GSM48__cause__loc::enum_type other_value);
GSM48__cause__loc_template(const GSM48__cause__loc& other_value);
GSM48__cause__loc_template(const OPTIONAL<GSM48__cause__loc>& other_value);
GSM48__cause__loc_template(const GSM48__cause__loc_template& other_value);
~GSM48__cause__loc_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GSM48__cause__loc_template& operator=(template_sel other_value);
GSM48__cause__loc_template& operator=(int other_value);
GSM48__cause__loc_template& operator=(GSM48__cause__loc::enum_type other_value);
GSM48__cause__loc_template& operator=(const GSM48__cause__loc& other_value);
GSM48__cause__loc_template& operator=(const OPTIONAL<GSM48__cause__loc>& other_value);
GSM48__cause__loc_template& operator=(const GSM48__cause__loc_template& other_value);

boolean match(GSM48__cause__loc::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GSM48__cause__loc& other_value, boolean legacy = FALSE) const;
GSM48__cause__loc::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GSM48__cause__loc_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GSM48__cause__loc& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__cause : public Base_Type {
  GSM48__cause__loc field_location;
  GSM48__cause__coding field_coding;
  INTEGER field_rec;
  INTEGER field_rec__val;
  INTEGER field_val;
  OCTETSTRING field_diag;
public:
  MNCC__cause();
  MNCC__cause(const GSM48__cause__loc& par_location,
    const GSM48__cause__coding& par_coding,
    const INTEGER& par_rec,
    const INTEGER& par_rec__val,
    const INTEGER& par_val,
    const OCTETSTRING& par_diag);
  MNCC__cause(const MNCC__cause& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__cause& operator=(const MNCC__cause& other_value);
  boolean operator==(const MNCC__cause& other_value) const;
  inline boolean operator!=(const MNCC__cause& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GSM48__cause__loc& location()
    {return field_location;}
  inline const GSM48__cause__loc& location() const
    {return field_location;}
  inline GSM48__cause__coding& coding()
    {return field_coding;}
  inline const GSM48__cause__coding& coding() const
    {return field_coding;}
  inline INTEGER& rec()
    {return field_rec;}
  inline const INTEGER& rec() const
    {return field_rec;}
  inline INTEGER& rec__val()
    {return field_rec__val;}
  inline const INTEGER& rec__val() const
    {return field_rec__val;}
  inline INTEGER& val()
    {return field_val;}
  inline const INTEGER& val() const
    {return field_val;}
  inline OCTETSTRING& diag()
    {return field_diag;}
  inline const OCTETSTRING& diag() const
    {return field_diag;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__cause_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__cause_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__cause& other_value);
void copy_template(const MNCC__cause_template& other_value);

public:
MNCC__cause_template();
MNCC__cause_template(template_sel other_value);
MNCC__cause_template(const MNCC__cause& other_value);
MNCC__cause_template(const OPTIONAL<MNCC__cause>& other_value);
MNCC__cause_template(const MNCC__cause_template& other_value);
~MNCC__cause_template();
MNCC__cause_template& operator=(template_sel other_value);
MNCC__cause_template& operator=(const MNCC__cause& other_value);
MNCC__cause_template& operator=(const OPTIONAL<MNCC__cause>& other_value);
MNCC__cause_template& operator=(const MNCC__cause_template& other_value);
boolean match(const MNCC__cause& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__cause valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__cause_template& list_item(unsigned int list_index) const;
GSM48__cause__loc_template& location();
const GSM48__cause__loc_template& location() const;
GSM48__cause__coding_template& coding();
const GSM48__cause__coding_template& coding() const;
INTEGER_template& rec();
const INTEGER_template& rec() const;
INTEGER_template& rec__val();
const INTEGER_template& rec__val() const;
INTEGER_template& val();
const INTEGER_template& val() const;
OCTETSTRING_template& diag();
const OCTETSTRING_template& diag() const;
int size_of() const;
void log() const;
void log_match(const MNCC__cause& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__useruser : public Base_Type {
  INTEGER field_proto;
  CHARSTRING field_info;
public:
  MNCC__useruser();
  MNCC__useruser(const INTEGER& par_proto,
    const CHARSTRING& par_info);
  MNCC__useruser(const MNCC__useruser& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__useruser& operator=(const MNCC__useruser& other_value);
  boolean operator==(const MNCC__useruser& other_value) const;
  inline boolean operator!=(const MNCC__useruser& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& proto()
    {return field_proto;}
  inline const INTEGER& proto() const
    {return field_proto;}
  inline CHARSTRING& info()
    {return field_info;}
  inline const CHARSTRING& info() const
    {return field_info;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__useruser_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__useruser_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__useruser& other_value);
void copy_template(const MNCC__useruser_template& other_value);

public:
MNCC__useruser_template();
MNCC__useruser_template(template_sel other_value);
MNCC__useruser_template(const MNCC__useruser& other_value);
MNCC__useruser_template(const OPTIONAL<MNCC__useruser>& other_value);
MNCC__useruser_template(const MNCC__useruser_template& other_value);
~MNCC__useruser_template();
MNCC__useruser_template& operator=(template_sel other_value);
MNCC__useruser_template& operator=(const MNCC__useruser& other_value);
MNCC__useruser_template& operator=(const OPTIONAL<MNCC__useruser>& other_value);
MNCC__useruser_template& operator=(const MNCC__useruser_template& other_value);
boolean match(const MNCC__useruser& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__useruser valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__useruser_template& list_item(unsigned int list_index) const;
INTEGER_template& proto();
const INTEGER_template& proto() const;
CHARSTRING_template& info();
const CHARSTRING_template& info() const;
int size_of() const;
void log() const;
void log_match(const MNCC__useruser& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__progress : public Base_Type {
  INTEGER field_coding;
  INTEGER field_location;
  INTEGER field_descr;
public:
  MNCC__progress();
  MNCC__progress(const INTEGER& par_coding,
    const INTEGER& par_location,
    const INTEGER& par_descr);
  MNCC__progress(const MNCC__progress& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__progress& operator=(const MNCC__progress& other_value);
  boolean operator==(const MNCC__progress& other_value) const;
  inline boolean operator!=(const MNCC__progress& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& coding()
    {return field_coding;}
  inline const INTEGER& coding() const
    {return field_coding;}
  inline INTEGER& location()
    {return field_location;}
  inline const INTEGER& location() const
    {return field_location;}
  inline INTEGER& descr()
    {return field_descr;}
  inline const INTEGER& descr() const
    {return field_descr;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__progress_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__progress_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__progress& other_value);
void copy_template(const MNCC__progress_template& other_value);

public:
MNCC__progress_template();
MNCC__progress_template(template_sel other_value);
MNCC__progress_template(const MNCC__progress& other_value);
MNCC__progress_template(const OPTIONAL<MNCC__progress>& other_value);
MNCC__progress_template(const MNCC__progress_template& other_value);
~MNCC__progress_template();
MNCC__progress_template& operator=(template_sel other_value);
MNCC__progress_template& operator=(const MNCC__progress& other_value);
MNCC__progress_template& operator=(const OPTIONAL<MNCC__progress>& other_value);
MNCC__progress_template& operator=(const MNCC__progress_template& other_value);
boolean match(const MNCC__progress& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__progress valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__progress_template& list_item(unsigned int list_index) const;
INTEGER_template& coding();
const INTEGER_template& coding() const;
INTEGER_template& location();
const INTEGER_template& location() const;
INTEGER_template& descr();
const INTEGER_template& descr() const;
int size_of() const;
void log() const;
void log_match(const MNCC__progress& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__cccap : public Base_Type {
  INTEGER field_dtmf;
  INTEGER field_pcp;
public:
  MNCC__cccap();
  MNCC__cccap(const INTEGER& par_dtmf,
    const INTEGER& par_pcp);
  MNCC__cccap(const MNCC__cccap& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__cccap& operator=(const MNCC__cccap& other_value);
  boolean operator==(const MNCC__cccap& other_value) const;
  inline boolean operator!=(const MNCC__cccap& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& dtmf()
    {return field_dtmf;}
  inline const INTEGER& dtmf() const
    {return field_dtmf;}
  inline INTEGER& pcp()
    {return field_pcp;}
  inline const INTEGER& pcp() const
    {return field_pcp;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__cccap_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__cccap_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__cccap& other_value);
void copy_template(const MNCC__cccap_template& other_value);

public:
MNCC__cccap_template();
MNCC__cccap_template(template_sel other_value);
MNCC__cccap_template(const MNCC__cccap& other_value);
MNCC__cccap_template(const OPTIONAL<MNCC__cccap>& other_value);
MNCC__cccap_template(const MNCC__cccap_template& other_value);
~MNCC__cccap_template();
MNCC__cccap_template& operator=(template_sel other_value);
MNCC__cccap_template& operator=(const MNCC__cccap& other_value);
MNCC__cccap_template& operator=(const OPTIONAL<MNCC__cccap>& other_value);
MNCC__cccap_template& operator=(const MNCC__cccap_template& other_value);
boolean match(const MNCC__cccap& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__cccap valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__cccap_template& list_item(unsigned int list_index) const;
INTEGER_template& dtmf();
const INTEGER_template& dtmf() const;
INTEGER_template& pcp();
const INTEGER_template& pcp() const;
int size_of() const;
void log() const;
void log_match(const MNCC__cccap& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__bcap : public Base_Type { // enum
friend class MNCC__bcap_template;
public:
enum enum_type { GSM__MNCC__BCAP__SPEECH = 0, GSM__MNCC__BCAP__UNR__DIG = 1, GSM__MNCC__BCAP__AUDIO = 2, GSM__MNCC__BCAP__FAX__G3 = 3, GSM__MNCC__BCAP__OTHER__ITC = 4, GSM__MNCC__BCAP__RESERVED = 7, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
MNCC__bcap();
MNCC__bcap(int other_value);
MNCC__bcap(enum_type other_value);
MNCC__bcap(const MNCC__bcap& other_value);

MNCC__bcap& operator=(int other_value);
MNCC__bcap& operator=(enum_type other_value);
MNCC__bcap& operator=(const MNCC__bcap& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MNCC__bcap& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MNCC__bcap& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MNCC__bcap& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MNCC__bcap& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MNCC__bcap& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MNCC__bcap& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MNCC__bcap& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__bcap_template : public Base_Template {
union {
MNCC__bcap::enum_type single_value;
struct {
unsigned int n_values;
MNCC__bcap_template *list_value;
} value_list;
};

void copy_template(const MNCC__bcap_template& other_value);

public:
MNCC__bcap_template();
MNCC__bcap_template(template_sel other_value);
MNCC__bcap_template(int other_value);
MNCC__bcap_template(MNCC__bcap::enum_type other_value);
MNCC__bcap_template(const MNCC__bcap& other_value);
MNCC__bcap_template(const OPTIONAL<MNCC__bcap>& other_value);
MNCC__bcap_template(const MNCC__bcap_template& other_value);
~MNCC__bcap_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__bcap_template& operator=(template_sel other_value);
MNCC__bcap_template& operator=(int other_value);
MNCC__bcap_template& operator=(MNCC__bcap::enum_type other_value);
MNCC__bcap_template& operator=(const MNCC__bcap& other_value);
MNCC__bcap_template& operator=(const OPTIONAL<MNCC__bcap>& other_value);
MNCC__bcap_template& operator=(const MNCC__bcap_template& other_value);

boolean match(MNCC__bcap::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const MNCC__bcap& other_value, boolean legacy = FALSE) const;
MNCC__bcap::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__bcap_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MNCC__bcap& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__PDU__Signal : public Base_Type {
  INTEGER field_callref;
  OPTIONAL<MNCC__bearer__cap> field_bearer__cap;
  OPTIONAL<MNCC__number> field_called;
  OPTIONAL<MNCC__number> field_calling;
  OPTIONAL<MNCC__number> field_redirecting;
  OPTIONAL<MNCC__number> field_connected;
  OPTIONAL<MNCC__cause> field_cause;
  OPTIONAL<MNCC__progress> field_progress;
  OPTIONAL<MNCC__useruser> field_useruser;
  OPTIONAL<CHARSTRING> field_facility;
  OPTIONAL<MNCC__cccap> field_cccap;
  OPTIONAL<CHARSTRING> field_ssversion;
  INTEGER field_clir__sup;
  INTEGER field_clir__inv;
  OPTIONAL<INTEGER> field_signal;
  OPTIONAL<CHARSTRING> field_keypad;
  INTEGER field_more;
  INTEGER field_notify;
  OPTIONAL<INTEGER> field_emergency;
  CHARSTRING field_imsi;
  INTEGER field_lchan__type;
  INTEGER field_lchan__mode;
public:
  MNCC__PDU__Signal();
  MNCC__PDU__Signal(const INTEGER& par_callref,
    const OPTIONAL<MNCC__bearer__cap>& par_bearer__cap,
    const OPTIONAL<MNCC__number>& par_called,
    const OPTIONAL<MNCC__number>& par_calling,
    const OPTIONAL<MNCC__number>& par_redirecting,
    const OPTIONAL<MNCC__number>& par_connected,
    const OPTIONAL<MNCC__cause>& par_cause,
    const OPTIONAL<MNCC__progress>& par_progress,
    const OPTIONAL<MNCC__useruser>& par_useruser,
    const OPTIONAL<CHARSTRING>& par_facility,
    const OPTIONAL<MNCC__cccap>& par_cccap,
    const OPTIONAL<CHARSTRING>& par_ssversion,
    const INTEGER& par_clir__sup,
    const INTEGER& par_clir__inv,
    const OPTIONAL<INTEGER>& par_signal,
    const OPTIONAL<CHARSTRING>& par_keypad,
    const INTEGER& par_more,
    const INTEGER& par_notify,
    const OPTIONAL<INTEGER>& par_emergency,
    const CHARSTRING& par_imsi,
    const INTEGER& par_lchan__type,
    const INTEGER& par_lchan__mode);
  MNCC__PDU__Signal(const MNCC__PDU__Signal& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__PDU__Signal& operator=(const MNCC__PDU__Signal& other_value);
  boolean operator==(const MNCC__PDU__Signal& other_value) const;
  inline boolean operator!=(const MNCC__PDU__Signal& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& callref()
    {return field_callref;}
  inline const INTEGER& callref() const
    {return field_callref;}
  inline OPTIONAL<MNCC__bearer__cap>& bearer__cap()
    {return field_bearer__cap;}
  inline const OPTIONAL<MNCC__bearer__cap>& bearer__cap() const
    {return field_bearer__cap;}
  inline OPTIONAL<MNCC__number>& called()
    {return field_called;}
  inline const OPTIONAL<MNCC__number>& called() const
    {return field_called;}
  inline OPTIONAL<MNCC__number>& calling()
    {return field_calling;}
  inline const OPTIONAL<MNCC__number>& calling() const
    {return field_calling;}
  inline OPTIONAL<MNCC__number>& redirecting()
    {return field_redirecting;}
  inline const OPTIONAL<MNCC__number>& redirecting() const
    {return field_redirecting;}
  inline OPTIONAL<MNCC__number>& connected()
    {return field_connected;}
  inline const OPTIONAL<MNCC__number>& connected() const
    {return field_connected;}
  inline OPTIONAL<MNCC__cause>& cause()
    {return field_cause;}
  inline const OPTIONAL<MNCC__cause>& cause() const
    {return field_cause;}
  inline OPTIONAL<MNCC__progress>& progress()
    {return field_progress;}
  inline const OPTIONAL<MNCC__progress>& progress() const
    {return field_progress;}
  inline OPTIONAL<MNCC__useruser>& useruser()
    {return field_useruser;}
  inline const OPTIONAL<MNCC__useruser>& useruser() const
    {return field_useruser;}
  inline OPTIONAL<CHARSTRING>& facility()
    {return field_facility;}
  inline const OPTIONAL<CHARSTRING>& facility() const
    {return field_facility;}
  inline OPTIONAL<MNCC__cccap>& cccap()
    {return field_cccap;}
  inline const OPTIONAL<MNCC__cccap>& cccap() const
    {return field_cccap;}
  inline OPTIONAL<CHARSTRING>& ssversion()
    {return field_ssversion;}
  inline const OPTIONAL<CHARSTRING>& ssversion() const
    {return field_ssversion;}
  inline INTEGER& clir__sup()
    {return field_clir__sup;}
  inline const INTEGER& clir__sup() const
    {return field_clir__sup;}
  inline INTEGER& clir__inv()
    {return field_clir__inv;}
  inline const INTEGER& clir__inv() const
    {return field_clir__inv;}
  inline OPTIONAL<INTEGER>& signal()
    {return field_signal;}
  inline const OPTIONAL<INTEGER>& signal() const
    {return field_signal;}
  inline OPTIONAL<CHARSTRING>& keypad()
    {return field_keypad;}
  inline const OPTIONAL<CHARSTRING>& keypad() const
    {return field_keypad;}
  inline INTEGER& more()
    {return field_more;}
  inline const INTEGER& more() const
    {return field_more;}
  inline INTEGER& notify()
    {return field_notify;}
  inline const INTEGER& notify() const
    {return field_notify;}
  inline OPTIONAL<INTEGER>& emergency()
    {return field_emergency;}
  inline const OPTIONAL<INTEGER>& emergency() const
    {return field_emergency;}
  inline CHARSTRING& imsi()
    {return field_imsi;}
  inline const CHARSTRING& imsi() const
    {return field_imsi;}
  inline INTEGER& lchan__type()
    {return field_lchan__type;}
  inline const INTEGER& lchan__type() const
    {return field_lchan__type;}
  inline INTEGER& lchan__mode()
    {return field_lchan__mode;}
  inline const INTEGER& lchan__mode() const
    {return field_lchan__mode;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__PDU__Signal_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__PDU__Signal_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__PDU__Signal& other_value);
void copy_template(const MNCC__PDU__Signal_template& other_value);

public:
MNCC__PDU__Signal_template();
MNCC__PDU__Signal_template(template_sel other_value);
MNCC__PDU__Signal_template(const MNCC__PDU__Signal& other_value);
MNCC__PDU__Signal_template(const OPTIONAL<MNCC__PDU__Signal>& other_value);
MNCC__PDU__Signal_template(const MNCC__PDU__Signal_template& other_value);
~MNCC__PDU__Signal_template();
MNCC__PDU__Signal_template& operator=(template_sel other_value);
MNCC__PDU__Signal_template& operator=(const MNCC__PDU__Signal& other_value);
MNCC__PDU__Signal_template& operator=(const OPTIONAL<MNCC__PDU__Signal>& other_value);
MNCC__PDU__Signal_template& operator=(const MNCC__PDU__Signal_template& other_value);
boolean match(const MNCC__PDU__Signal& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__PDU__Signal valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU__Signal_template& list_item(unsigned int list_index) const;
INTEGER_template& callref();
const INTEGER_template& callref() const;
MNCC__bearer__cap_template& bearer__cap();
const MNCC__bearer__cap_template& bearer__cap() const;
MNCC__number_template& called();
const MNCC__number_template& called() const;
MNCC__number_template& calling();
const MNCC__number_template& calling() const;
MNCC__number_template& redirecting();
const MNCC__number_template& redirecting() const;
MNCC__number_template& connected();
const MNCC__number_template& connected() const;
MNCC__cause_template& cause();
const MNCC__cause_template& cause() const;
MNCC__progress_template& progress();
const MNCC__progress_template& progress() const;
MNCC__useruser_template& useruser();
const MNCC__useruser_template& useruser() const;
CHARSTRING_template& facility();
const CHARSTRING_template& facility() const;
MNCC__cccap_template& cccap();
const MNCC__cccap_template& cccap() const;
CHARSTRING_template& ssversion();
const CHARSTRING_template& ssversion() const;
INTEGER_template& clir__sup();
const INTEGER_template& clir__sup() const;
INTEGER_template& clir__inv();
const INTEGER_template& clir__inv() const;
INTEGER_template& signal();
const INTEGER_template& signal() const;
CHARSTRING_template& keypad();
const CHARSTRING_template& keypad() const;
INTEGER_template& more();
const INTEGER_template& more() const;
INTEGER_template& notify();
const INTEGER_template& notify() const;
INTEGER_template& emergency();
const INTEGER_template& emergency() const;
CHARSTRING_template& imsi();
const CHARSTRING_template& imsi() const;
INTEGER_template& lchan__type();
const INTEGER_template& lchan__type() const;
INTEGER_template& lchan__mode();
const INTEGER_template& lchan__mode() const;
int size_of() const;
void log() const;
void log_match(const MNCC__PDU__Signal& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__PDU__Data : public Base_Type {
  INTEGER field_callref;
  OCTETSTRING field_data;
public:
  MNCC__PDU__Data();
  MNCC__PDU__Data(const INTEGER& par_callref,
    const OCTETSTRING& par_data);
  MNCC__PDU__Data(const MNCC__PDU__Data& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__PDU__Data& operator=(const MNCC__PDU__Data& other_value);
  boolean operator==(const MNCC__PDU__Data& other_value) const;
  inline boolean operator!=(const MNCC__PDU__Data& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& callref()
    {return field_callref;}
  inline const INTEGER& callref() const
    {return field_callref;}
  inline OCTETSTRING& data()
    {return field_data;}
  inline const OCTETSTRING& data() const
    {return field_data;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__PDU__Data_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__PDU__Data_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__PDU__Data& other_value);
void copy_template(const MNCC__PDU__Data_template& other_value);

public:
MNCC__PDU__Data_template();
MNCC__PDU__Data_template(template_sel other_value);
MNCC__PDU__Data_template(const MNCC__PDU__Data& other_value);
MNCC__PDU__Data_template(const OPTIONAL<MNCC__PDU__Data>& other_value);
MNCC__PDU__Data_template(const MNCC__PDU__Data_template& other_value);
~MNCC__PDU__Data_template();
MNCC__PDU__Data_template& operator=(template_sel other_value);
MNCC__PDU__Data_template& operator=(const MNCC__PDU__Data& other_value);
MNCC__PDU__Data_template& operator=(const OPTIONAL<MNCC__PDU__Data>& other_value);
MNCC__PDU__Data_template& operator=(const MNCC__PDU__Data_template& other_value);
boolean match(const MNCC__PDU__Data& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__PDU__Data valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU__Data_template& list_item(unsigned int list_index) const;
INTEGER_template& callref();
const INTEGER_template& callref() const;
OCTETSTRING_template& data();
const OCTETSTRING_template& data() const;
int size_of() const;
void log() const;
void log_match(const MNCC__PDU__Data& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__PDU__Rtp : public Base_Type {
  INTEGER field_callref;
  INTEGER field_ip;
  INTEGER field_rtp__port;
  INTEGER field_payload__type;
  INTEGER field_payload__msg__type;
public:
  MNCC__PDU__Rtp();
  MNCC__PDU__Rtp(const INTEGER& par_callref,
    const INTEGER& par_ip,
    const INTEGER& par_rtp__port,
    const INTEGER& par_payload__type,
    const INTEGER& par_payload__msg__type);
  MNCC__PDU__Rtp(const MNCC__PDU__Rtp& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__PDU__Rtp& operator=(const MNCC__PDU__Rtp& other_value);
  boolean operator==(const MNCC__PDU__Rtp& other_value) const;
  inline boolean operator!=(const MNCC__PDU__Rtp& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& callref()
    {return field_callref;}
  inline const INTEGER& callref() const
    {return field_callref;}
  inline INTEGER& ip()
    {return field_ip;}
  inline const INTEGER& ip() const
    {return field_ip;}
  inline INTEGER& rtp__port()
    {return field_rtp__port;}
  inline const INTEGER& rtp__port() const
    {return field_rtp__port;}
  inline INTEGER& payload__type()
    {return field_payload__type;}
  inline const INTEGER& payload__type() const
    {return field_payload__type;}
  inline INTEGER& payload__msg__type()
    {return field_payload__msg__type;}
  inline const INTEGER& payload__msg__type() const
    {return field_payload__msg__type;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__PDU__Rtp_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__PDU__Rtp_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__PDU__Rtp& other_value);
void copy_template(const MNCC__PDU__Rtp_template& other_value);

public:
MNCC__PDU__Rtp_template();
MNCC__PDU__Rtp_template(template_sel other_value);
MNCC__PDU__Rtp_template(const MNCC__PDU__Rtp& other_value);
MNCC__PDU__Rtp_template(const OPTIONAL<MNCC__PDU__Rtp>& other_value);
MNCC__PDU__Rtp_template(const MNCC__PDU__Rtp_template& other_value);
~MNCC__PDU__Rtp_template();
MNCC__PDU__Rtp_template& operator=(template_sel other_value);
MNCC__PDU__Rtp_template& operator=(const MNCC__PDU__Rtp& other_value);
MNCC__PDU__Rtp_template& operator=(const OPTIONAL<MNCC__PDU__Rtp>& other_value);
MNCC__PDU__Rtp_template& operator=(const MNCC__PDU__Rtp_template& other_value);
boolean match(const MNCC__PDU__Rtp& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__PDU__Rtp valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU__Rtp_template& list_item(unsigned int list_index) const;
INTEGER_template& callref();
const INTEGER_template& callref() const;
INTEGER_template& ip();
const INTEGER_template& ip() const;
INTEGER_template& rtp__port();
const INTEGER_template& rtp__port() const;
INTEGER_template& payload__type();
const INTEGER_template& payload__type() const;
INTEGER_template& payload__msg__type();
const INTEGER_template& payload__msg__type() const;
int size_of() const;
void log() const;
void log_match(const MNCC__PDU__Rtp& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__PDU__Hello : public Base_Type {
  INTEGER field_version;
  INTEGER field_mncc__size;
  INTEGER field_data__frame__size;
  INTEGER field_called__offset;
  INTEGER field_signal__offset;
  INTEGER field_emergency__offset;
  INTEGER field_lchan__type__offset;
public:
  MNCC__PDU__Hello();
  MNCC__PDU__Hello(const INTEGER& par_version,
    const INTEGER& par_mncc__size,
    const INTEGER& par_data__frame__size,
    const INTEGER& par_called__offset,
    const INTEGER& par_signal__offset,
    const INTEGER& par_emergency__offset,
    const INTEGER& par_lchan__type__offset);
  MNCC__PDU__Hello(const MNCC__PDU__Hello& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__PDU__Hello& operator=(const MNCC__PDU__Hello& other_value);
  boolean operator==(const MNCC__PDU__Hello& other_value) const;
  inline boolean operator!=(const MNCC__PDU__Hello& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline INTEGER& mncc__size()
    {return field_mncc__size;}
  inline const INTEGER& mncc__size() const
    {return field_mncc__size;}
  inline INTEGER& data__frame__size()
    {return field_data__frame__size;}
  inline const INTEGER& data__frame__size() const
    {return field_data__frame__size;}
  inline INTEGER& called__offset()
    {return field_called__offset;}
  inline const INTEGER& called__offset() const
    {return field_called__offset;}
  inline INTEGER& signal__offset()
    {return field_signal__offset;}
  inline const INTEGER& signal__offset() const
    {return field_signal__offset;}
  inline INTEGER& emergency__offset()
    {return field_emergency__offset;}
  inline const INTEGER& emergency__offset() const
    {return field_emergency__offset;}
  inline INTEGER& lchan__type__offset()
    {return field_lchan__type__offset;}
  inline const INTEGER& lchan__type__offset() const
    {return field_lchan__type__offset;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__PDU__Hello_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__PDU__Hello_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__PDU__Hello& other_value);
void copy_template(const MNCC__PDU__Hello_template& other_value);

public:
MNCC__PDU__Hello_template();
MNCC__PDU__Hello_template(template_sel other_value);
MNCC__PDU__Hello_template(const MNCC__PDU__Hello& other_value);
MNCC__PDU__Hello_template(const OPTIONAL<MNCC__PDU__Hello>& other_value);
MNCC__PDU__Hello_template(const MNCC__PDU__Hello_template& other_value);
~MNCC__PDU__Hello_template();
MNCC__PDU__Hello_template& operator=(template_sel other_value);
MNCC__PDU__Hello_template& operator=(const MNCC__PDU__Hello& other_value);
MNCC__PDU__Hello_template& operator=(const OPTIONAL<MNCC__PDU__Hello>& other_value);
MNCC__PDU__Hello_template& operator=(const MNCC__PDU__Hello_template& other_value);
boolean match(const MNCC__PDU__Hello& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__PDU__Hello valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU__Hello_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
INTEGER_template& mncc__size();
const INTEGER_template& mncc__size() const;
INTEGER_template& data__frame__size();
const INTEGER_template& data__frame__size() const;
INTEGER_template& called__offset();
const INTEGER_template& called__offset() const;
INTEGER_template& signal__offset();
const INTEGER_template& signal__offset() const;
INTEGER_template& emergency__offset();
const INTEGER_template& emergency__offset() const;
INTEGER_template& lchan__type__offset();
const INTEGER_template& lchan__type__offset() const;
int size_of() const;
void log() const;
void log_match(const MNCC__PDU__Hello& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MNCC__MsgUnion : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_signal = 1, ALT_data = 2, ALT_rtp = 3, ALT_hello = 4 };
private:
union_selection_type union_selection;
union {
MNCC__PDU__Signal *field_signal;
MNCC__PDU__Data *field_data;
MNCC__PDU__Rtp *field_rtp;
MNCC__PDU__Hello *field_hello;
};
void copy_value(const MNCC__MsgUnion& other_value);

public:
MNCC__MsgUnion();
MNCC__MsgUnion(const MNCC__MsgUnion& other_value);
~MNCC__MsgUnion();
MNCC__MsgUnion& operator=(const MNCC__MsgUnion& other_value);
boolean operator==(const MNCC__MsgUnion& other_value) const;
inline boolean operator!=(const MNCC__MsgUnion& other_value) const { return !(*this == other_value); }
MNCC__PDU__Signal& signal();
const MNCC__PDU__Signal& signal() const;
MNCC__PDU__Data& data();
const MNCC__PDU__Data& data() const;
MNCC__PDU__Rtp& rtp();
const MNCC__PDU__Rtp& rtp() const;
MNCC__PDU__Hello& hello();
const MNCC__PDU__Hello& hello() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__MsgUnion_template : public Base_Template {
union {
struct {
MNCC__MsgUnion::union_selection_type union_selection;
union {
MNCC__PDU__Signal_template *field_signal;
MNCC__PDU__Data_template *field_data;
MNCC__PDU__Rtp_template *field_rtp;
MNCC__PDU__Hello_template *field_hello;
};
} single_value;
struct {
unsigned int n_values;
MNCC__MsgUnion_template *list_value;
} value_list;
};
void copy_value(const MNCC__MsgUnion& other_value);

void copy_template(const MNCC__MsgUnion_template& other_value);

public:
MNCC__MsgUnion_template();
MNCC__MsgUnion_template(template_sel other_value);
MNCC__MsgUnion_template(const MNCC__MsgUnion& other_value);
MNCC__MsgUnion_template(const OPTIONAL<MNCC__MsgUnion>& other_value);
MNCC__MsgUnion_template(const MNCC__MsgUnion_template& other_value);
~MNCC__MsgUnion_template();
void clean_up();
MNCC__MsgUnion_template& operator=(template_sel other_value);
MNCC__MsgUnion_template& operator=(const MNCC__MsgUnion& other_value);
MNCC__MsgUnion_template& operator=(const OPTIONAL<MNCC__MsgUnion>& other_value);
MNCC__MsgUnion_template& operator=(const MNCC__MsgUnion_template& other_value);
boolean match(const MNCC__MsgUnion& other_value, boolean legacy = FALSE) const;
boolean is_value() const;MNCC__MsgUnion valueof() const;
MNCC__MsgUnion_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU__Signal_template& signal();
const MNCC__PDU__Signal_template& signal() const;
MNCC__PDU__Data_template& data();
const MNCC__PDU__Data_template& data() const;
MNCC__PDU__Rtp_template& rtp();
const MNCC__PDU__Rtp_template& rtp() const;
MNCC__PDU__Hello_template& hello();
const MNCC__PDU__Hello_template& hello() const;
boolean ischosen(MNCC__MsgUnion::union_selection_type checked_selection) const;
void log() const;
void log_match(const MNCC__MsgUnion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MNCC__PDU : public Base_Type {
  MNCC__MsgType field_msg__type;
  MNCC__MsgUnion field_u;
public:
  MNCC__PDU();
  MNCC__PDU(const MNCC__MsgType& par_msg__type,
    const MNCC__MsgUnion& par_u);
  MNCC__PDU(const MNCC__PDU& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MNCC__PDU& operator=(const MNCC__PDU& other_value);
  boolean operator==(const MNCC__PDU& other_value) const;
  inline boolean operator!=(const MNCC__PDU& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline MNCC__MsgType& msg__type()
    {return field_msg__type;}
  inline const MNCC__MsgType& msg__type() const
    {return field_msg__type;}
  inline MNCC__MsgUnion& u()
    {return field_u;}
  inline const MNCC__MsgUnion& u() const
    {return field_u;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MNCC__PDU_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MNCC__PDU_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MNCC__PDU& other_value);
void copy_template(const MNCC__PDU_template& other_value);

public:
MNCC__PDU_template();
MNCC__PDU_template(template_sel other_value);
MNCC__PDU_template(const MNCC__PDU& other_value);
MNCC__PDU_template(const OPTIONAL<MNCC__PDU>& other_value);
MNCC__PDU_template(const MNCC__PDU_template& other_value);
~MNCC__PDU_template();
MNCC__PDU_template& operator=(template_sel other_value);
MNCC__PDU_template& operator=(const MNCC__PDU& other_value);
MNCC__PDU_template& operator=(const OPTIONAL<MNCC__PDU>& other_value);
MNCC__PDU_template& operator=(const MNCC__PDU_template& other_value);
boolean match(const MNCC__PDU& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MNCC__PDU valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MNCC__PDU_template& list_item(unsigned int list_index) const;
MNCC__MsgType_template& msg__type();
const MNCC__MsgType_template& msg__type() const;
MNCC__MsgUnion_template& u();
const MNCC__MsgUnion_template& u() const;
int size_of() const;
void log() const;
void log_match(const MNCC__PDU& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void int__encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER int__decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__ra_encoder(const GSM48__bcap__ra& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__ra_decoder(OCTETSTRING& input_stream, GSM48__bcap__ra& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__sig__access_encoder(const GSM48__bcap__sig__access& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__sig__access_decoder(OCTETSTRING& input_stream, GSM48__bcap__sig__access& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__user__rate_encoder(const GSM48__bcap__user__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__user__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__user__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__parity_encoder(const GSM48__bcap__parity& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__parity_decoder(OCTETSTRING& input_stream, GSM48__bcap__parity& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__interm__rate_encoder(const GSM48__bcap__interm__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__interm__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__interm__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__transp_encoder(const GSM48__bcap__transp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__transp_decoder(OCTETSTRING& input_stream, GSM48__bcap__transp& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__bcap__modem__type_encoder(const GSM48__bcap__modem__type& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__bcap__modem__type_decoder(OCTETSTRING& input_stream, GSM48__bcap__modem__type& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgType_encoder(const MNCC__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgType_decoder(OCTETSTRING& input_stream, MNCC__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_rate__adaptation_encoder(const GSM48__bcap__ra& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_rate__adaptation_decoder(OCTETSTRING& input_stream, GSM48__bcap__ra& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_sig__access_encoder(const GSM48__bcap__sig__access& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_sig__access_decoder(OCTETSTRING& input_stream, GSM48__bcap__sig__access& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_async_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_async_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_nr__stop__bits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_nr__stop__bits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_nr__data__bits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_nr__data__bits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_user__rate_encoder(const GSM48__bcap__user__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_user__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__user__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_parity_encoder(const GSM48__bcap__parity& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_parity_decoder(OCTETSTRING& input_stream, GSM48__bcap__parity& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_interm__rate_encoder(const GSM48__bcap__interm__rate& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_interm__rate_decoder(OCTETSTRING& input_stream, GSM48__bcap__interm__rate& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_transp_encoder(const GSM48__bcap__transp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_transp_decoder(OCTETSTRING& input_stream, GSM48__bcap__transp& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_modem__type_encoder(const GSM48__bcap__modem__type& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_modem__type_decoder(OCTETSTRING& input_stream, GSM48__bcap__modem__type& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap__data_encoder(const MNCC__bearer__cap__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap__data_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap__data& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__speech__vers_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__speech__vers_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__speech__vers_encoder(const MNCC__speech__vers& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__speech__vers_decoder(OCTETSTRING& input_stream, MNCC__speech__vers& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_transfer_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_transfer_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_mode_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_mode_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_coding_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_coding_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_radio_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_radio_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_speech__ctm_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_speech__ctm_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_speech__ver_encoder(const MNCC__speech__vers& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_speech__ver_decoder(OCTETSTRING& input_stream, MNCC__speech__vers& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_data_encoder(const MNCC__bearer__cap__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_data_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap__data& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bearer__cap_encoder(const MNCC__bearer__cap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bearer__cap_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__type__of__number_encoder(const GSM48__type__of__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__type__of__number_decoder(OCTETSTRING& input_stream, GSM48__type__of__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_number__type_encoder(const GSM48__type__of__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_number__type_decoder(OCTETSTRING& input_stream, GSM48__type__of__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__num__plan__ind_encoder(const GSM48__num__plan__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__num__plan__ind_decoder(OCTETSTRING& input_stream, GSM48__num__plan__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_plan_encoder(const GSM48__num__plan__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_plan_decoder(OCTETSTRING& input_stream, GSM48__num__plan__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__present__ind_encoder(const GSM48__present__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__present__ind_decoder(OCTETSTRING& input_stream, GSM48__present__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_presence_encoder(const GSM48__present__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_presence_decoder(OCTETSTRING& input_stream, GSM48__present__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__screening__ind_encoder(const GSM48__screening__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__screening__ind_decoder(OCTETSTRING& input_stream, GSM48__screening__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_screen_encoder(const GSM48__screening__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_screen_decoder(OCTETSTRING& input_stream, GSM48__screening__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_number_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_number_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__number_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__number_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__cause__coding_encoder(const GSM48__cause__coding& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__cause__coding_decoder(OCTETSTRING& input_stream, GSM48__cause__coding& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void GSM48__cause__loc_encoder(const GSM48__cause__loc& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER GSM48__cause__loc_decoder(OCTETSTRING& input_stream, GSM48__cause__loc& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern MNCC__number_template ts__MNCC__number(const CHARSTRING& number, const GSM48__type__of__number& ton, const GSM48__num__plan__ind& npi, const GSM48__present__ind& pres, const GSM48__screening__ind& screen);
extern MNCC__number_template tr__MNCC__number(const CHARSTRING_template& number, const GSM48__type__of__number_template& ton, const GSM48__num__plan__ind_template& npi, const GSM48__present__ind_template& pres, const GSM48__screening__ind_template& screen);
extern void MNCC__cause_location_encoder(const GSM48__cause__loc& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_location_decoder(OCTETSTRING& input_stream, GSM48__cause__loc& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_coding_encoder(const GSM48__cause__coding& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_coding_decoder(OCTETSTRING& input_stream, GSM48__cause__coding& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_rec_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_rec_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_rec__val_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_rec__val_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_val_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_val_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_diag_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_diag_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cause_encoder(const MNCC__cause& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cause_decoder(OCTETSTRING& input_stream, MNCC__cause& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern MNCC__cause_template ts__MNCC__cause(const INTEGER& val, const GSM48__cause__loc& loc, const GSM48__cause__coding& coding, const OCTETSTRING& diag);
extern void MNCC__useruser_proto_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__useruser_proto_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__useruser_info_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__useruser_info_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__useruser_encoder(const MNCC__useruser& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__useruser_decoder(OCTETSTRING& input_stream, MNCC__useruser& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__progress_coding_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__progress_coding_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__progress_location_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__progress_location_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__progress_descr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__progress_descr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__progress_encoder(const MNCC__progress& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__progress_decoder(OCTETSTRING& input_stream, MNCC__progress& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cccap_dtmf_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cccap_dtmf_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cccap_pcp_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cccap_pcp_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__cccap_encoder(const MNCC__cccap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__cccap_decoder(OCTETSTRING& input_stream, MNCC__cccap& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__notify_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__notify_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__keypad_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__keypad_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__bcap_encoder(const MNCC__bcap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__bcap_decoder(OCTETSTRING& input_stream, MNCC__bcap& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_clir__sup_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_clir__sup_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_clir__inv_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_clir__inv_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_more_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_more_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_notify_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_notify_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_imsi_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_imsi_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_lchan__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_lchan__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_lchan__mode_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_lchan__mode_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_bearer__cap_encoder(const MNCC__bearer__cap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_bearer__cap_decoder(OCTETSTRING& input_stream, MNCC__bearer__cap& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_called_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_called_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_calling_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_calling_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_redirecting_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_redirecting_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_connected_encoder(const MNCC__number& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_connected_decoder(OCTETSTRING& input_stream, MNCC__number& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_cause_encoder(const MNCC__cause& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_cause_decoder(OCTETSTRING& input_stream, MNCC__cause& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_progress_encoder(const MNCC__progress& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_progress_decoder(OCTETSTRING& input_stream, MNCC__progress& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_useruser_encoder(const MNCC__useruser& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_useruser_decoder(OCTETSTRING& input_stream, MNCC__useruser& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_facility_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_facility_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_cccap_encoder(const MNCC__cccap& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_cccap_decoder(OCTETSTRING& input_stream, MNCC__cccap& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_ssversion_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_ssversion_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_signal_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_signal_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_keypad_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_keypad_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_emergency_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_emergency_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Signal_encoder(const MNCC__PDU__Signal& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Signal_decoder(OCTETSTRING& input_stream, MNCC__PDU__Signal& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Data_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Data_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Data_data_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Data_data_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Data_encoder(const MNCC__PDU__Data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Data_decoder(OCTETSTRING& input_stream, MNCC__PDU__Data& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_callref_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_callref_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_ip_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_ip_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_rtp__port_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_rtp__port_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_payload__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_payload__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_payload__msg__type_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_payload__msg__type_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Rtp_encoder(const MNCC__PDU__Rtp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Rtp_decoder(OCTETSTRING& input_stream, MNCC__PDU__Rtp& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_version_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_version_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_mncc__size_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_mncc__size_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_data__frame__size_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_data__frame__size_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_called__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_called__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_signal__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_signal__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_emergency__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_emergency__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_lchan__type__offset_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_lchan__type__offset_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU__Hello_encoder(const MNCC__PDU__Hello& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU__Hello_decoder(OCTETSTRING& input_stream, MNCC__PDU__Hello& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgUnion_signal_encoder(const MNCC__PDU__Signal& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgUnion_signal_decoder(OCTETSTRING& input_stream, MNCC__PDU__Signal& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgUnion_data_encoder(const MNCC__PDU__Data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgUnion_data_decoder(OCTETSTRING& input_stream, MNCC__PDU__Data& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgUnion_rtp_encoder(const MNCC__PDU__Rtp& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgUnion_rtp_decoder(OCTETSTRING& input_stream, MNCC__PDU__Rtp& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgUnion_hello_encoder(const MNCC__PDU__Hello& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgUnion_hello_decoder(OCTETSTRING& input_stream, MNCC__PDU__Hello& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__MsgUnion_encoder(const MNCC__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__MsgUnion_decoder(OCTETSTRING& input_stream, MNCC__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU_msg__type_encoder(const MNCC__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU_msg__type_decoder(OCTETSTRING& input_stream, MNCC__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU_u_encoder(const MNCC__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU_u_decoder(OCTETSTRING& input_stream, MNCC__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void MNCC__PDU_encoder(const MNCC__PDU& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER MNCC__PDU_decoder(OCTETSTRING& input_stream, MNCC__PDU& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern OCTETSTRING enc__MNCC__PDU(const MNCC__PDU& pdu);
extern MNCC__PDU dec__MNCC__PDU(const OCTETSTRING& stream);
extern MNCC__PDU_template ts__MNCC__HELLO(const INTEGER& version);
extern MNCC__PDU_template ts__MNCC__Sign(const MNCC__MsgType& msg__type, const MNCC__PDU__Signal& sign);
extern MNCC__PDU_template ts__MNCC__SIMPLE(const MNCC__MsgType& msg__type, const INTEGER& call__id);
extern MNCC__PDU_template tr__MNCC__SIMPLE(const MNCC__MsgType_template& msg__type, const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__SETUP__req(const INTEGER& call__id, const CHARSTRING& called, const CHARSTRING& calling, const CHARSTRING& imsi);
extern MNCC__PDU_template tr__MNCC__SETUP__req(const INTEGER_template& call__id, const CHARSTRING_template& called, const CHARSTRING_template& calling, const CHARSTRING_template& imsi);
extern MNCC__PDU_template ts__MNCC__SETUP__rsp(const INTEGER& call__id, const CHARSTRING& imsi, const MNCC__number_template& connected);
extern MNCC__PDU_template tr__MNCC__SETUP__rsp(const INTEGER_template& call__id, const CHARSTRING_template& imsi, const MNCC__number_template& connected);
extern MNCC__PDU_template tr__MNCC__SETUP__ind(const INTEGER_template& call__id, const MNCC__number_template& called, const MNCC__number_template& calling, const CHARSTRING_template& imsi);
extern MNCC__PDU_template ts__MNCC__SETUP__ind(const INTEGER& call__id, const MNCC__number& called, const MNCC__number_template& calling, const CHARSTRING_template& imsi, const MNCC__bearer__cap_template& bcap);
extern MNCC__PDU_template ts__MNCC__SETUP__CNF(const INTEGER& call__id, const MNCC__number_template& connected);
extern MNCC__PDU_template tr__MNCC__SETUP__cnf(const INTEGER& call__id, const MNCC__number_template& connected);
extern MNCC__PDU_template tr__MNCC__SETUP__COMPL__req(const INTEGER_template& call__id);
extern MNCC__PDU_template tr__MNCC__SETUP__COMPL__ind(const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__SETUP__COMPL__ind(const INTEGER& call__id);
extern MNCC__PDU_template tr__MNCC__REJ__req(const INTEGER_template& call__id, const MNCC__cause_template& cause);
extern MNCC__PDU_template ts__MNCC__REJ__ind(const INTEGER& call__id, const MNCC__cause_template& cause);
extern MNCC__PDU_template tr__MNCC__CALL__CONF__ind(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__cause_template& cause, const MNCC__cccap_template& cccap);
extern MNCC__PDU_template ts__MNCC__CALL__CONF__ind(const INTEGER& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__cause_template& cause, const MNCC__cccap_template& cccap);
extern MNCC__PDU_template ts__MNCC__CALL__PROC__req(const INTEGER& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__cccap_template& cccap);
extern MNCC__PDU_template tr__MNCC__CALL__PROC__req(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__cccap_template& cccap);
extern MNCC__PDU_template ts__MNCC__PROGRESS__req(const INTEGER& call__id, const MNCC__progress& prog, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__ALERT__req(const INTEGER& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__ALERT__req(const INTEGER_template& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__ALERT__ind(const INTEGER_template& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__ALERT__ind(const INTEGER& call__id, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__NOTIFY__req(const INTEGER& call__id, const INTEGER& notify);
extern MNCC__PDU_template tr__MNCC__NOTIFY__ind(const INTEGER_template& call__id, const INTEGER_template& notify);
extern MNCC__PDU_template tr__MNCC__DISC__ind(const INTEGER_template& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__DISC__ind(const INTEGER& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__DISC__req(const INTEGER& call__id, const MNCC__cause& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__DISC__req(const INTEGER_template& call__id, const MNCC__cause_template& cause, const MNCC__progress_template& prog, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__REL__ind(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__REL__ind(const INTEGER& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__REL__req(const INTEGER& call__id, const MNCC__cause& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__REL__req(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template tr__MNCC__REL__cnf(const INTEGER_template& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__REL__cnf(const INTEGER& call__id, const MNCC__cause_template& cause, const CHARSTRING_template& fac, const MNCC__useruser_template& uu);
extern MNCC__PDU_template ts__MNCC__FACILITY__req(const INTEGER& call__id, const CHARSTRING& fac);
extern MNCC__PDU_template tr__MNCC__FACILITY__ind(const INTEGER_template& call__id, const CHARSTRING_template& fac);
extern MNCC__PDU_template tr__MNCC__START__DTMF__ind(const INTEGER_template& call__id, const CHARSTRING_template& keypad);
extern MNCC__PDU_template ts__MNCC__START__DTMF__rsp(const INTEGER& call__id, const CHARSTRING& keypad);
extern MNCC__PDU_template ts__MNCC__START__DTMF__rej(const INTEGER& call__id, const MNCC__cause& cause);
extern MNCC__PDU_template tr__MNCC__STOP__DTMF__ind(const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__STOP__DTMF__rsp(const INTEGER& call__id);
extern MNCC__PDU_template tr__MNCC__MODIFY__ind(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap);
extern MNCC__PDU_template ts__MNCC__MODIFY__rsp(const INTEGER& call__id, const MNCC__bearer__cap& bcap);
extern MNCC__PDU_template ts__MNCC__MODIFY__req(const INTEGER& call__id, const MNCC__bearer__cap& bcap);
extern MNCC__PDU_template tr__MNCC__MODIFY__cnf(const INTEGER_template& call__id, const MNCC__bearer__cap_template& bcap);
extern MNCC__PDU_template ts__MNCC__USERINFO__req(const INTEGER& call__id, const MNCC__useruser& uu, const INTEGER& more);
extern MNCC__PDU_template tr__MNCC__USERINFO__ind(const INTEGER_template& call__id, const MNCC__useruser_template& uu, const INTEGER& more);
extern MNCC__PDU_template tr__MNCC__HOLD__ind(const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__HOLD__cnf(const INTEGER& call__id);
extern MNCC__PDU_template ts__MNCC__HOLD__rej(const INTEGER& call__id, const MNCC__cause& cause);
extern MNCC__PDU_template tr__MNCC__RETRIEVE__ind(const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__RETRIEVE__cnf(const INTEGER& call__id);
extern MNCC__PDU_template ts__MNCC__RETRIEVE__rej(const INTEGER& call__id, const MNCC__cause& cause);
extern MNCC__PDU_template ts__MNCC__SIMPLE__RTP(const MNCC__MsgType& msg__type, const INTEGER& call__id);
extern MNCC__PDU_template ts__MNCC__RTP__CREATE(const INTEGER& call__id);
extern MNCC__PDU_template tr__MNCC__RTP__CREATE(const INTEGER_template& call__id);
extern MNCC__PDU_template ts__MNCC__RTP__CONNECT(const INTEGER& call__id, const INTEGER& ip, const INTEGER& rtp__port, const INTEGER& pt);
extern MNCC__PDU_template tr__MNCC__RTP__CONNECT(const INTEGER_template& call__id, const INTEGER_template& ip, const INTEGER_template& rtp__port, const INTEGER_template& pt);
extern MNCC__PDU_template ts__MNCC__RTP__FREE(const INTEGER& call__id);
extern INTEGER f__mncc__get__call__id(const MNCC__PDU& pdu);

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t int__raw_;
extern const XERdescriptor_t int__xer_;
extern const TTCN_JSONdescriptor_t int__json_;
extern const TTCN_Typedescriptor_t int__descr_;
extern UNIVERSAL_CHARSTRING int__default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__ra_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__ra_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__ra_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__sig__access_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__sig__access_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__sig__access_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__user__rate_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__user__rate_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__user__rate_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__parity_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__parity_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__parity_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__interm__rate_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__interm__rate_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__interm__rate_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__transp_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__transp_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__transp_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__bcap__modem__type_raw_;
extern const TTCN_Typedescriptor_t GSM48__bcap__modem__type_descr_;
extern UNIVERSAL_CHARSTRING GSM48__bcap__modem__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__MsgType_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgType_descr_;
extern UNIVERSAL_CHARSTRING MNCC__MsgType_default_coding;
extern const INTEGER& GSM__MAX__FACILITY;
extern const INTEGER& GSM__MAX__SSVERSION;
extern const INTEGER& GSM__MAX__USERUSER;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_rate__adaptation_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_rate__adaptation_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_rate__adaptation_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_sig__access_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_sig__access_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_sig__access_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_async_raw_;
extern const XERdescriptor_t MNCC__bearer__cap__data_async_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap__data_async_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap__data_async_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_async_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_async_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_raw_;
extern const XERdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap__data_nr__stop__bits_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_nr__stop__bits_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_nr__stop__bits_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_nr__data__bits_raw_;
extern const XERdescriptor_t MNCC__bearer__cap__data_nr__data__bits_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap__data_nr__data__bits_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap__data_nr__data__bits_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_nr__data__bits_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_nr__data__bits_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_user__rate_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_user__rate_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_user__rate_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_parity_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_parity_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_parity_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_interm__rate_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_interm__rate_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_interm__rate_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_transp_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_transp_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_transp_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_modem__type_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_modem__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_modem__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap__data_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap__data_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap__data_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__speech__vers_raw_;
extern const TTCN_Typedescriptor_t MNCC__speech__vers_descr_;
extern const TTCN_RAWdescriptor_t MNCC__speech__vers_0_raw_;
extern const XERdescriptor_t MNCC__speech__vers_0_xer_;
extern const TTCN_JSONdescriptor_t MNCC__speech__vers_0_json_;
extern const TTCN_OERdescriptor_t MNCC__speech__vers_0_oer_;
extern const TTCN_Typedescriptor_t MNCC__speech__vers_0_descr_;
extern UNIVERSAL_CHARSTRING MNCC__speech__vers_0_default_coding;
extern UNIVERSAL_CHARSTRING MNCC__speech__vers_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_transfer_raw_;
extern const XERdescriptor_t MNCC__bearer__cap_transfer_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap_transfer_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap_transfer_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_transfer_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_transfer_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_mode_raw_;
extern const XERdescriptor_t MNCC__bearer__cap_mode_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap_mode_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap_mode_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_mode_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_mode_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_coding_raw_;
extern const XERdescriptor_t MNCC__bearer__cap_coding_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap_coding_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap_coding_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_coding_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_coding_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_radio_raw_;
extern const XERdescriptor_t MNCC__bearer__cap_radio_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap_radio_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap_radio_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_radio_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_radio_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_speech__ctm_raw_;
extern const XERdescriptor_t MNCC__bearer__cap_speech__ctm_xer_;
extern const TTCN_JSONdescriptor_t MNCC__bearer__cap_speech__ctm_json_;
extern const TTCN_OERdescriptor_t MNCC__bearer__cap_speech__ctm_oer_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_speech__ctm_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_speech__ctm_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_speech__ver_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_speech__ver_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_speech__ver_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_descr_;
extern const TTCN_RAWdescriptor_t MNCC__bearer__cap_data_raw_;
extern const TTCN_Typedescriptor_t MNCC__bearer__cap_data_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_data_default_coding;
extern UNIVERSAL_CHARSTRING MNCC__bearer__cap_default_coding;
extern const MNCC__bearer__cap_template& ts__MNCC__bcap__voice;
extern const TTCN_RAWdescriptor_t GSM48__type__of__number_raw_;
extern const TTCN_Typedescriptor_t GSM48__type__of__number_descr_;
extern UNIVERSAL_CHARSTRING GSM48__type__of__number_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_number__type_raw_;
extern const TTCN_Typedescriptor_t MNCC__number_number__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_number__type_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__num__plan__ind_raw_;
extern const TTCN_Typedescriptor_t GSM48__num__plan__ind_descr_;
extern UNIVERSAL_CHARSTRING GSM48__num__plan__ind_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_plan_raw_;
extern const TTCN_Typedescriptor_t MNCC__number_plan_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_plan_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__present__ind_raw_;
extern const TTCN_Typedescriptor_t GSM48__present__ind_descr_;
extern UNIVERSAL_CHARSTRING GSM48__present__ind_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_presence_raw_;
extern const TTCN_Typedescriptor_t MNCC__number_presence_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_presence_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__screening__ind_raw_;
extern const TTCN_Typedescriptor_t GSM48__screening__ind_descr_;
extern UNIVERSAL_CHARSTRING GSM48__screening__ind_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_screen_raw_;
extern const TTCN_Typedescriptor_t MNCC__number_screen_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_screen_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_number_raw_;
extern const XERdescriptor_t MNCC__number_number_xer_;
extern const TTCN_JSONdescriptor_t MNCC__number_number_json_;
extern const TTCN_Typedescriptor_t MNCC__number_number_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_number_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__number_raw_;
extern const TTCN_Typedescriptor_t MNCC__number_descr_;
extern UNIVERSAL_CHARSTRING MNCC__number_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__cause__coding_raw_;
extern const TTCN_Typedescriptor_t GSM48__cause__coding_descr_;
extern UNIVERSAL_CHARSTRING GSM48__cause__coding_default_coding;
extern const TTCN_RAWdescriptor_t GSM48__cause__loc_raw_;
extern const TTCN_Typedescriptor_t GSM48__cause__loc_descr_;
extern UNIVERSAL_CHARSTRING GSM48__cause__loc_default_coding;
extern const GSM48__type__of__number& ts__MNCC__number_ton_defval;
extern const GSM48__num__plan__ind& ts__MNCC__number_npi_defval;
extern const GSM48__present__ind& ts__MNCC__number_pres_defval;
extern const GSM48__screening__ind& ts__MNCC__number_screen_defval;
extern const GSM48__type__of__number_template& tr__MNCC__number_ton_defval;
extern const GSM48__num__plan__ind_template& tr__MNCC__number_npi_defval;
extern const GSM48__present__ind_template& tr__MNCC__number_pres_defval;
extern const GSM48__screening__ind_template& tr__MNCC__number_screen_defval;
extern const TTCN_RAWdescriptor_t MNCC__cause_location_raw_;
extern const TTCN_Typedescriptor_t MNCC__cause_location_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_location_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_coding_raw_;
extern const TTCN_Typedescriptor_t MNCC__cause_coding_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_coding_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_rec_raw_;
extern const XERdescriptor_t MNCC__cause_rec_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cause_rec_json_;
extern const TTCN_OERdescriptor_t MNCC__cause_rec_oer_;
extern const TTCN_Typedescriptor_t MNCC__cause_rec_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_rec_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_rec__val_raw_;
extern const XERdescriptor_t MNCC__cause_rec__val_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cause_rec__val_json_;
extern const TTCN_OERdescriptor_t MNCC__cause_rec__val_oer_;
extern const TTCN_Typedescriptor_t MNCC__cause_rec__val_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_rec__val_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_val_raw_;
extern const XERdescriptor_t MNCC__cause_val_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cause_val_json_;
extern const TTCN_OERdescriptor_t MNCC__cause_val_oer_;
extern const TTCN_Typedescriptor_t MNCC__cause_val_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_val_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_diag_raw_;
extern const XERdescriptor_t MNCC__cause_diag_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cause_diag_json_;
extern const TTCN_OERdescriptor_t MNCC__cause_diag_oer_;
extern const TTCN_Typedescriptor_t MNCC__cause_diag_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_diag_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cause_raw_;
extern const TTCN_Typedescriptor_t MNCC__cause_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cause_default_coding;
extern const GSM48__cause__loc& ts__MNCC__cause_loc_defval;
extern const GSM48__cause__coding& ts__MNCC__cause_coding_defval;
extern const OCTETSTRING& ts__MNCC__cause_diag_defval;
extern const TTCN_RAWdescriptor_t MNCC__useruser_proto_raw_;
extern const XERdescriptor_t MNCC__useruser_proto_xer_;
extern const TTCN_JSONdescriptor_t MNCC__useruser_proto_json_;
extern const TTCN_OERdescriptor_t MNCC__useruser_proto_oer_;
extern const TTCN_Typedescriptor_t MNCC__useruser_proto_descr_;
extern UNIVERSAL_CHARSTRING MNCC__useruser_proto_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__useruser_info_raw_;
extern const XERdescriptor_t MNCC__useruser_info_xer_;
extern const TTCN_JSONdescriptor_t MNCC__useruser_info_json_;
extern const TTCN_Typedescriptor_t MNCC__useruser_info_descr_;
extern UNIVERSAL_CHARSTRING MNCC__useruser_info_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__useruser_raw_;
extern const TTCN_Typedescriptor_t MNCC__useruser_descr_;
extern UNIVERSAL_CHARSTRING MNCC__useruser_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__progress_coding_raw_;
extern const XERdescriptor_t MNCC__progress_coding_xer_;
extern const TTCN_JSONdescriptor_t MNCC__progress_coding_json_;
extern const TTCN_OERdescriptor_t MNCC__progress_coding_oer_;
extern const TTCN_Typedescriptor_t MNCC__progress_coding_descr_;
extern UNIVERSAL_CHARSTRING MNCC__progress_coding_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__progress_location_raw_;
extern const XERdescriptor_t MNCC__progress_location_xer_;
extern const TTCN_JSONdescriptor_t MNCC__progress_location_json_;
extern const TTCN_OERdescriptor_t MNCC__progress_location_oer_;
extern const TTCN_Typedescriptor_t MNCC__progress_location_descr_;
extern UNIVERSAL_CHARSTRING MNCC__progress_location_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__progress_descr_raw_;
extern const XERdescriptor_t MNCC__progress_descr_xer_;
extern const TTCN_JSONdescriptor_t MNCC__progress_descr_json_;
extern const TTCN_OERdescriptor_t MNCC__progress_descr_oer_;
extern const TTCN_Typedescriptor_t MNCC__progress_descr_descr_;
extern UNIVERSAL_CHARSTRING MNCC__progress_descr_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__progress_raw_;
extern const TTCN_Typedescriptor_t MNCC__progress_descr_;
extern UNIVERSAL_CHARSTRING MNCC__progress_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cccap_dtmf_raw_;
extern const XERdescriptor_t MNCC__cccap_dtmf_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cccap_dtmf_json_;
extern const TTCN_OERdescriptor_t MNCC__cccap_dtmf_oer_;
extern const TTCN_Typedescriptor_t MNCC__cccap_dtmf_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cccap_dtmf_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cccap_pcp_raw_;
extern const XERdescriptor_t MNCC__cccap_pcp_xer_;
extern const TTCN_JSONdescriptor_t MNCC__cccap_pcp_json_;
extern const TTCN_OERdescriptor_t MNCC__cccap_pcp_oer_;
extern const TTCN_Typedescriptor_t MNCC__cccap_pcp_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cccap_pcp_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__cccap_raw_;
extern const TTCN_Typedescriptor_t MNCC__cccap_descr_;
extern UNIVERSAL_CHARSTRING MNCC__cccap_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__notify_raw_;
extern const XERdescriptor_t MNCC__notify_xer_;
extern const TTCN_JSONdescriptor_t MNCC__notify_json_;
extern const TTCN_OERdescriptor_t MNCC__notify_oer_;
extern const TTCN_Typedescriptor_t MNCC__notify_descr_;
extern UNIVERSAL_CHARSTRING MNCC__notify_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__keypad_raw_;
extern const XERdescriptor_t MNCC__keypad_xer_;
extern const TTCN_JSONdescriptor_t MNCC__keypad_json_;
extern const TTCN_Typedescriptor_t MNCC__keypad_descr_;
extern UNIVERSAL_CHARSTRING MNCC__keypad_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__bcap_raw_;
extern const TTCN_Typedescriptor_t MNCC__bcap_descr_;
extern UNIVERSAL_CHARSTRING MNCC__bcap_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_callref_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_callref_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_callref_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_callref_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_callref_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_callref_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_clir__sup_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_clir__sup_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_clir__sup_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_clir__sup_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_clir__sup_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_clir__sup_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_clir__inv_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_clir__inv_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_clir__inv_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_clir__inv_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_clir__inv_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_clir__inv_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_more_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_more_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_more_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_more_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_more_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_more_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_notify_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_notify_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_notify_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_notify_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_notify_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_notify_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_imsi_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_imsi_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_imsi_json_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_imsi_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_imsi_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_lchan__type_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_lchan__type_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_lchan__type_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_lchan__type_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_lchan__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_lchan__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_lchan__mode_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_lchan__mode_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_lchan__mode_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_lchan__mode_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_lchan__mode_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_lchan__mode_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_descr_;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_bearer__cap_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_bearer__cap_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_bearer__cap_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_called_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_called_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_called_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_calling_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_calling_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_calling_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_redirecting_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_redirecting_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_redirecting_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_connected_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_connected_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_connected_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_cause_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_cause_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_cause_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_progress_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_progress_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_progress_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_useruser_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_useruser_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_useruser_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_facility_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_facility_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_facility_json_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_facility_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_facility_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_cccap_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_cccap_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_cccap_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_ssversion_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_ssversion_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_ssversion_json_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_ssversion_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_ssversion_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_signal_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_signal_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_signal_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_signal_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_signal_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_signal_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_keypad_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_keypad_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_keypad_json_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_keypad_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_keypad_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Signal_emergency_raw_;
extern const XERdescriptor_t MNCC__PDU__Signal_emergency_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Signal_emergency_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Signal_emergency_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Signal_emergency_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_emergency_default_coding;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Signal_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Data_callref_raw_;
extern const XERdescriptor_t MNCC__PDU__Data_callref_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Data_callref_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Data_callref_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Data_callref_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Data_callref_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Data_data_raw_;
extern const XERdescriptor_t MNCC__PDU__Data_data_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Data_data_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Data_data_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Data_data_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Data_data_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Data_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Data_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Data_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_callref_raw_;
extern const XERdescriptor_t MNCC__PDU__Rtp_callref_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Rtp_callref_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Rtp_callref_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_callref_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_callref_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_ip_raw_;
extern const XERdescriptor_t MNCC__PDU__Rtp_ip_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Rtp_ip_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Rtp_ip_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_ip_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_ip_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_rtp__port_raw_;
extern const XERdescriptor_t MNCC__PDU__Rtp_rtp__port_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Rtp_rtp__port_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Rtp_rtp__port_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_rtp__port_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_rtp__port_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_payload__type_raw_;
extern const XERdescriptor_t MNCC__PDU__Rtp_payload__type_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Rtp_payload__type_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Rtp_payload__type_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_payload__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_payload__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_payload__msg__type_raw_;
extern const XERdescriptor_t MNCC__PDU__Rtp_payload__msg__type_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Rtp_payload__msg__type_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Rtp_payload__msg__type_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_payload__msg__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_payload__msg__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Rtp_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Rtp_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Rtp_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_version_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_version_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_version_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_version_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_version_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_version_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_mncc__size_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_mncc__size_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_mncc__size_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_mncc__size_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_mncc__size_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_mncc__size_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_data__frame__size_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_data__frame__size_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_data__frame__size_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_data__frame__size_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_data__frame__size_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_data__frame__size_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_called__offset_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_called__offset_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_called__offset_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_called__offset_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_called__offset_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_called__offset_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_signal__offset_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_signal__offset_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_signal__offset_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_signal__offset_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_signal__offset_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_signal__offset_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_emergency__offset_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_emergency__offset_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_emergency__offset_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_emergency__offset_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_emergency__offset_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_emergency__offset_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_lchan__type__offset_raw_;
extern const XERdescriptor_t MNCC__PDU__Hello_lchan__type__offset_xer_;
extern const TTCN_JSONdescriptor_t MNCC__PDU__Hello_lchan__type__offset_json_;
extern const TTCN_OERdescriptor_t MNCC__PDU__Hello_lchan__type__offset_oer_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_lchan__type__offset_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_lchan__type__offset_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU__Hello_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU__Hello_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU__Hello_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__MsgUnion_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgUnion_descr_;
extern const TTCN_RAWdescriptor_t MNCC__MsgUnion_signal_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgUnion_signal_descr_;
extern UNIVERSAL_CHARSTRING MNCC__MsgUnion_signal_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__MsgUnion_data_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgUnion_data_descr_;
extern UNIVERSAL_CHARSTRING MNCC__MsgUnion_data_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__MsgUnion_rtp_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgUnion_rtp_descr_;
extern UNIVERSAL_CHARSTRING MNCC__MsgUnion_rtp_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__MsgUnion_hello_raw_;
extern const TTCN_Typedescriptor_t MNCC__MsgUnion_hello_descr_;
extern UNIVERSAL_CHARSTRING MNCC__MsgUnion_hello_default_coding;
extern UNIVERSAL_CHARSTRING MNCC__MsgUnion_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU_msg__type_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU_msg__type_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU_msg__type_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU_u_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU_u_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU_u_default_coding;
extern const TTCN_RAWdescriptor_t MNCC__PDU_raw_;
extern const TTCN_Typedescriptor_t MNCC__PDU_descr_;
extern UNIVERSAL_CHARSTRING MNCC__PDU_default_coding;
extern const INTEGER& ts__MNCC__HELLO_version_defval;
extern const CHARSTRING& ts__MNCC__SETUP__req_imsi_defval;
extern const INTEGER_template& tr__MNCC__SETUP__req_call__id_defval;
extern const CHARSTRING_template& tr__MNCC__SETUP__req_called_defval;
extern const CHARSTRING_template& tr__MNCC__SETUP__req_calling_defval;
extern const CHARSTRING_template& tr__MNCC__SETUP__req_imsi_defval;
extern const CHARSTRING& ts__MNCC__SETUP__rsp_imsi_defval;
extern const MNCC__number_template& ts__MNCC__SETUP__rsp_connected_defval;
extern const CHARSTRING_template& tr__MNCC__SETUP__rsp_imsi_defval;
extern const MNCC__number_template& tr__MNCC__SETUP__rsp_connected_defval;
extern const INTEGER_template& tr__MNCC__SETUP__ind_call__id_defval;
extern const MNCC__number_template& tr__MNCC__SETUP__ind_called_defval;
extern const MNCC__number_template& tr__MNCC__SETUP__ind_calling_defval;
extern const CHARSTRING_template& tr__MNCC__SETUP__ind_imsi_defval;
extern const MNCC__number_template& ts__MNCC__SETUP__ind_calling_defval;
extern const CHARSTRING_template& ts__MNCC__SETUP__ind_imsi_defval;
extern const MNCC__bearer__cap_template& ts__MNCC__SETUP__ind_bcap_defval;
extern const MNCC__number_template& ts__MNCC__SETUP__CNF_connected_defval;
extern const MNCC__number_template& tr__MNCC__SETUP__cnf_connected_defval;
extern const INTEGER_template& tr__MNCC__SETUP__COMPL__ind_call__id_defval;
extern const MNCC__cause_template& tr__MNCC__REJ__req_cause_defval;
extern const MNCC__cause_template& ts__MNCC__REJ__ind_cause_defval;
extern const MNCC__bearer__cap_template& tr__MNCC__CALL__CONF__ind_bcap_defval;
extern const MNCC__cause_template& tr__MNCC__CALL__CONF__ind_cause_defval;
extern const MNCC__cccap_template& tr__MNCC__CALL__CONF__ind_cccap_defval;
extern const MNCC__bearer__cap_template& ts__MNCC__CALL__CONF__ind_bcap_defval;
extern const MNCC__cause_template& ts__MNCC__CALL__CONF__ind_cause_defval;
extern const MNCC__cccap_template& ts__MNCC__CALL__CONF__ind_cccap_defval;
extern const MNCC__bearer__cap_template& ts__MNCC__CALL__PROC__req_bcap_defval;
extern const MNCC__progress_template& ts__MNCC__CALL__PROC__req_prog_defval;
extern const CHARSTRING_template& ts__MNCC__CALL__PROC__req_fac_defval;
extern const MNCC__cccap_template& ts__MNCC__CALL__PROC__req_cccap_defval;
extern const MNCC__bearer__cap_template& tr__MNCC__CALL__PROC__req_bcap_defval;
extern const MNCC__progress_template& tr__MNCC__CALL__PROC__req_prog_defval;
extern const CHARSTRING_template& tr__MNCC__CALL__PROC__req_fac_defval;
extern const MNCC__cccap_template& tr__MNCC__CALL__PROC__req_cccap_defval;
extern const MNCC__useruser_template& ts__MNCC__PROGRESS__req_uu_defval;
extern const MNCC__progress_template& ts__MNCC__ALERT__req_prog_defval;
extern const CHARSTRING_template& ts__MNCC__ALERT__req_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__ALERT__req_uu_defval;
extern const MNCC__progress_template& tr__MNCC__ALERT__req_prog_defval;
extern const CHARSTRING_template& tr__MNCC__ALERT__req_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__ALERT__req_uu_defval;
extern const MNCC__progress_template& tr__MNCC__ALERT__ind_prog_defval;
extern const CHARSTRING_template& tr__MNCC__ALERT__ind_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__ALERT__ind_uu_defval;
extern const MNCC__progress_template& ts__MNCC__ALERT__ind_prog_defval;
extern const CHARSTRING_template& ts__MNCC__ALERT__ind_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__ALERT__ind_uu_defval;
extern const INTEGER_template& tr__MNCC__DISC__ind_call__id_defval;
extern const MNCC__cause_template& tr__MNCC__DISC__ind_cause_defval;
extern const MNCC__progress_template& tr__MNCC__DISC__ind_prog_defval;
extern const CHARSTRING_template& tr__MNCC__DISC__ind_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__DISC__ind_uu_defval;
extern const MNCC__progress_template& ts__MNCC__DISC__ind_prog_defval;
extern const CHARSTRING_template& ts__MNCC__DISC__ind_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__DISC__ind_uu_defval;
extern const MNCC__progress_template& ts__MNCC__DISC__req_prog_defval;
extern const CHARSTRING_template& ts__MNCC__DISC__req_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__DISC__req_uu_defval;
extern const MNCC__cause_template& tr__MNCC__DISC__req_cause_defval;
extern const MNCC__progress_template& tr__MNCC__DISC__req_prog_defval;
extern const CHARSTRING_template& tr__MNCC__DISC__req_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__DISC__req_uu_defval;
extern const INTEGER_template& tr__MNCC__REL__ind_call__id_defval;
extern const MNCC__cause_template& tr__MNCC__REL__ind_cause_defval;
extern const CHARSTRING_template& tr__MNCC__REL__ind_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__REL__ind_uu_defval;
extern const CHARSTRING_template& ts__MNCC__REL__ind_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__REL__ind_uu_defval;
extern const CHARSTRING_template& ts__MNCC__REL__req_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__REL__req_uu_defval;
extern const MNCC__cause_template& tr__MNCC__REL__req_cause_defval;
extern const CHARSTRING_template& tr__MNCC__REL__req_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__REL__req_uu_defval;
extern const INTEGER_template& tr__MNCC__REL__cnf_call__id_defval;
extern const MNCC__cause_template& tr__MNCC__REL__cnf_cause_defval;
extern const CHARSTRING_template& tr__MNCC__REL__cnf_fac_defval;
extern const MNCC__useruser_template& tr__MNCC__REL__cnf_uu_defval;
extern const CHARSTRING_template& ts__MNCC__REL__cnf_fac_defval;
extern const MNCC__useruser_template& ts__MNCC__REL__cnf_uu_defval;
extern const INTEGER_template& tr__MNCC__FACILITY__ind_call__id_defval;
extern const CHARSTRING_template& tr__MNCC__FACILITY__ind_fac_defval;
extern const INTEGER_template& tr__MNCC__START__DTMF__ind_call__id_defval;
extern const CHARSTRING_template& tr__MNCC__START__DTMF__ind_keypad_defval;
extern const INTEGER_template& tr__MNCC__STOP__DTMF__ind_call__id_defval;
extern const INTEGER_template& tr__MNCC__MODIFY__ind_call__id_defval;
extern const MNCC__bearer__cap_template& tr__MNCC__MODIFY__ind_bcap_defval;
extern const INTEGER_template& tr__MNCC__MODIFY__cnf_call__id_defval;
extern const MNCC__bearer__cap_template& tr__MNCC__MODIFY__cnf_bcap_defval;
extern const INTEGER_template& tr__MNCC__USERINFO__ind_call__id_defval;
extern const MNCC__useruser_template& tr__MNCC__USERINFO__ind_uu_defval;
extern const INTEGER_template& tr__MNCC__HOLD__ind_call__id_defval;
extern const INTEGER_template& tr__MNCC__RETRIEVE__ind_call__id_defval;
extern const INTEGER_template& tr__MNCC__RTP__CREATE_call__id_defval;
extern const INTEGER_template& tr__MNCC__RTP__CONNECT_ip_defval;
extern const INTEGER_template& tr__MNCC__RTP__CONNECT_rtp__port_defval;
extern const INTEGER_template& tr__MNCC__RTP__CONNECT_pt_defval;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
