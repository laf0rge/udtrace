// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R5A
// The generation of user and time information were disabled by the -D flag.

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "PCUIF_Types.hh"

namespace PCUIF__Types {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char bs_1_bits[] = { 0 },
bs_3_bits[] = { 0 },
bs_0_bits[] = { 0, 0 },
bs_2_bits[] = { 128 };
static const BITSTRING bs_1(3, bs_1_bits),
bs_3(8, bs_3_bits),
bs_0(14, bs_0_bits),
bs_2(8, bs_2_bits);
static const unsigned char os_2_octets[] = { 0 },
os_0_octets[] = { 0, 0 },
os_1_octets[] = { 0, 0, 0 },
os_4_octets[] = { 0, 0, 0, 0 },
os_3_octets[] = { 7 };
static const OCTETSTRING os_2(1, os_2_octets),
os_0(2, os_0_octets),
os_1(3, os_1_octets),
os_4(4, os_4_octets),
os_3(1, os_3_octets);
static const CHARSTRING cs_0(12, "/tmp/pcu_bts");
static const unsigned char module_checksum[] = { 0x14, 0x83, 0x83, 0x91, 0xca, 0x91, 0x4c, 0x23, 0x88, 0x82, 0xad, 0xfd, 0x2d, 0xa6, 0x37, 0x42 };

/* Global variable definitions */

static CHARSTRING const_PCU__SOCK__DEFAULT;
const CHARSTRING& PCU__SOCK__DEFAULT = const_PCU__SOCK__DEFAULT;
static INTEGER const_PCU__IF__VERSION;
const INTEGER& PCU__IF__VERSION = const_PCU__IF__VERSION;
const TTCN_RAWdescriptor_t PCUIF__MsgType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgType
const TTCN_Typedescriptor_t PCUIF__MsgType_descr_ = { "@PCUIF_Types.PCUIF_MsgType", NULL, &PCUIF__MsgType_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgType_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__Sapi
const TTCN_Typedescriptor_t PCUIF__Sapi_descr_ = { "@PCUIF_Types.PCUIF_Sapi", NULL, &PCUIF__Sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_bts__active_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_bts__active_xer_ = { {"bts_active>\n", "bts_active>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_bts__active_oer_ext_arr_[0] = {};
const int PCUIF__Flags_bts__active_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_bts__active_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_bts__active_oer_ext_arr_, 0, PCUIF__Flags_bts__active_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_bts__active_descr_ = { "@PCUIF_Types.PCUIF_Flags.bts_active", &BOOLEAN_ber_, &PCUIF__Flags_bts__active_raw_, &BOOLEAN_text_, &PCUIF__Flags_bts__active_xer_, &BOOLEAN_json_, &PCUIF__Flags_bts__active_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_bts__active_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_sysmo__direct__dsp_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_sysmo__direct__dsp_xer_ = { {"sysmo_direct_dsp>\n", "sysmo_direct_dsp>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_sysmo__direct__dsp_oer_ext_arr_[0] = {};
const int PCUIF__Flags_sysmo__direct__dsp_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_sysmo__direct__dsp_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_sysmo__direct__dsp_oer_ext_arr_, 0, PCUIF__Flags_sysmo__direct__dsp_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_sysmo__direct__dsp_descr_ = { "@PCUIF_Types.PCUIF_Flags.sysmo_direct_dsp", &BOOLEAN_ber_, &PCUIF__Flags_sysmo__direct__dsp_raw_, &BOOLEAN_text_, &PCUIF__Flags_sysmo__direct__dsp_xer_, &BOOLEAN_json_, &PCUIF__Flags_sysmo__direct__dsp_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_sysmo__direct__dsp_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_spare_raw_ = {14,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,14,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_spare_xer_ = { {"spare>\n", "spare>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PCUIF__Flags_spare_descr_ = { "@PCUIF_Types.PCUIF_Flags.spare", &BITSTRING_ber_, &PCUIF__Flags_spare_raw_, NULL, &PCUIF__Flags_spare_xer_, &BITSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_spare_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_cs1_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_cs1_xer_ = { {"cs1>\n", "cs1>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_cs1_oer_ext_arr_[0] = {};
const int PCUIF__Flags_cs1_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_cs1_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_cs1_oer_ext_arr_, 0, PCUIF__Flags_cs1_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_cs1_descr_ = { "@PCUIF_Types.PCUIF_Flags.cs1", &BOOLEAN_ber_, &PCUIF__Flags_cs1_raw_, &BOOLEAN_text_, &PCUIF__Flags_cs1_xer_, &BOOLEAN_json_, &PCUIF__Flags_cs1_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_cs1_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_cs2_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_cs2_xer_ = { {"cs2>\n", "cs2>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_cs2_oer_ext_arr_[0] = {};
const int PCUIF__Flags_cs2_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_cs2_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_cs2_oer_ext_arr_, 0, PCUIF__Flags_cs2_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_cs2_descr_ = { "@PCUIF_Types.PCUIF_Flags.cs2", &BOOLEAN_ber_, &PCUIF__Flags_cs2_raw_, &BOOLEAN_text_, &PCUIF__Flags_cs2_xer_, &BOOLEAN_json_, &PCUIF__Flags_cs2_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_cs2_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_cs3_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_cs3_xer_ = { {"cs3>\n", "cs3>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_cs3_oer_ext_arr_[0] = {};
const int PCUIF__Flags_cs3_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_cs3_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_cs3_oer_ext_arr_, 0, PCUIF__Flags_cs3_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_cs3_descr_ = { "@PCUIF_Types.PCUIF_Flags.cs3", &BOOLEAN_ber_, &PCUIF__Flags_cs3_raw_, &BOOLEAN_text_, &PCUIF__Flags_cs3_xer_, &BOOLEAN_json_, &PCUIF__Flags_cs3_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_cs3_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_cs4_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_cs4_xer_ = { {"cs4>\n", "cs4>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_cs4_oer_ext_arr_[0] = {};
const int PCUIF__Flags_cs4_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_cs4_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_cs4_oer_ext_arr_, 0, PCUIF__Flags_cs4_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_cs4_descr_ = { "@PCUIF_Types.PCUIF_Flags.cs4", &BOOLEAN_ber_, &PCUIF__Flags_cs4_raw_, &BOOLEAN_text_, &PCUIF__Flags_cs4_xer_, &BOOLEAN_json_, &PCUIF__Flags_cs4_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_cs4_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs1_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs1_xer_ = { {"mcs1>\n", "mcs1>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs1_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs1_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs1_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs1_oer_ext_arr_, 0, PCUIF__Flags_mcs1_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs1_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs1", &BOOLEAN_ber_, &PCUIF__Flags_mcs1_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs1_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs1_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs1_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs2_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs2_xer_ = { {"mcs2>\n", "mcs2>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs2_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs2_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs2_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs2_oer_ext_arr_, 0, PCUIF__Flags_mcs2_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs2_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs2", &BOOLEAN_ber_, &PCUIF__Flags_mcs2_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs2_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs2_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs2_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs3_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs3_xer_ = { {"mcs3>\n", "mcs3>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs3_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs3_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs3_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs3_oer_ext_arr_, 0, PCUIF__Flags_mcs3_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs3_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs3", &BOOLEAN_ber_, &PCUIF__Flags_mcs3_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs3_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs3_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs3_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs4_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs4_xer_ = { {"mcs4>\n", "mcs4>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs4_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs4_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs4_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs4_oer_ext_arr_, 0, PCUIF__Flags_mcs4_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs4_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs4", &BOOLEAN_ber_, &PCUIF__Flags_mcs4_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs4_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs4_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs4_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs5_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs5_xer_ = { {"mcs5>\n", "mcs5>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs5_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs5_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs5_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs5_oer_ext_arr_, 0, PCUIF__Flags_mcs5_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs5_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs5", &BOOLEAN_ber_, &PCUIF__Flags_mcs5_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs5_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs5_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs5_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs6_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs6_xer_ = { {"mcs6>\n", "mcs6>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs6_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs6_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs6_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs6_oer_ext_arr_, 0, PCUIF__Flags_mcs6_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs6_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs6", &BOOLEAN_ber_, &PCUIF__Flags_mcs6_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs6_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs6_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs6_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs7_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs7_xer_ = { {"mcs7>\n", "mcs7>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs7_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs7_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs7_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs7_oer_ext_arr_, 0, PCUIF__Flags_mcs7_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs7_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs7", &BOOLEAN_ber_, &PCUIF__Flags_mcs7_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs7_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs7_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs7_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs8_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs8_xer_ = { {"mcs8>\n", "mcs8>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs8_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs8_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs8_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs8_oer_ext_arr_, 0, PCUIF__Flags_mcs8_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs8_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs8", &BOOLEAN_ber_, &PCUIF__Flags_mcs8_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs8_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs8_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs8_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_mcs9_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_mcs9_xer_ = { {"mcs9>\n", "mcs9>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Flags_mcs9_oer_ext_arr_[0] = {};
const int PCUIF__Flags_mcs9_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Flags_mcs9_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Flags_mcs9_oer_ext_arr_, 0, PCUIF__Flags_mcs9_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Flags_mcs9_descr_ = { "@PCUIF_Types.PCUIF_Flags.mcs9", &BOOLEAN_ber_, &PCUIF__Flags_mcs9_raw_, &BOOLEAN_text_, &PCUIF__Flags_mcs9_xer_, &BOOLEAN_json_, &PCUIF__Flags_mcs9_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_mcs9_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_spare2_raw_ = {3,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,3,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Flags_spare2_xer_ = { {"spare2>\n", "spare2>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PCUIF__Flags_spare2_descr_ = { "@PCUIF_Types.PCUIF_Flags.spare2", &BITSTRING_ber_, &PCUIF__Flags_spare2_raw_, NULL, &PCUIF__Flags_spare2_xer_, &BITSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_spare2_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Flags_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__Flags
const TTCN_Typedescriptor_t PCUIF__Flags_descr_ = { "@PCUIF_Types.PCUIF_Flags", NULL, &PCUIF__Flags_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Flags_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__TextType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__TextType
const TTCN_Typedescriptor_t PCUIF__TextType_descr_ = { "@PCUIF_Types.PCUIF_TextType", NULL, &PCUIF__TextType_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__TextType_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Text_raw_ = {1024,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,128,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Text_xer_ = { {"PCUIF_Text>\n", "PCUIF_Text>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PCUIF__Text_descr_ = { "@PCUIF_Types.PCUIF_Text", NULL, &PCUIF__Text_raw_, &CHARSTRING_text_, &PCUIF__Text_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Text_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__txt__ind_txt__type_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__txt__ind_txt__type
const TTCN_Typedescriptor_t PCUIF__txt__ind_txt__type_descr_ = { "@PCUIF_Types.PCUIF_txt_ind.txt_type", NULL, &PCUIF__txt__ind_txt__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__txt__ind_txt__type_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__txt__ind_text_raw_ = {1024,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,128,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__txt__ind_text_xer_ = { {"text>\n", "text>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PCUIF__txt__ind_text_descr_ = { "@PCUIF_Types.PCUIF_txt_ind.text", NULL, &PCUIF__txt__ind_text_raw_, &CHARSTRING_text_, &PCUIF__txt__ind_text_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__txt__ind_text_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__txt__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__txt__ind
const TTCN_Typedescriptor_t PCUIF__txt__ind_descr_ = { "@PCUIF_Types.PCUIF_txt_ind", NULL, &PCUIF__txt__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__txt__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t OCT162_raw_ = {1296,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,162,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       OCT162_xer_ = { {"OCT162>\n", "OCT162>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int OCT162_oer_ext_arr_[0] = {};
const int OCT162_oer_p_[0] = {};
const TTCN_OERdescriptor_t OCT162_oer_ = { -1, TRUE, -1, FALSE, 0, 0, OCT162_oer_ext_arr_, 0, OCT162_oer_p_};
const TTCN_Typedescriptor_t OCT162_descr_ = { "@PCUIF_Types.OCT162", &OCTETSTRING_ber_, &OCT162_raw_, &OCTETSTRING_text_, &OCT162_xer_, &OCTETSTRING_json_, &OCT162_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING OCT162_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__data_sapi
const TTCN_Typedescriptor_t PCUIF__data_sapi_descr_ = { "@PCUIF_Types.PCUIF_data.sapi", NULL, &PCUIF__data_sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_len_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_len_xer_ = { {"len>\n", "len>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_len_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_len_descr_ = { "@PCUIF_Types.PCUIF_data.len", &INTEGER_ber_, &PCUIF__data_len_raw_, &INTEGER_text_, &PCUIF__data_len_xer_, &INTEGER_json_, &PCUIF__data_len_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_len_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_data_raw_ = {1296,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,162,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__data_data_oer_ext_arr_[0] = {};
const int PCUIF__data_data_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__data_data_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__data_data_oer_ext_arr_, 0, PCUIF__data_data_oer_p_};
const TTCN_Typedescriptor_t PCUIF__data_data_descr_ = { "@PCUIF_Types.PCUIF_data.data", &OCTETSTRING_ber_, &PCUIF__data_data_raw_, &OCTETSTRING_text_, &PCUIF__data_data_xer_, &OCTETSTRING_json_, &PCUIF__data_data_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_data_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_fn_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_fn_xer_ = { {"fn>\n", "fn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_fn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_fn_descr_ = { "@PCUIF_Types.PCUIF_data.fn", &INTEGER_ber_, &PCUIF__data_fn_raw_, &INTEGER_text_, &PCUIF__data_fn_xer_, &INTEGER_json_, &PCUIF__data_fn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_fn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_arfcn_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_arfcn_xer_ = { {"arfcn>\n", "arfcn>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_arfcn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_arfcn_descr_ = { "@PCUIF_Types.PCUIF_data.arfcn", &INTEGER_ber_, &PCUIF__data_arfcn_raw_, &INTEGER_text_, &PCUIF__data_arfcn_xer_, &INTEGER_json_, &PCUIF__data_arfcn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_arfcn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_trx__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_trx__nr_xer_ = { {"trx_nr>\n", "trx_nr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_trx__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_trx__nr_descr_ = { "@PCUIF_Types.PCUIF_data.trx_nr", &INTEGER_ber_, &PCUIF__data_trx__nr_raw_, &INTEGER_text_, &PCUIF__data_trx__nr_xer_, &INTEGER_json_, &PCUIF__data_trx__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_trx__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_ts__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_ts__nr_xer_ = { {"ts_nr>\n", "ts_nr>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_ts__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_ts__nr_descr_ = { "@PCUIF_Types.PCUIF_data.ts_nr", &INTEGER_ber_, &PCUIF__data_ts__nr_raw_, &INTEGER_text_, &PCUIF__data_ts__nr_xer_, &INTEGER_json_, &PCUIF__data_ts__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_ts__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_block__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_block__nr_xer_ = { {"block_nr>\n", "block_nr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_block__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_block__nr_descr_ = { "@PCUIF_Types.PCUIF_data.block_nr", &INTEGER_ber_, &PCUIF__data_block__nr_raw_, &INTEGER_text_, &PCUIF__data_block__nr_xer_, &INTEGER_json_, &PCUIF__data_block__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_block__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_rssi_raw_ = {8,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_rssi_xer_ = { {"rssi>\n", "rssi>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_rssi_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_rssi_descr_ = { "@PCUIF_Types.PCUIF_data.rssi", &INTEGER_ber_, &PCUIF__data_rssi_raw_, &INTEGER_text_, &PCUIF__data_rssi_xer_, &INTEGER_json_, &PCUIF__data_rssi_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_rssi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_ber10k_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_ber10k_xer_ = { {"ber10k>\n", "ber10k>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_ber10k_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_ber10k_descr_ = { "@PCUIF_Types.PCUIF_data.ber10k", &INTEGER_ber_, &PCUIF__data_ber10k_raw_, &INTEGER_text_, &PCUIF__data_ber10k_xer_, &INTEGER_json_, &PCUIF__data_ber10k_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_ber10k_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_ta__offs__qbits_raw_ = {16,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_ta__offs__qbits_xer_ = { {"ta_offs_qbits>\n", "ta_offs_qbits>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_ta__offs__qbits_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_ta__offs__qbits_descr_ = { "@PCUIF_Types.PCUIF_data.ta_offs_qbits", &INTEGER_ber_, &PCUIF__data_ta__offs__qbits_raw_, &INTEGER_text_, &PCUIF__data_ta__offs__qbits_xer_, &INTEGER_json_, &PCUIF__data_ta__offs__qbits_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_ta__offs__qbits_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_lqual__cb_raw_ = {16,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data_lqual__cb_xer_ = { {"lqual_cb>\n", "lqual_cb>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data_lqual__cb_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data_lqual__cb_descr_ = { "@PCUIF_Types.PCUIF_data.lqual_cb", &INTEGER_ber_, &PCUIF__data_lqual__cb_raw_, &INTEGER_text_, &PCUIF__data_lqual__cb_xer_, &INTEGER_json_, &PCUIF__data_lqual__cb_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_lqual__cb_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__data
const TTCN_Typedescriptor_t PCUIF__data_descr_ = { "@PCUIF_Types.PCUIF_data", NULL, &PCUIF__data_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__data__cnf__dt_sapi
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_sapi_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.sapi", NULL, &PCUIF__data__cnf__dt_sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_tlli_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_tlli_xer_ = { {"tlli>\n", "tlli>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__data__cnf__dt_tlli_oer_ext_arr_[0] = {};
const int PCUIF__data__cnf__dt_tlli_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_tlli_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__data__cnf__dt_tlli_oer_ext_arr_, 0, PCUIF__data__cnf__dt_tlli_oer_p_};
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_tlli_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.tlli", &OCTETSTRING_ber_, &PCUIF__data__cnf__dt_tlli_raw_, &OCTETSTRING_text_, &PCUIF__data__cnf__dt_tlli_xer_, &OCTETSTRING_json_, &PCUIF__data__cnf__dt_tlli_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_tlli_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_fn_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_fn_xer_ = { {"fn>\n", "fn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_fn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_fn_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.fn", &INTEGER_ber_, &PCUIF__data__cnf__dt_fn_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_fn_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_fn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_fn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_arfcn_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_arfcn_xer_ = { {"arfcn>\n", "arfcn>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_arfcn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_arfcn_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.arfcn", &INTEGER_ber_, &PCUIF__data__cnf__dt_arfcn_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_arfcn_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_arfcn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_arfcn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_trx__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_trx__nr_xer_ = { {"trx_nr>\n", "trx_nr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_trx__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_trx__nr_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.trx_nr", &INTEGER_ber_, &PCUIF__data__cnf__dt_trx__nr_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_trx__nr_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_trx__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_trx__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_ts__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_ts__nr_xer_ = { {"ts_nr>\n", "ts_nr>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_ts__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_ts__nr_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.ts_nr", &INTEGER_ber_, &PCUIF__data__cnf__dt_ts__nr_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_ts__nr_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_ts__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_ts__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_block__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_block__nr_xer_ = { {"block_nr>\n", "block_nr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_block__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_block__nr_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.block_nr", &INTEGER_ber_, &PCUIF__data__cnf__dt_block__nr_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_block__nr_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_block__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_block__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_rssi_raw_ = {8,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_rssi_xer_ = { {"rssi>\n", "rssi>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_rssi_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_rssi_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.rssi", &INTEGER_ber_, &PCUIF__data__cnf__dt_rssi_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_rssi_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_rssi_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_rssi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_ber10k_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_ber10k_xer_ = { {"ber10k>\n", "ber10k>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_ber10k_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_ber10k_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.ber10k", &INTEGER_ber_, &PCUIF__data__cnf__dt_ber10k_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_ber10k_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_ber10k_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_ber10k_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_ta__offs__qbits_raw_ = {16,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_ta__offs__qbits_xer_ = { {"ta_offs_qbits>\n", "ta_offs_qbits>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_ta__offs__qbits_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_ta__offs__qbits_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.ta_offs_qbits", &INTEGER_ber_, &PCUIF__data__cnf__dt_ta__offs__qbits_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_ta__offs__qbits_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_ta__offs__qbits_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_ta__offs__qbits_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_lqual__cb_raw_ = {16,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__data__cnf__dt_lqual__cb_xer_ = { {"lqual_cb>\n", "lqual_cb>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__data__cnf__dt_lqual__cb_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_lqual__cb_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt.lqual_cb", &INTEGER_ber_, &PCUIF__data__cnf__dt_lqual__cb_raw_, &INTEGER_text_, &PCUIF__data__cnf__dt_lqual__cb_xer_, &INTEGER_json_, &PCUIF__data__cnf__dt_lqual__cb_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_lqual__cb_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__data__cnf__dt_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__data__cnf__dt
const TTCN_Typedescriptor_t PCUIF__data__cnf__dt_descr_ = { "@PCUIF_Types.PCUIF_data_cnf_dt", NULL, &PCUIF__data__cnf__dt_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__data__cnf__dt_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__rts__req_sapi
const TTCN_Typedescriptor_t PCUIF__rts__req_sapi_descr_ = { "@PCUIF_Types.PCUIF_rts_req.sapi", NULL, &PCUIF__rts__req_sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_spare_raw_ = {24,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,3,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_spare_xer_ = { {"spare>\n", "spare>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__rts__req_spare_oer_ext_arr_[0] = {};
const int PCUIF__rts__req_spare_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__rts__req_spare_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__rts__req_spare_oer_ext_arr_, 0, PCUIF__rts__req_spare_oer_p_};
const TTCN_Typedescriptor_t PCUIF__rts__req_spare_descr_ = { "@PCUIF_Types.PCUIF_rts_req.spare", &OCTETSTRING_ber_, &PCUIF__rts__req_spare_raw_, &OCTETSTRING_text_, &PCUIF__rts__req_spare_xer_, &OCTETSTRING_json_, &PCUIF__rts__req_spare_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_spare_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_fn_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_fn_xer_ = { {"fn>\n", "fn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rts__req_fn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rts__req_fn_descr_ = { "@PCUIF_Types.PCUIF_rts_req.fn", &INTEGER_ber_, &PCUIF__rts__req_fn_raw_, &INTEGER_text_, &PCUIF__rts__req_fn_xer_, &INTEGER_json_, &PCUIF__rts__req_fn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_fn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_arfcn_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_arfcn_xer_ = { {"arfcn>\n", "arfcn>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rts__req_arfcn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rts__req_arfcn_descr_ = { "@PCUIF_Types.PCUIF_rts_req.arfcn", &INTEGER_ber_, &PCUIF__rts__req_arfcn_raw_, &INTEGER_text_, &PCUIF__rts__req_arfcn_xer_, &INTEGER_json_, &PCUIF__rts__req_arfcn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_arfcn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_trx__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_trx__nr_xer_ = { {"trx_nr>\n", "trx_nr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rts__req_trx__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rts__req_trx__nr_descr_ = { "@PCUIF_Types.PCUIF_rts_req.trx_nr", &INTEGER_ber_, &PCUIF__rts__req_trx__nr_raw_, &INTEGER_text_, &PCUIF__rts__req_trx__nr_xer_, &INTEGER_json_, &PCUIF__rts__req_trx__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_trx__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_ts__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_ts__nr_xer_ = { {"ts_nr>\n", "ts_nr>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rts__req_ts__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rts__req_ts__nr_descr_ = { "@PCUIF_Types.PCUIF_rts_req.ts_nr", &INTEGER_ber_, &PCUIF__rts__req_ts__nr_raw_, &INTEGER_text_, &PCUIF__rts__req_ts__nr_xer_, &INTEGER_json_, &PCUIF__rts__req_ts__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_ts__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_block__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rts__req_block__nr_xer_ = { {"block_nr>\n", "block_nr>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rts__req_block__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rts__req_block__nr_descr_ = { "@PCUIF_Types.PCUIF_rts_req.block_nr", &INTEGER_ber_, &PCUIF__rts__req_block__nr_raw_, &INTEGER_text_, &PCUIF__rts__req_block__nr_xer_, &INTEGER_json_, &PCUIF__rts__req_block__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_block__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rts__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__rts__req
const TTCN_Typedescriptor_t PCUIF__rts__req_descr_ = { "@PCUIF_Types.PCUIF_rts_req", NULL, &PCUIF__rts__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rts__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__BurstType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__BurstType
const TTCN_Typedescriptor_t PCUIF__BurstType_descr_ = { "@PCUIF_Types.PCUIF_BurstType", NULL, &PCUIF__BurstType_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__BurstType_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__rach__ind_sapi
const TTCN_Typedescriptor_t PCUIF__rach__ind_sapi_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.sapi", NULL, &PCUIF__rach__ind_sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_ra_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rach__ind_ra_xer_ = { {"ra>\n", "ra>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rach__ind_ra_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rach__ind_ra_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.ra", &INTEGER_ber_, &PCUIF__rach__ind_ra_raw_, &INTEGER_text_, &PCUIF__rach__ind_ra_xer_, &INTEGER_json_, &PCUIF__rach__ind_ra_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_ra_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_qta_raw_ = {16,SG_SG_BIT,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rach__ind_qta_xer_ = { {"qta>\n", "qta>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rach__ind_qta_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rach__ind_qta_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.qta", &INTEGER_ber_, &PCUIF__rach__ind_qta_raw_, &INTEGER_text_, &PCUIF__rach__ind_qta_xer_, &INTEGER_json_, &PCUIF__rach__ind_qta_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_qta_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_fn_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rach__ind_fn_xer_ = { {"fn>\n", "fn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rach__ind_fn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rach__ind_fn_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.fn", &INTEGER_ber_, &PCUIF__rach__ind_fn_raw_, &INTEGER_text_, &PCUIF__rach__ind_fn_xer_, &INTEGER_json_, &PCUIF__rach__ind_fn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_fn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_arfcn_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rach__ind_arfcn_xer_ = { {"arfcn>\n", "arfcn>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rach__ind_arfcn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rach__ind_arfcn_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.arfcn", &INTEGER_ber_, &PCUIF__rach__ind_arfcn_raw_, &INTEGER_text_, &PCUIF__rach__ind_arfcn_xer_, &INTEGER_json_, &PCUIF__rach__ind_arfcn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_arfcn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_is__11bit_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__rach__ind_is__11bit_xer_ = { {"is_11bit>\n", "is_11bit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__rach__ind_is__11bit_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__rach__ind_is__11bit_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.is_11bit", &INTEGER_ber_, &PCUIF__rach__ind_is__11bit_raw_, &INTEGER_text_, &PCUIF__rach__ind_is__11bit_xer_, &INTEGER_json_, &PCUIF__rach__ind_is__11bit_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_is__11bit_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_burst__type_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__rach__ind_burst__type
const TTCN_Typedescriptor_t PCUIF__rach__ind_burst__type_descr_ = { "@PCUIF_Types.PCUIF_rach_ind.burst_type", NULL, &PCUIF__rach__ind_burst__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_burst__type_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__rach__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__rach__ind
const TTCN_Typedescriptor_t PCUIF__rach__ind_descr_ = { "@PCUIF_Types.PCUIF_rach_ind", NULL, &PCUIF__rach__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__rach__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_arfcn_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__InfoTrx_arfcn_xer_ = { {"arfcn>\n", "arfcn>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__InfoTrx_arfcn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__InfoTrx_arfcn_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx.arfcn", &INTEGER_ber_, &PCUIF__InfoTrx_arfcn_raw_, &INTEGER_text_, &PCUIF__InfoTrx_arfcn_xer_, &INTEGER_json_, &PCUIF__InfoTrx_arfcn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_arfcn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_pdch__mask_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_MSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__InfoTrx_pdch__mask_xer_ = { {"pdch_mask>\n", "pdch_mask>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PCUIF__InfoTrx_pdch__mask_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx.pdch_mask", &BITSTRING_ber_, &PCUIF__InfoTrx_pdch__mask_raw_, NULL, &PCUIF__InfoTrx_pdch__mask_xer_, &BITSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_pdch__mask_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_spare_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__InfoTrx_spare_xer_ = { {"spare>\n", "spare>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__InfoTrx_spare_oer_ext_arr_[0] = {};
const int PCUIF__InfoTrx_spare_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__InfoTrx_spare_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__InfoTrx_spare_oer_ext_arr_, 0, PCUIF__InfoTrx_spare_oer_p_};
const TTCN_Typedescriptor_t PCUIF__InfoTrx_spare_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx.spare", &OCTETSTRING_ber_, &PCUIF__InfoTrx_spare_raw_, &OCTETSTRING_text_, &PCUIF__InfoTrx_spare_xer_, &OCTETSTRING_json_, &PCUIF__InfoTrx_spare_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_spare_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_tsc_raw_ = {64,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__InfoTrx_tsc_xer_ = { {"tsc>\n", "tsc>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__InfoTrx_tsc_oer_ext_arr_[0] = {};
const int PCUIF__InfoTrx_tsc_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__InfoTrx_tsc_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__InfoTrx_tsc_oer_ext_arr_, 0, PCUIF__InfoTrx_tsc_oer_p_};
const TTCN_Typedescriptor_t PCUIF__InfoTrx_tsc_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx.tsc", &OCTETSTRING_ber_, &PCUIF__InfoTrx_tsc_raw_, &OCTETSTRING_text_, &PCUIF__InfoTrx_tsc_xer_, &OCTETSTRING_json_, &PCUIF__InfoTrx_tsc_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_tsc_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_hLayer1_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__InfoTrx_hLayer1_xer_ = { {"hLayer1>\n", "hLayer1>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__InfoTrx_hLayer1_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__InfoTrx_hLayer1_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx.hLayer1", &INTEGER_ber_, &PCUIF__InfoTrx_hLayer1_raw_, &INTEGER_text_, &PCUIF__InfoTrx_hLayer1_xer_, &INTEGER_json_, &PCUIF__InfoTrx_hLayer1_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_hLayer1_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrx_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__InfoTrx
const TTCN_Typedescriptor_t PCUIF__InfoTrx_descr_ = { "@PCUIF_Types.PCUIF_InfoTrx", NULL, &PCUIF__InfoTrx_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrx_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__InfoTrxs_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__InfoTrxs
const TTCN_Typedescriptor_t PCUIF__InfoTrxs_descr_ = { "@PCUIF_Types.PCUIF_InfoTrxs", NULL, &PCUIF__InfoTrxs_raw_, NULL, NULL, NULL, NULL, &PCUIF__InfoTrxs_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__InfoTrxs_0_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__InfoTrxs_0
const TTCN_Typedescriptor_t PCUIF__InfoTrxs_0_descr_ = { "@PCUIF_Types.PCUIF_InfoTrxs.<oftype>", NULL, &PCUIF__InfoTrxs_0_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__InfoTrxs_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__InfoTrxs_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_version_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_version_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_version_descr_ = { "@PCUIF_Types.PCUIF_info_ind.version", &INTEGER_ber_, &PCUIF__info__ind_version_raw_, &INTEGER_text_, &PCUIF__info__ind_version_xer_, &INTEGER_json_, &PCUIF__info__ind_version_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_version_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_flags_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_flags
const TTCN_Typedescriptor_t PCUIF__info__ind_flags_descr_ = { "@PCUIF_Types.PCUIF_info_ind.flags", NULL, &PCUIF__info__ind_flags_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_flags_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_trx_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_trx
const TTCN_Typedescriptor_t PCUIF__info__ind_trx_descr_ = { "@PCUIF_Types.PCUIF_info_ind.trx", NULL, &PCUIF__info__ind_trx_raw_, NULL, NULL, NULL, NULL, &PCUIF__InfoTrxs_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_trx_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_bsic_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_bsic_xer_ = { {"bsic>\n", "bsic>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_bsic_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_bsic_descr_ = { "@PCUIF_Types.PCUIF_info_ind.bsic", &INTEGER_ber_, &PCUIF__info__ind_bsic_raw_, &INTEGER_text_, &PCUIF__info__ind_bsic_xer_, &INTEGER_json_, &PCUIF__info__ind_bsic_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_bsic_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_mcc_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_mcc_xer_ = { {"mcc>\n", "mcc>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_mcc_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_mcc_descr_ = { "@PCUIF_Types.PCUIF_info_ind.mcc", &INTEGER_ber_, &PCUIF__info__ind_mcc_raw_, &INTEGER_text_, &PCUIF__info__ind_mcc_xer_, &INTEGER_json_, &PCUIF__info__ind_mcc_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_mcc_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_mnc_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_mnc_xer_ = { {"mnc>\n", "mnc>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_mnc_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_mnc_descr_ = { "@PCUIF_Types.PCUIF_info_ind.mnc", &INTEGER_ber_, &PCUIF__info__ind_mnc_raw_, &INTEGER_text_, &PCUIF__info__ind_mnc_xer_, &INTEGER_json_, &PCUIF__info__ind_mnc_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_mnc_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_mnc__3__digits_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_mnc__3__digits_xer_ = { {"mnc_3_digits>\n", "mnc_3_digits>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_mnc__3__digits_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_mnc__3__digits_descr_ = { "@PCUIF_Types.PCUIF_info_ind.mnc_3_digits", &INTEGER_ber_, &PCUIF__info__ind_mnc__3__digits_raw_, &INTEGER_text_, &PCUIF__info__ind_mnc__3__digits_xer_, &INTEGER_json_, &PCUIF__info__ind_mnc__3__digits_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_mnc__3__digits_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_lac_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_lac_xer_ = { {"lac>\n", "lac>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_lac_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_lac_descr_ = { "@PCUIF_Types.PCUIF_info_ind.lac", &INTEGER_ber_, &PCUIF__info__ind_lac_raw_, &INTEGER_text_, &PCUIF__info__ind_lac_xer_, &INTEGER_json_, &PCUIF__info__ind_lac_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_lac_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_rac_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_rac_xer_ = { {"rac>\n", "rac>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_rac_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_rac_descr_ = { "@PCUIF_Types.PCUIF_info_ind.rac", &INTEGER_ber_, &PCUIF__info__ind_rac_raw_, &INTEGER_text_, &PCUIF__info__ind_rac_xer_, &INTEGER_json_, &PCUIF__info__ind_rac_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_rac_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_nsei_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_nsei_xer_ = { {"nsei>\n", "nsei>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_nsei_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_nsei_descr_ = { "@PCUIF_Types.PCUIF_info_ind.nsei", &INTEGER_ber_, &PCUIF__info__ind_nsei_raw_, &INTEGER_text_, &PCUIF__info__ind_nsei_xer_, &INTEGER_json_, &PCUIF__info__ind_nsei_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_nsei_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_nse__timer_raw_ = {7,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_nse__timer
const TTCN_Typedescriptor_t PCUIF__info__ind_nse__timer_descr_ = { "@PCUIF_Types.PCUIF_info_ind.nse_timer", NULL, &PCUIF__info__ind_nse__timer_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_nse__timer_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_nse__timer_0_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_nse__timer_0_xer_ = { {"uint8_t>\n", "uint8_t>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_nse__timer_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_nse__timer_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.nse_timer.<oftype>", &INTEGER_ber_, &PCUIF__info__ind_nse__timer_0_raw_, &INTEGER_text_, &PCUIF__info__ind_nse__timer_0_xer_, &INTEGER_json_, &PCUIF__info__ind_nse__timer_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_nse__timer_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_nse__timer_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_cell__timer_raw_ = {11,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_cell__timer
const TTCN_Typedescriptor_t PCUIF__info__ind_cell__timer_descr_ = { "@PCUIF_Types.PCUIF_info_ind.cell_timer", NULL, &PCUIF__info__ind_cell__timer_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_cell__timer_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_cell__timer_0_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_cell__timer_0_xer_ = { {"uint8_t>\n", "uint8_t>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_cell__timer_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_cell__timer_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.cell_timer.<oftype>", &INTEGER_ber_, &PCUIF__info__ind_cell__timer_0_raw_, &INTEGER_text_, &PCUIF__info__ind_cell__timer_0_xer_, &INTEGER_json_, &PCUIF__info__ind_cell__timer_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_cell__timer_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_cell__timer_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_cell__id_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_cell__id_xer_ = { {"cell_id>\n", "cell_id>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_cell__id_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_cell__id_descr_ = { "@PCUIF_Types.PCUIF_info_ind.cell_id", &INTEGER_ber_, &PCUIF__info__ind_cell__id_raw_, &INTEGER_text_, &PCUIF__info__ind_cell__id_xer_, &INTEGER_json_, &PCUIF__info__ind_cell__id_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_cell__id_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_repeat__time_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_repeat__time_xer_ = { {"repeat_time>\n", "repeat_time>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_repeat__time_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_repeat__time_descr_ = { "@PCUIF_Types.PCUIF_info_ind.repeat_time", &INTEGER_ber_, &PCUIF__info__ind_repeat__time_raw_, &INTEGER_text_, &PCUIF__info__ind_repeat__time_xer_, &INTEGER_json_, &PCUIF__info__ind_repeat__time_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_repeat__time_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_repeat__count_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_repeat__count_xer_ = { {"repeat_count>\n", "repeat_count>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_repeat__count_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_repeat__count_descr_ = { "@PCUIF_Types.PCUIF_info_ind.repeat_count", &INTEGER_ber_, &PCUIF__info__ind_repeat__count_raw_, &INTEGER_text_, &PCUIF__info__ind_repeat__count_xer_, &INTEGER_json_, &PCUIF__info__ind_repeat__count_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_repeat__count_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_bvci_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_bvci_xer_ = { {"bvci>\n", "bvci>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_bvci_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_bvci_descr_ = { "@PCUIF_Types.PCUIF_info_ind.bvci", &INTEGER_ber_, &PCUIF__info__ind_bvci_raw_, &INTEGER_text_, &PCUIF__info__ind_bvci_xer_, &INTEGER_json_, &PCUIF__info__ind_bvci_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_bvci_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3142_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3142_xer_ = { {"t3142>\n", "t3142>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3142_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3142_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3142", &INTEGER_ber_, &PCUIF__info__ind_t3142_raw_, &INTEGER_text_, &PCUIF__info__ind_t3142_xer_, &INTEGER_json_, &PCUIF__info__ind_t3142_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3142_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3169_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3169_xer_ = { {"t3169>\n", "t3169>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3169_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3169_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3169", &INTEGER_ber_, &PCUIF__info__ind_t3169_raw_, &INTEGER_text_, &PCUIF__info__ind_t3169_xer_, &INTEGER_json_, &PCUIF__info__ind_t3169_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3169_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3191_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3191_xer_ = { {"t3191>\n", "t3191>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3191_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3191_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3191", &INTEGER_ber_, &PCUIF__info__ind_t3191_raw_, &INTEGER_text_, &PCUIF__info__ind_t3191_xer_, &INTEGER_json_, &PCUIF__info__ind_t3191_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3191_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3193__10ms_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3193__10ms_xer_ = { {"t3193_10ms>\n", "t3193_10ms>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3193__10ms_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3193__10ms_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3193_10ms", &INTEGER_ber_, &PCUIF__info__ind_t3193__10ms_raw_, &INTEGER_text_, &PCUIF__info__ind_t3193__10ms_xer_, &INTEGER_json_, &PCUIF__info__ind_t3193__10ms_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3193__10ms_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3195_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3195_xer_ = { {"t3195>\n", "t3195>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3195_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3195_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3195", &INTEGER_ber_, &PCUIF__info__ind_t3195_raw_, &INTEGER_text_, &PCUIF__info__ind_t3195_xer_, &INTEGER_json_, &PCUIF__info__ind_t3195_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3195_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3101_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3101_xer_ = { {"t3101>\n", "t3101>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3101_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3101_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3101", &INTEGER_ber_, &PCUIF__info__ind_t3101_raw_, &INTEGER_text_, &PCUIF__info__ind_t3101_xer_, &INTEGER_json_, &PCUIF__info__ind_t3101_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3101_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3103_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3103_xer_ = { {"t3103>\n", "t3103>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3103_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3103_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3103", &INTEGER_ber_, &PCUIF__info__ind_t3103_raw_, &INTEGER_text_, &PCUIF__info__ind_t3103_xer_, &INTEGER_json_, &PCUIF__info__ind_t3103_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3103_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_t3105_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_t3105_xer_ = { {"t3105>\n", "t3105>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_t3105_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_t3105_descr_ = { "@PCUIF_Types.PCUIF_info_ind.t3105", &INTEGER_ber_, &PCUIF__info__ind_t3105_raw_, &INTEGER_text_, &PCUIF__info__ind_t3105_xer_, &INTEGER_json_, &PCUIF__info__ind_t3105_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_t3105_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_cv__countdown_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_cv__countdown_xer_ = { {"cv_countdown>\n", "cv_countdown>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_cv__countdown_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_cv__countdown_descr_ = { "@PCUIF_Types.PCUIF_info_ind.cv_countdown", &INTEGER_ber_, &PCUIF__info__ind_cv__countdown_raw_, &INTEGER_text_, &PCUIF__info__ind_cv__countdown_xer_, &INTEGER_json_, &PCUIF__info__ind_cv__countdown_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_cv__countdown_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_dl__tbf__ext_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_dl__tbf__ext_xer_ = { {"dl_tbf_ext>\n", "dl_tbf_ext>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_dl__tbf__ext_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_dl__tbf__ext_descr_ = { "@PCUIF_Types.PCUIF_info_ind.dl_tbf_ext", &INTEGER_ber_, &PCUIF__info__ind_dl__tbf__ext_raw_, &INTEGER_text_, &PCUIF__info__ind_dl__tbf__ext_xer_, &INTEGER_json_, &PCUIF__info__ind_dl__tbf__ext_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_dl__tbf__ext_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_ul__tbf__ext_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_ul__tbf__ext_xer_ = { {"ul_tbf_ext>\n", "ul_tbf_ext>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_ul__tbf__ext_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_ul__tbf__ext_descr_ = { "@PCUIF_Types.PCUIF_info_ind.ul_tbf_ext", &INTEGER_ber_, &PCUIF__info__ind_ul__tbf__ext_raw_, &INTEGER_text_, &PCUIF__info__ind_ul__tbf__ext_xer_, &INTEGER_json_, &PCUIF__info__ind_ul__tbf__ext_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_ul__tbf__ext_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_initial__cs_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_initial__cs_xer_ = { {"initial_cs>\n", "initial_cs>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_initial__cs_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_initial__cs_descr_ = { "@PCUIF_Types.PCUIF_info_ind.initial_cs", &INTEGER_ber_, &PCUIF__info__ind_initial__cs_raw_, &INTEGER_text_, &PCUIF__info__ind_initial__cs_xer_, &INTEGER_json_, &PCUIF__info__ind_initial__cs_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_initial__cs_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_initial__mcs_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_initial__mcs_xer_ = { {"initial_mcs>\n", "initial_mcs>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_initial__mcs_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_initial__mcs_descr_ = { "@PCUIF_Types.PCUIF_info_ind.initial_mcs", &INTEGER_ber_, &PCUIF__info__ind_initial__mcs_raw_, &INTEGER_text_, &PCUIF__info__ind_initial__mcs_xer_, &INTEGER_json_, &PCUIF__info__ind_initial__mcs_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_initial__mcs_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_nsvci_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_nsvci
const TTCN_Typedescriptor_t PCUIF__info__ind_nsvci_descr_ = { "@PCUIF_Types.PCUIF_info_ind.nsvci", NULL, &PCUIF__info__ind_nsvci_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_nsvci_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_nsvci_0_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_nsvci_0_xer_ = { {"uint16_t>\n", "uint16_t>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_nsvci_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_nsvci_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.nsvci.<oftype>", &INTEGER_ber_, &PCUIF__info__ind_nsvci_0_raw_, &INTEGER_text_, &PCUIF__info__ind_nsvci_0_xer_, &INTEGER_json_, &PCUIF__info__ind_nsvci_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_nsvci_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_nsvci_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_local__pprt_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_local__pprt
const TTCN_Typedescriptor_t PCUIF__info__ind_local__pprt_descr_ = { "@PCUIF_Types.PCUIF_info_ind.local_pprt", NULL, &PCUIF__info__ind_local__pprt_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_local__pprt_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_local__pprt_0_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_local__pprt_0_xer_ = { {"uint16_t>\n", "uint16_t>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_local__pprt_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_local__pprt_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.local_pprt.<oftype>", &INTEGER_ber_, &PCUIF__info__ind_local__pprt_0_raw_, &INTEGER_text_, &PCUIF__info__ind_local__pprt_0_xer_, &INTEGER_json_, &PCUIF__info__ind_local__pprt_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_local__pprt_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_local__pprt_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_remote__port_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_remote__port
const TTCN_Typedescriptor_t PCUIF__info__ind_remote__port_descr_ = { "@PCUIF_Types.PCUIF_info_ind.remote_port", NULL, &PCUIF__info__ind_remote__port_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_remote__port_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_remote__port_0_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_remote__port_0_xer_ = { {"uint16_t>\n", "uint16_t>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__info__ind_remote__port_0_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__info__ind_remote__port_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.remote_port.<oftype>", &INTEGER_ber_, &PCUIF__info__ind_remote__port_0_raw_, &INTEGER_text_, &PCUIF__info__ind_remote__port_0_xer_, &INTEGER_json_, &PCUIF__info__ind_remote__port_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_remote__port_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_remote__port_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_remote__ip_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind_remote__ip
const TTCN_Typedescriptor_t PCUIF__info__ind_remote__ip_descr_ = { "@PCUIF_Types.PCUIF_info_ind.remote_ip", NULL, &PCUIF__info__ind_remote__ip_raw_, NULL, NULL, NULL, NULL, &PCUIF__info__ind_remote__ip_0_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__info__ind_remote__ip_0_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__info__ind_remote__ip_0_xer_ = { {"OCT4>\n", "OCT4>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__info__ind_remote__ip_0_oer_ext_arr_[0] = {};
const int PCUIF__info__ind_remote__ip_0_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__info__ind_remote__ip_0_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__info__ind_remote__ip_0_oer_ext_arr_, 0, PCUIF__info__ind_remote__ip_0_oer_p_};
const TTCN_Typedescriptor_t PCUIF__info__ind_remote__ip_0_descr_ = { "@PCUIF_Types.PCUIF_info_ind.remote_ip.<oftype>", &OCTETSTRING_ber_, &PCUIF__info__ind_remote__ip_0_raw_, &OCTETSTRING_text_, &PCUIF__info__ind_remote__ip_0_xer_, &OCTETSTRING_json_, &PCUIF__info__ind_remote__ip_0_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_remote__ip_0_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__info__ind_remote__ip_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__info__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__info__ind
const TTCN_Typedescriptor_t PCUIF__info__ind_descr_ = { "@PCUIF_Types.PCUIF_info_ind", NULL, &PCUIF__info__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__info__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__act__req_is__activate_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__act__req_is__activate_xer_ = { {"is_activate>\n", "is_activate>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__act__req_is__activate_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__act__req_is__activate_descr_ = { "@PCUIF_Types.PCUIF_act_req.is_activate", &INTEGER_ber_, &PCUIF__act__req_is__activate_raw_, &INTEGER_text_, &PCUIF__act__req_is__activate_xer_, &INTEGER_json_, &PCUIF__act__req_is__activate_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__act__req_is__activate_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__act__req_trx__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__act__req_trx__nr_xer_ = { {"trx_nr>\n", "trx_nr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__act__req_trx__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__act__req_trx__nr_descr_ = { "@PCUIF_Types.PCUIF_act_req.trx_nr", &INTEGER_ber_, &PCUIF__act__req_trx__nr_raw_, &INTEGER_text_, &PCUIF__act__req_trx__nr_xer_, &INTEGER_json_, &PCUIF__act__req_trx__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__act__req_trx__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__act__req_ts__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__act__req_ts__nr_xer_ = { {"ts_nr>\n", "ts_nr>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__act__req_ts__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__act__req_ts__nr_descr_ = { "@PCUIF_Types.PCUIF_act_req.ts_nr", &INTEGER_ber_, &PCUIF__act__req_ts__nr_raw_, &INTEGER_text_, &PCUIF__act__req_ts__nr_xer_, &INTEGER_json_, &PCUIF__act__req_ts__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__act__req_ts__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__act__req_spare_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__act__req_spare_xer_ = { {"spare>\n", "spare>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__act__req_spare_oer_ext_arr_[0] = {};
const int PCUIF__act__req_spare_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__act__req_spare_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__act__req_spare_oer_ext_arr_, 0, PCUIF__act__req_spare_oer_p_};
const TTCN_Typedescriptor_t PCUIF__act__req_spare_descr_ = { "@PCUIF_Types.PCUIF_act_req.spare", &OCTETSTRING_ber_, &PCUIF__act__req_spare_raw_, &OCTETSTRING_text_, &PCUIF__act__req_spare_xer_, &OCTETSTRING_json_, &PCUIF__act__req_spare_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__act__req_spare_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__act__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__act__req
const TTCN_Typedescriptor_t PCUIF__act__req_descr_ = { "@PCUIF_Types.PCUIF_act_req", NULL, &PCUIF__act__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__act__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__time__ind_fn_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__time__ind_fn_xer_ = { {"fn>\n", "fn>\n"}, {4, 4}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__time__ind_fn_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__time__ind_fn_descr_ = { "@PCUIF_Types.PCUIF_time_ind.fn", &INTEGER_ber_, &PCUIF__time__ind_fn_raw_, &INTEGER_text_, &PCUIF__time__ind_fn_xer_, &INTEGER_json_, &PCUIF__time__ind_fn_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__time__ind_fn_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__time__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__time__ind
const TTCN_Typedescriptor_t PCUIF__time__ind_descr_ = { "@PCUIF_Types.PCUIF_time_ind", NULL, &PCUIF__time__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__time__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__pag__req_sapi_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__pag__req_sapi
const TTCN_Typedescriptor_t PCUIF__pag__req_sapi_descr_ = { "@PCUIF_Types.PCUIF_pag_req.sapi", NULL, &PCUIF__pag__req_sapi_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__pag__req_sapi_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__pag__req_chan__needed_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__pag__req_chan__needed_xer_ = { {"chan_needed>\n", "chan_needed>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__pag__req_chan__needed_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__pag__req_chan__needed_descr_ = { "@PCUIF_Types.PCUIF_pag_req.chan_needed", &INTEGER_ber_, &PCUIF__pag__req_chan__needed_raw_, &INTEGER_text_, &PCUIF__pag__req_chan__needed_xer_, &INTEGER_json_, &PCUIF__pag__req_chan__needed_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__pag__req_chan__needed_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__pag__req_identity__lv_raw_ = {72,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,9,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__pag__req_identity__lv_xer_ = { {"identity_lv>\n", "identity_lv>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__pag__req_identity__lv_oer_ext_arr_[0] = {};
const int PCUIF__pag__req_identity__lv_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__pag__req_identity__lv_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__pag__req_identity__lv_oer_ext_arr_, 0, PCUIF__pag__req_identity__lv_oer_p_};
const TTCN_Typedescriptor_t PCUIF__pag__req_identity__lv_descr_ = { "@PCUIF_Types.PCUIF_pag_req.identity_lv", &OCTETSTRING_ber_, &PCUIF__pag__req_identity__lv_raw_, &OCTETSTRING_text_, &PCUIF__pag__req_identity__lv_xer_, &OCTETSTRING_json_, &PCUIF__pag__req_identity__lv_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__pag__req_identity__lv_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__pag__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__pag__req
const TTCN_Typedescriptor_t PCUIF__pag__req_descr_ = { "@PCUIF_Types.PCUIF_pag_req", NULL, &PCUIF__pag__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__pag__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__susp__req_tlli_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,4,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__susp__req_tlli_xer_ = { {"tlli>\n", "tlli>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__susp__req_tlli_oer_ext_arr_[0] = {};
const int PCUIF__susp__req_tlli_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__susp__req_tlli_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__susp__req_tlli_oer_ext_arr_, 0, PCUIF__susp__req_tlli_oer_p_};
const TTCN_Typedescriptor_t PCUIF__susp__req_tlli_descr_ = { "@PCUIF_Types.PCUIF_susp_req.tlli", &OCTETSTRING_ber_, &PCUIF__susp__req_tlli_raw_, &OCTETSTRING_text_, &PCUIF__susp__req_tlli_xer_, &OCTETSTRING_json_, &PCUIF__susp__req_tlli_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__susp__req_tlli_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__susp__req_ra__id_raw_ = {48,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,6,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__susp__req_ra__id_xer_ = { {"ra_id>\n", "ra_id>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__susp__req_ra__id_oer_ext_arr_[0] = {};
const int PCUIF__susp__req_ra__id_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__susp__req_ra__id_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__susp__req_ra__id_oer_ext_arr_, 0, PCUIF__susp__req_ra__id_oer_p_};
const TTCN_Typedescriptor_t PCUIF__susp__req_ra__id_descr_ = { "@PCUIF_Types.PCUIF_susp_req.ra_id", &OCTETSTRING_ber_, &PCUIF__susp__req_ra__id_raw_, &OCTETSTRING_text_, &PCUIF__susp__req_ra__id_xer_, &OCTETSTRING_json_, &PCUIF__susp__req_ra__id_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__susp__req_ra__id_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__susp__req_cause_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__susp__req_cause_xer_ = { {"cause>\n", "cause>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__susp__req_cause_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__susp__req_cause_descr_ = { "@PCUIF_Types.PCUIF_susp_req.cause", &INTEGER_ber_, &PCUIF__susp__req_cause_raw_, &INTEGER_text_, &PCUIF__susp__req_cause_xer_, &INTEGER_json_, &PCUIF__susp__req_cause_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__susp__req_cause_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__susp__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__susp__req
const TTCN_Typedescriptor_t PCUIF__susp__req_descr_ = { "@PCUIF_Types.PCUIF_susp_req", NULL, &PCUIF__susp__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__susp__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion
const TTCN_Typedescriptor_t PCUIF__MsgUnion_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion", NULL, &PCUIF__MsgUnion_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_data__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_data__req
const TTCN_Typedescriptor_t PCUIF__MsgUnion_data__req_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.data_req", NULL, &PCUIF__MsgUnion_data__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_data__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_data__cnf_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_data__cnf
const TTCN_Typedescriptor_t PCUIF__MsgUnion_data__cnf_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.data_cnf", NULL, &PCUIF__MsgUnion_data__cnf_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_data__cnf_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_data__cnf__dt_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_data__cnf__dt
const TTCN_Typedescriptor_t PCUIF__MsgUnion_data__cnf__dt_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.data_cnf_dt", NULL, &PCUIF__MsgUnion_data__cnf__dt_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_data__cnf__dt_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_data__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_data__ind
const TTCN_Typedescriptor_t PCUIF__MsgUnion_data__ind_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.data_ind", NULL, &PCUIF__MsgUnion_data__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_data__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_susp__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_susp__req
const TTCN_Typedescriptor_t PCUIF__MsgUnion_susp__req_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.susp_req", NULL, &PCUIF__MsgUnion_susp__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_susp__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_rts__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_rts__req
const TTCN_Typedescriptor_t PCUIF__MsgUnion_rts__req_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.rts_req", NULL, &PCUIF__MsgUnion_rts__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_rts__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_rach__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_rach__ind
const TTCN_Typedescriptor_t PCUIF__MsgUnion_rach__ind_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.rach_ind", NULL, &PCUIF__MsgUnion_rach__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_rach__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_txt__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_txt__ind
const TTCN_Typedescriptor_t PCUIF__MsgUnion_txt__ind_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.txt_ind", NULL, &PCUIF__MsgUnion_txt__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_txt__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_info__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_info__ind
const TTCN_Typedescriptor_t PCUIF__MsgUnion_info__ind_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.info_ind", NULL, &PCUIF__MsgUnion_info__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_info__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_act__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_act__req
const TTCN_Typedescriptor_t PCUIF__MsgUnion_act__req_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.act_req", NULL, &PCUIF__MsgUnion_act__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_act__req_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_time__ind_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_time__ind
const TTCN_Typedescriptor_t PCUIF__MsgUnion_time__ind_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.time_ind", NULL, &PCUIF__MsgUnion_time__ind_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_time__ind_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__MsgUnion_pag__req_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__MsgUnion_pag__req
const TTCN_Typedescriptor_t PCUIF__MsgUnion_pag__req_descr_ = { "@PCUIF_Types.PCUIF_MsgUnion.pag_req", NULL, &PCUIF__MsgUnion_pag__req_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_pag__req_default_coding("RAW");
UNIVERSAL_CHARSTRING PCUIF__MsgUnion_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Message_msg__type_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__Message_msg__type
const TTCN_Typedescriptor_t PCUIF__Message_msg__type_descr_ = { "@PCUIF_Types.PCUIF_Message.msg_type", NULL, &PCUIF__Message_msg__type_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Message_msg__type_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Message_bts__nr_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Message_bts__nr_xer_ = { {"bts_nr>\n", "bts_nr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_OERdescriptor_t PCUIF__Message_bts__nr_oer_ = { -1, FALSE, -1, FALSE, 0, 0, NULL, 0, NULL };
const TTCN_Typedescriptor_t PCUIF__Message_bts__nr_descr_ = { "@PCUIF_Types.PCUIF_Message.bts_nr", &INTEGER_ber_, &PCUIF__Message_bts__nr_raw_, &INTEGER_text_, &PCUIF__Message_bts__nr_xer_, &INTEGER_json_, &PCUIF__Message_bts__nr_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Message_bts__nr_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Message_spare_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,2,CharCoding::UNKNOWN,NULL};
const XERdescriptor_t       PCUIF__Message_spare_xer_ = { {"spare>\n", "spare>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int PCUIF__Message_spare_oer_ext_arr_[0] = {};
const int PCUIF__Message_spare_oer_p_[0] = {};
const TTCN_OERdescriptor_t PCUIF__Message_spare_oer_ = { -1, TRUE, -1, FALSE, 0, 0, PCUIF__Message_spare_oer_ext_arr_, 0, PCUIF__Message_spare_oer_p_};
const TTCN_Typedescriptor_t PCUIF__Message_spare_descr_ = { "@PCUIF_Types.PCUIF_Message.spare", &OCTETSTRING_ber_, &PCUIF__Message_spare_raw_, &OCTETSTRING_text_, &PCUIF__Message_spare_xer_, &OCTETSTRING_json_, &PCUIF__Message_spare_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Message_spare_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Message_u_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__Message_u
const TTCN_Typedescriptor_t PCUIF__Message_u_descr_ = { "@PCUIF_Types.PCUIF_Message.u", NULL, &PCUIF__Message_u_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Message_u_default_coding("RAW");
const TTCN_RAWdescriptor_t PCUIF__Message_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,1696,0,0,8,0,NULL,-1,CharCoding::UNKNOWN,NULL};
// No XER for PCUIF__Message
const TTCN_Typedescriptor_t PCUIF__Message_descr_ = { "@PCUIF_Types.PCUIF_Message", NULL, &PCUIF__Message_raw_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING PCUIF__Message_default_coding("RAW");
static INTEGER_template template_tr__PCUIF__RTS__REQ_bts__nr_defval;
const INTEGER_template& tr__PCUIF__RTS__REQ_bts__nr_defval = template_tr__PCUIF__RTS__REQ_bts__nr_defval;
static INTEGER_template template_tr__PCUIF__RTS__REQ_trx__nr_defval;
const INTEGER_template& tr__PCUIF__RTS__REQ_trx__nr_defval = template_tr__PCUIF__RTS__REQ_trx__nr_defval;
static INTEGER_template template_tr__PCUIF__RTS__REQ_ts__nr_defval;
const INTEGER_template& tr__PCUIF__RTS__REQ_ts__nr_defval = template_tr__PCUIF__RTS__REQ_ts__nr_defval;
static PCUIF__Sapi_template template_tr__PCUIF__RTS__REQ_sapi_defval;
const PCUIF__Sapi_template& tr__PCUIF__RTS__REQ_sapi_defval = template_tr__PCUIF__RTS__REQ_sapi_defval;
static INTEGER_template template_tr__PCUIF__RTS__REQ_fn_defval;
const INTEGER_template& tr__PCUIF__RTS__REQ_fn_defval = template_tr__PCUIF__RTS__REQ_fn_defval;
static INTEGER_template template_tr__PCUIF__RTS__REQ_block__nr_defval;
const INTEGER_template& tr__PCUIF__RTS__REQ_block__nr_defval = template_tr__PCUIF__RTS__REQ_block__nr_defval;
static CHARSTRING_template template_tr__PCUIF__TXT__IND_text_defval;
const CHARSTRING_template& tr__PCUIF__TXT__IND_text_defval = template_tr__PCUIF__TXT__IND_text_defval;
static INTEGER_template template_ts__PCUIF__DATA__IND_rssi_defval;
const INTEGER_template& ts__PCUIF__DATA__IND_rssi_defval = template_ts__PCUIF__DATA__IND_rssi_defval;
static INTEGER_template template_ts__PCUIF__DATA__IND_ber10k_defval;
const INTEGER_template& ts__PCUIF__DATA__IND_ber10k_defval = template_ts__PCUIF__DATA__IND_ber10k_defval;
static INTEGER_template template_ts__PCUIF__DATA__IND_ta__offs__qbits_defval;
const INTEGER_template& ts__PCUIF__DATA__IND_ta__offs__qbits_defval = template_ts__PCUIF__DATA__IND_ta__offs__qbits_defval;
static INTEGER_template template_ts__PCUIF__DATA__IND_lqual__cb_defval;
const INTEGER_template& ts__PCUIF__DATA__IND_lqual__cb_defval = template_ts__PCUIF__DATA__IND_lqual__cb_defval;
static INTEGER_template template_tr__PCUIF__DATA__IND_bts__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__IND_bts__nr_defval = template_tr__PCUIF__DATA__IND_bts__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__IND_trx__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__IND_trx__nr_defval = template_tr__PCUIF__DATA__IND_trx__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__IND_ts__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__IND_ts__nr_defval = template_tr__PCUIF__DATA__IND_ts__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__IND_block__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__IND_block__nr_defval = template_tr__PCUIF__DATA__IND_block__nr_defval;
static PCUIF__Sapi_template template_tr__PCUIF__DATA__IND_sapi_defval;
const PCUIF__Sapi_template& tr__PCUIF__DATA__IND_sapi_defval = template_tr__PCUIF__DATA__IND_sapi_defval;
static OCTETSTRING_template template_tr__PCUIF__DATA__IND_data_defval;
const OCTETSTRING_template& tr__PCUIF__DATA__IND_data_defval = template_tr__PCUIF__DATA__IND_data_defval;
static INTEGER_template template_tr__PCUIF__DATA__REQ_block__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__REQ_block__nr_defval = template_tr__PCUIF__DATA__REQ_block__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__REQ_fn_defval;
const INTEGER_template& tr__PCUIF__DATA__REQ_fn_defval = template_tr__PCUIF__DATA__REQ_fn_defval;
static PCUIF__Sapi_template template_tr__PCUIF__DATA__REQ_sapi_defval;
const PCUIF__Sapi_template& tr__PCUIF__DATA__REQ_sapi_defval = template_tr__PCUIF__DATA__REQ_sapi_defval;
static OCTETSTRING_template template_tr__PCUIF__DATA__REQ_data_defval;
const OCTETSTRING_template& tr__PCUIF__DATA__REQ_data_defval = template_tr__PCUIF__DATA__REQ_data_defval;
static INTEGER_template template_tr__PCUIF__DATA__CNF_bts__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__CNF_bts__nr_defval = template_tr__PCUIF__DATA__CNF_bts__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__CNF_trx__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__CNF_trx__nr_defval = template_tr__PCUIF__DATA__CNF_trx__nr_defval;
static INTEGER_template template_tr__PCUIF__DATA__CNF_ts__nr_defval;
const INTEGER_template& tr__PCUIF__DATA__CNF_ts__nr_defval = template_tr__PCUIF__DATA__CNF_ts__nr_defval;
static PCUIF__Sapi_template template_tr__PCUIF__DATA__CNF_sapi_defval;
const PCUIF__Sapi_template& tr__PCUIF__DATA__CNF_sapi_defval = template_tr__PCUIF__DATA__CNF_sapi_defval;
static OCTETSTRING_template template_tr__PCUIF__DATA__CNF_data_defval;
const OCTETSTRING_template& tr__PCUIF__DATA__CNF_data_defval = template_tr__PCUIF__DATA__CNF_data_defval;
static INTEGER_template template_ts__PCUIF__RACH__IND_qta_defval;
const INTEGER_template& ts__PCUIF__RACH__IND_qta_defval = template_ts__PCUIF__RACH__IND_qta_defval;
static INTEGER_template template_tr__PCUIF__RACH__IND_bts__nr_defval;
const INTEGER_template& tr__PCUIF__RACH__IND_bts__nr_defval = template_tr__PCUIF__RACH__IND_bts__nr_defval;
static INTEGER_template template_tr__PCUIF__RACH__IND_ra_defval;
const INTEGER_template& tr__PCUIF__RACH__IND_ra_defval = template_tr__PCUIF__RACH__IND_ra_defval;
static INTEGER_template template_tr__PCUIF__RACH__IND_is__11bit_defval;
const INTEGER_template& tr__PCUIF__RACH__IND_is__11bit_defval = template_tr__PCUIF__RACH__IND_is__11bit_defval;
static PCUIF__BurstType_template template_tr__PCUIF__RACH__IND_burst__type_defval;
const PCUIF__BurstType_template& tr__PCUIF__RACH__IND_burst__type_defval = template_tr__PCUIF__RACH__IND_burst__type_defval;
static INTEGER_template template_tr__PCUIF__RACH__IND_fn_defval;
const INTEGER_template& tr__PCUIF__RACH__IND_fn_defval = template_tr__PCUIF__RACH__IND_fn_defval;
static INTEGER_template template_tr__PCUIF__PAG__REQ_bts__nr_defval;
const INTEGER_template& tr__PCUIF__PAG__REQ_bts__nr_defval = template_tr__PCUIF__PAG__REQ_bts__nr_defval;
static OCTETSTRING_template template_tr__PCUIF__PAG__REQ_id__lv_defval;
const OCTETSTRING_template& tr__PCUIF__PAG__REQ_id__lv_defval = template_tr__PCUIF__PAG__REQ_id__lv_defval;
static INTEGER_template template_tr__PCUIF__PAG__REQ_chan__needed_defval;
const INTEGER_template& tr__PCUIF__PAG__REQ_chan__needed_defval = template_tr__PCUIF__PAG__REQ_chan__needed_defval;
static PCUIF__Sapi_template template_tr__PCUIF__PAG__REQ_sapi_defval;
const PCUIF__Sapi_template& tr__PCUIF__PAG__REQ_sapi_defval = template_tr__PCUIF__PAG__REQ_sapi_defval;
static PCUIF__Flags const_c__PCUIF__Flags__default;
const PCUIF__Flags& c__PCUIF__Flags__default = const_c__PCUIF__Flags__default;
static INTEGER_template template_ts__PCUIF__InfoTrx_arfcn_defval;
const INTEGER_template& ts__PCUIF__InfoTrx_arfcn_defval = template_ts__PCUIF__InfoTrx_arfcn_defval;
static BITSTRING_template template_ts__PCUIF__InfoTrx_pdch__mask_defval;
const BITSTRING_template& ts__PCUIF__InfoTrx_pdch__mask_defval = template_ts__PCUIF__InfoTrx_pdch__mask_defval;
static OCTETSTRING const_ts__PCUIF__InfoTrx_tsc_defval;
const OCTETSTRING& ts__PCUIF__InfoTrx_tsc_defval = const_ts__PCUIF__InfoTrx_tsc_defval;
static PCUIF__InfoTrx_template template_ts__PCUIF__InfoTrxNULL;
const PCUIF__InfoTrx_template& ts__PCUIF__InfoTrxNULL = template_ts__PCUIF__InfoTrxNULL;
static PCUIF__InfoTrxs_template template_ts__PCUIF__InfoTrxs__def;
const PCUIF__InfoTrxs_template& ts__PCUIF__InfoTrxs__def = template_ts__PCUIF__InfoTrxs__def;
static PCUIF__Flags_template template_ts__PCUIF__INFO__IND_flags_defval;
const PCUIF__Flags_template& ts__PCUIF__INFO__IND_flags_defval = template_ts__PCUIF__INFO__IND_flags_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_mcc_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_mcc_defval = template_ts__PCUIF__INFO__IND_mcc_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_mnc_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_mnc_defval = template_ts__PCUIF__INFO__IND_mnc_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_lac_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_lac_defval = template_ts__PCUIF__INFO__IND_lac_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_rac_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_rac_defval = template_ts__PCUIF__INFO__IND_rac_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_cell__id_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_cell__id_defval = template_ts__PCUIF__INFO__IND_cell__id_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_bsic_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_bsic_defval = template_ts__PCUIF__INFO__IND_bsic_defval;
static PCUIF__InfoTrxs_template template_ts__PCUIF__INFO__IND_trx_defval;
const PCUIF__InfoTrxs_template& ts__PCUIF__INFO__IND_trx_defval = template_ts__PCUIF__INFO__IND_trx_defval;
static INTEGER_template template_ts__PCUIF__INFO__IND_version_defval;
const INTEGER_template& ts__PCUIF__INFO__IND_version_defval = template_ts__PCUIF__INFO__IND_version_defval;
static INTEGER_template template_tr__PCUIF__INFO__IND_bts__nr_defval;
const INTEGER_template& tr__PCUIF__INFO__IND_bts__nr_defval = template_tr__PCUIF__INFO__IND_bts__nr_defval;
static PCUIF__Flags_template template_tr__PCUIF__INFO__IND_flags_defval;
const PCUIF__Flags_template& tr__PCUIF__INFO__IND_flags_defval = template_tr__PCUIF__INFO__IND_flags_defval;
static INTEGER_template template_tr__PCUIF__INFO__IND_version_defval;
const INTEGER_template& tr__PCUIF__INFO__IND_version_defval = template_tr__PCUIF__INFO__IND_version_defval;
TTCN_Module module_object("PCUIF_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_5,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

PCUIF__MsgType::PCUIF__MsgType()
{
enum_value = UNBOUND_VALUE;
}

PCUIF__MsgType::PCUIF__MsgType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @PCUIF_Types.PCUIF_MsgType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PCUIF__MsgType::PCUIF__MsgType(enum_type other_value)
{
enum_value = other_value;
}

PCUIF__MsgType::PCUIF__MsgType(const PCUIF__MsgType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
enum_value = other_value.enum_value;
}

PCUIF__MsgType& PCUIF__MsgType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_MsgType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PCUIF__MsgType& PCUIF__MsgType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PCUIF__MsgType& PCUIF__MsgType::operator=(const PCUIF__MsgType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
enum_value = other_value.enum_value;
return *this;
}

boolean PCUIF__MsgType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value == other_value;
}

boolean PCUIF__MsgType::operator==(const PCUIF__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value == other_value.enum_value;
}

boolean PCUIF__MsgType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value < other_value;
}

boolean PCUIF__MsgType::operator<(const PCUIF__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value < other_value.enum_value;
}

boolean PCUIF__MsgType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value > other_value;
}

boolean PCUIF__MsgType::operator>(const PCUIF__MsgType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value > other_value.enum_value;
}

const char *PCUIF__MsgType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case PCU__IF__MSG__DATA__REQ: return "PCU_IF_MSG_DATA_REQ";
case PCU__IF__MSG__DATA__CNF: return "PCU_IF_MSG_DATA_CNF";
case PCU__IF__MSG__DATA__IND: return "PCU_IF_MSG_DATA_IND";
case PCU__IF__MSG__SUSP__REQ: return "PCU_IF_MSG_SUSP_REQ";
case PCU__IF__MSG__RTS__REQ: return "PCU_IF_MSG_RTS_REQ";
case PCU__IF__MSG__DATA__CNF__DT: return "PCU_IF_MSG_DATA_CNF_DT";
case PCU__IF__MSG__RACH__IND: return "PCU_IF_MSG_RACH_IND";
case PCU__IF__MSG__INFO__IND: return "PCU_IF_MSG_INFO_IND";
case PCU__IF__MSG__ACT__REQ: return "PCU_IF_MSG_ACT_REQ";
case PCU__IF__MSG__TIME__IND: return "PCU_IF_MSG_TIME_IND";
case PCU__IF__MSG__PAG__REQ: return "PCU_IF_MSG_PAG_REQ";
case PCU__IF__MSG__TXT__IND: return "PCU_IF_MSG_TXT_IND";
default: return "<unknown>";
}
}

PCUIF__MsgType::enum_type PCUIF__MsgType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "PCU_IF_MSG_DATA_REQ")) return PCU__IF__MSG__DATA__REQ;
else if (!strcmp(str_par, "PCU_IF_MSG_DATA_CNF")) return PCU__IF__MSG__DATA__CNF;
else if (!strcmp(str_par, "PCU_IF_MSG_DATA_IND")) return PCU__IF__MSG__DATA__IND;
else if (!strcmp(str_par, "PCU_IF_MSG_SUSP_REQ")) return PCU__IF__MSG__SUSP__REQ;
else if (!strcmp(str_par, "PCU_IF_MSG_RTS_REQ")) return PCU__IF__MSG__RTS__REQ;
else if (!strcmp(str_par, "PCU_IF_MSG_DATA_CNF_DT")) return PCU__IF__MSG__DATA__CNF__DT;
else if (!strcmp(str_par, "PCU_IF_MSG_RACH_IND")) return PCU__IF__MSG__RACH__IND;
else if (!strcmp(str_par, "PCU_IF_MSG_INFO_IND")) return PCU__IF__MSG__INFO__IND;
else if (!strcmp(str_par, "PCU_IF_MSG_ACT_REQ")) return PCU__IF__MSG__ACT__REQ;
else if (!strcmp(str_par, "PCU_IF_MSG_TIME_IND")) return PCU__IF__MSG__TIME__IND;
else if (!strcmp(str_par, "PCU_IF_MSG_PAG_REQ")) return PCU__IF__MSG__PAG__REQ;
else if (!strcmp(str_par, "PCU_IF_MSG_TXT_IND")) return PCU__IF__MSG__TXT__IND;
else return UNKNOWN_VALUE;
}

boolean PCUIF__MsgType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 16:
case 17:
case 34:
case 50:
case 64:
case 82:
case 96:
case 112:
return TRUE;
default:
return FALSE;
}
}

int PCUIF__MsgType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_MsgType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PCUIF__MsgType::enum2int(const PCUIF__MsgType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_MsgType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PCUIF__MsgType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_MsgType.", int_val);
enum_value = (enum_type)int_val;
}

PCUIF__MsgType::operator PCUIF__MsgType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return enum_value;
}

void PCUIF__MsgType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PCUIF__MsgType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@PCUIF_Types.PCUIF_MsgType");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_MsgType.");
  }
}

void PCUIF__MsgType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
text_buf.push_int(enum_value);
}

void PCUIF__MsgType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @PCUIF_Types.PCUIF_MsgType.", enum_value);
}

void PCUIF__MsgType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__MsgType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__MsgType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 7, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int PCUIF__MsgType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 7);
}

void PCUIF__MsgType_template::copy_template(const PCUIF__MsgType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__MsgType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
}
}

PCUIF__MsgType_template::PCUIF__MsgType_template()
{
}

PCUIF__MsgType_template::PCUIF__MsgType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__MsgType_template::PCUIF__MsgType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PCUIF__MsgType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @PCUIF_Types.PCUIF_MsgType with unknown numeric value %d.", other_value);
single_value = (PCUIF__MsgType::enum_type)other_value;
}

PCUIF__MsgType_template::PCUIF__MsgType_template(PCUIF__MsgType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PCUIF__MsgType_template::PCUIF__MsgType_template(const PCUIF__MsgType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PCUIF__MsgType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType.");
single_value = other_value.enum_value;
}

PCUIF__MsgType_template::PCUIF__MsgType_template(const OPTIONAL<PCUIF__MsgType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__MsgType::enum_type)(const PCUIF__MsgType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @PCUIF_Types.PCUIF_MsgType from an unbound optional field.");
}
}

PCUIF__MsgType_template::PCUIF__MsgType_template(const PCUIF__MsgType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PCUIF__MsgType_template::~PCUIF__MsgType_template()
{
clean_up();
}

boolean PCUIF__MsgType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PCUIF__MsgType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PCUIF__MsgType::UNBOUND_VALUE;
}

void PCUIF__MsgType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(int other_value)
{
if (!PCUIF__MsgType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @PCUIF_Types.PCUIF_MsgType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__MsgType::enum_type)other_value;
return *this;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(PCUIF__MsgType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(const PCUIF__MsgType& other_value)
{
if (other_value.enum_value == PCUIF__MsgType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_MsgType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(const OPTIONAL<PCUIF__MsgType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__MsgType::enum_type)(const PCUIF__MsgType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
}
return *this;
}

PCUIF__MsgType_template& PCUIF__MsgType_template::operator=(const PCUIF__MsgType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__MsgType_template::match(PCUIF__MsgType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
}
return FALSE;
}

boolean PCUIF__MsgType_template::match(const PCUIF__MsgType& other_value, boolean) const
{
if (other_value.enum_value == PCUIF__MsgType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @PCUIF_Types.PCUIF_MsgType with an unbound value.");
return match(other_value.enum_value);
}

PCUIF__MsgType::enum_type PCUIF__MsgType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return single_value;
}

void PCUIF__MsgType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__MsgType_template[list_length];
}

PCUIF__MsgType_template& PCUIF__MsgType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
return value_list.list_value[list_index];
}

void PCUIF__MsgType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PCUIF__MsgType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__MsgType_template::log_match(const PCUIF__MsgType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PCUIF__MsgType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
}
}

void PCUIF__MsgType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PCUIF__MsgType::enum_type)text_buf.pull_int().get_val();
if (!PCUIF__MsgType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @PCUIF_Types.PCUIF_MsgType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__MsgType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @PCUIF_Types.PCUIF_MsgType.");
}
}

boolean PCUIF__MsgType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__MsgType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__MsgType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__MsgType_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PCUIF__MsgType::enum_type enum_val = PCUIF__MsgType::str_to_enum(m_p->get_enumerated());
    if (!PCUIF__MsgType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_MsgType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@PCUIF_Types.PCUIF_MsgType");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__MsgType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_MsgType");
}

PCUIF__Sapi::PCUIF__Sapi()
{
enum_value = UNBOUND_VALUE;
}

PCUIF__Sapi::PCUIF__Sapi(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @PCUIF_Types.PCUIF_Sapi with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PCUIF__Sapi::PCUIF__Sapi(enum_type other_value)
{
enum_value = other_value;
}

PCUIF__Sapi::PCUIF__Sapi(const PCUIF__Sapi& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
enum_value = other_value.enum_value;
}

PCUIF__Sapi& PCUIF__Sapi::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_Sapi.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PCUIF__Sapi& PCUIF__Sapi::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PCUIF__Sapi& PCUIF__Sapi::operator=(const PCUIF__Sapi& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
enum_value = other_value.enum_value;
return *this;
}

boolean PCUIF__Sapi::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value == other_value;
}

boolean PCUIF__Sapi::operator==(const PCUIF__Sapi& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value == other_value.enum_value;
}

boolean PCUIF__Sapi::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value < other_value;
}

boolean PCUIF__Sapi::operator<(const PCUIF__Sapi& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value < other_value.enum_value;
}

boolean PCUIF__Sapi::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value > other_value;
}

boolean PCUIF__Sapi::operator>(const PCUIF__Sapi& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value > other_value.enum_value;
}

const char *PCUIF__Sapi::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case PCU__IF__SAPI__UNKNOWN: return "PCU_IF_SAPI_UNKNOWN";
case PCU__IF__SAPI__RACH: return "PCU_IF_SAPI_RACH";
case PCU__IF__SAPI__AGCH: return "PCU_IF_SAPI_AGCH";
case PCU__IF__SAPI__PCH: return "PCU_IF_SAPI_PCH";
case PCU__IF__SAPI__BCCH: return "PCU_IF_SAPI_BCCH";
case PCU__IF__SAPI__PDTCH: return "PCU_IF_SAPI_PDTCH";
case PCU__IF__SAPI__PRACH: return "PCU_IF_SAPI_PRACH";
case PCU__IF__SAPI__PTCCH: return "PCU_IF_SAPI_PTCCH";
case PCU__IF__SAPI__AGCH__DT: return "PCU_IF_SAPI_AGCH_DT";
default: return "<unknown>";
}
}

PCUIF__Sapi::enum_type PCUIF__Sapi::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "PCU_IF_SAPI_UNKNOWN")) return PCU__IF__SAPI__UNKNOWN;
else if (!strcmp(str_par, "PCU_IF_SAPI_RACH")) return PCU__IF__SAPI__RACH;
else if (!strcmp(str_par, "PCU_IF_SAPI_AGCH")) return PCU__IF__SAPI__AGCH;
else if (!strcmp(str_par, "PCU_IF_SAPI_PCH")) return PCU__IF__SAPI__PCH;
else if (!strcmp(str_par, "PCU_IF_SAPI_BCCH")) return PCU__IF__SAPI__BCCH;
else if (!strcmp(str_par, "PCU_IF_SAPI_PDTCH")) return PCU__IF__SAPI__PDTCH;
else if (!strcmp(str_par, "PCU_IF_SAPI_PRACH")) return PCU__IF__SAPI__PRACH;
else if (!strcmp(str_par, "PCU_IF_SAPI_PTCCH")) return PCU__IF__SAPI__PTCCH;
else if (!strcmp(str_par, "PCU_IF_SAPI_AGCH_DT")) return PCU__IF__SAPI__AGCH__DT;
else return UNKNOWN_VALUE;
}

boolean PCUIF__Sapi::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
return TRUE;
default:
return FALSE;
}
}

int PCUIF__Sapi::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_Sapi.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PCUIF__Sapi::enum2int(const PCUIF__Sapi& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_Sapi.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PCUIF__Sapi::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_Sapi.", int_val);
enum_value = (enum_type)int_val;
}

PCUIF__Sapi::operator PCUIF__Sapi::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return enum_value;
}

void PCUIF__Sapi::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PCUIF__Sapi::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@PCUIF_Types.PCUIF_Sapi");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_Sapi.");
  }
}

void PCUIF__Sapi::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
text_buf.push_int(enum_value);
}

void PCUIF__Sapi::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @PCUIF_Types.PCUIF_Sapi.", enum_value);
}

void PCUIF__Sapi::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__Sapi::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__Sapi::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int PCUIF__Sapi::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

void PCUIF__Sapi_template::copy_template(const PCUIF__Sapi_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__Sapi_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
}
}

PCUIF__Sapi_template::PCUIF__Sapi_template()
{
}

PCUIF__Sapi_template::PCUIF__Sapi_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__Sapi_template::PCUIF__Sapi_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PCUIF__Sapi::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @PCUIF_Types.PCUIF_Sapi with unknown numeric value %d.", other_value);
single_value = (PCUIF__Sapi::enum_type)other_value;
}

PCUIF__Sapi_template::PCUIF__Sapi_template(PCUIF__Sapi::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PCUIF__Sapi_template::PCUIF__Sapi_template(const PCUIF__Sapi& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PCUIF__Sapi::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi.");
single_value = other_value.enum_value;
}

PCUIF__Sapi_template::PCUIF__Sapi_template(const OPTIONAL<PCUIF__Sapi>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__Sapi::enum_type)(const PCUIF__Sapi&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @PCUIF_Types.PCUIF_Sapi from an unbound optional field.");
}
}

PCUIF__Sapi_template::PCUIF__Sapi_template(const PCUIF__Sapi_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PCUIF__Sapi_template::~PCUIF__Sapi_template()
{
clean_up();
}

boolean PCUIF__Sapi_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PCUIF__Sapi_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PCUIF__Sapi::UNBOUND_VALUE;
}

void PCUIF__Sapi_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(int other_value)
{
if (!PCUIF__Sapi::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @PCUIF_Types.PCUIF_Sapi.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__Sapi::enum_type)other_value;
return *this;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(PCUIF__Sapi::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(const PCUIF__Sapi& other_value)
{
if (other_value.enum_value == PCUIF__Sapi::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_Sapi to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(const OPTIONAL<PCUIF__Sapi>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__Sapi::enum_type)(const PCUIF__Sapi&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
}
return *this;
}

PCUIF__Sapi_template& PCUIF__Sapi_template::operator=(const PCUIF__Sapi_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__Sapi_template::match(PCUIF__Sapi::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
}
return FALSE;
}

boolean PCUIF__Sapi_template::match(const PCUIF__Sapi& other_value, boolean) const
{
if (other_value.enum_value == PCUIF__Sapi::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @PCUIF_Types.PCUIF_Sapi with an unbound value.");
return match(other_value.enum_value);
}

PCUIF__Sapi::enum_type PCUIF__Sapi_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return single_value;
}

void PCUIF__Sapi_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__Sapi_template[list_length];
}

PCUIF__Sapi_template& PCUIF__Sapi_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
return value_list.list_value[list_index];
}

void PCUIF__Sapi_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PCUIF__Sapi::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__Sapi_template::log_match(const PCUIF__Sapi& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PCUIF__Sapi_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
}
}

void PCUIF__Sapi_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PCUIF__Sapi::enum_type)text_buf.pull_int().get_val();
if (!PCUIF__Sapi::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @PCUIF_Types.PCUIF_Sapi.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__Sapi_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @PCUIF_Types.PCUIF_Sapi.");
}
}

boolean PCUIF__Sapi_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__Sapi_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__Sapi_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__Sapi_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PCUIF__Sapi::enum_type enum_val = PCUIF__Sapi::str_to_enum(m_p->get_enumerated());
    if (!PCUIF__Sapi::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_Sapi.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@PCUIF_Types.PCUIF_Sapi");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__Sapi_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_Sapi");
}

PCUIF__Flags::PCUIF__Flags()
{
}

PCUIF__Flags::PCUIF__Flags(const BOOLEAN& par_bts__active,
    const BOOLEAN& par_sysmo__direct__dsp,
    const BITSTRING& par_spare,
    const BOOLEAN& par_cs1,
    const BOOLEAN& par_cs2,
    const BOOLEAN& par_cs3,
    const BOOLEAN& par_cs4,
    const BOOLEAN& par_mcs1,
    const BOOLEAN& par_mcs2,
    const BOOLEAN& par_mcs3,
    const BOOLEAN& par_mcs4,
    const BOOLEAN& par_mcs5,
    const BOOLEAN& par_mcs6,
    const BOOLEAN& par_mcs7,
    const BOOLEAN& par_mcs8,
    const BOOLEAN& par_mcs9,
    const BITSTRING& par_spare2)
  :   field_bts__active(par_bts__active),
  field_sysmo__direct__dsp(par_sysmo__direct__dsp),
  field_spare(par_spare),
  field_cs1(par_cs1),
  field_cs2(par_cs2),
  field_cs3(par_cs3),
  field_cs4(par_cs4),
  field_mcs1(par_mcs1),
  field_mcs2(par_mcs2),
  field_mcs3(par_mcs3),
  field_mcs4(par_mcs4),
  field_mcs5(par_mcs5),
  field_mcs6(par_mcs6),
  field_mcs7(par_mcs7),
  field_mcs8(par_mcs8),
  field_mcs9(par_mcs9),
  field_spare2(par_spare2)
{
}

PCUIF__Flags::PCUIF__Flags(const PCUIF__Flags& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_Flags.");
if (other_value.bts__active().is_bound()) field_bts__active = other_value.bts__active();
else field_bts__active.clean_up();
if (other_value.sysmo__direct__dsp().is_bound()) field_sysmo__direct__dsp = other_value.sysmo__direct__dsp();
else field_sysmo__direct__dsp.clean_up();
if (other_value.spare().is_bound()) field_spare = other_value.spare();
else field_spare.clean_up();
if (other_value.cs1().is_bound()) field_cs1 = other_value.cs1();
else field_cs1.clean_up();
if (other_value.cs2().is_bound()) field_cs2 = other_value.cs2();
else field_cs2.clean_up();
if (other_value.cs3().is_bound()) field_cs3 = other_value.cs3();
else field_cs3.clean_up();
if (other_value.cs4().is_bound()) field_cs4 = other_value.cs4();
else field_cs4.clean_up();
if (other_value.mcs1().is_bound()) field_mcs1 = other_value.mcs1();
else field_mcs1.clean_up();
if (other_value.mcs2().is_bound()) field_mcs2 = other_value.mcs2();
else field_mcs2.clean_up();
if (other_value.mcs3().is_bound()) field_mcs3 = other_value.mcs3();
else field_mcs3.clean_up();
if (other_value.mcs4().is_bound()) field_mcs4 = other_value.mcs4();
else field_mcs4.clean_up();
if (other_value.mcs5().is_bound()) field_mcs5 = other_value.mcs5();
else field_mcs5.clean_up();
if (other_value.mcs6().is_bound()) field_mcs6 = other_value.mcs6();
else field_mcs6.clean_up();
if (other_value.mcs7().is_bound()) field_mcs7 = other_value.mcs7();
else field_mcs7.clean_up();
if (other_value.mcs8().is_bound()) field_mcs8 = other_value.mcs8();
else field_mcs8.clean_up();
if (other_value.mcs9().is_bound()) field_mcs9 = other_value.mcs9();
else field_mcs9.clean_up();
if (other_value.spare2().is_bound()) field_spare2 = other_value.spare2();
else field_spare2.clean_up();
}

void PCUIF__Flags::clean_up()
{
field_bts__active.clean_up();
field_sysmo__direct__dsp.clean_up();
field_spare.clean_up();
field_cs1.clean_up();
field_cs2.clean_up();
field_cs3.clean_up();
field_cs4.clean_up();
field_mcs1.clean_up();
field_mcs2.clean_up();
field_mcs3.clean_up();
field_mcs4.clean_up();
field_mcs5.clean_up();
field_mcs6.clean_up();
field_mcs7.clean_up();
field_mcs8.clean_up();
field_mcs9.clean_up();
field_spare2.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__Flags::get_descriptor() const { return &PCUIF__Flags_descr_; }
PCUIF__Flags& PCUIF__Flags::operator=(const PCUIF__Flags& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_Flags.");
  if (other_value.bts__active().is_bound()) field_bts__active = other_value.bts__active();
  else field_bts__active.clean_up();
  if (other_value.sysmo__direct__dsp().is_bound()) field_sysmo__direct__dsp = other_value.sysmo__direct__dsp();
  else field_sysmo__direct__dsp.clean_up();
  if (other_value.spare().is_bound()) field_spare = other_value.spare();
  else field_spare.clean_up();
  if (other_value.cs1().is_bound()) field_cs1 = other_value.cs1();
  else field_cs1.clean_up();
  if (other_value.cs2().is_bound()) field_cs2 = other_value.cs2();
  else field_cs2.clean_up();
  if (other_value.cs3().is_bound()) field_cs3 = other_value.cs3();
  else field_cs3.clean_up();
  if (other_value.cs4().is_bound()) field_cs4 = other_value.cs4();
  else field_cs4.clean_up();
  if (other_value.mcs1().is_bound()) field_mcs1 = other_value.mcs1();
  else field_mcs1.clean_up();
  if (other_value.mcs2().is_bound()) field_mcs2 = other_value.mcs2();
  else field_mcs2.clean_up();
  if (other_value.mcs3().is_bound()) field_mcs3 = other_value.mcs3();
  else field_mcs3.clean_up();
  if (other_value.mcs4().is_bound()) field_mcs4 = other_value.mcs4();
  else field_mcs4.clean_up();
  if (other_value.mcs5().is_bound()) field_mcs5 = other_value.mcs5();
  else field_mcs5.clean_up();
  if (other_value.mcs6().is_bound()) field_mcs6 = other_value.mcs6();
  else field_mcs6.clean_up();
  if (other_value.mcs7().is_bound()) field_mcs7 = other_value.mcs7();
  else field_mcs7.clean_up();
  if (other_value.mcs8().is_bound()) field_mcs8 = other_value.mcs8();
  else field_mcs8.clean_up();
  if (other_value.mcs9().is_bound()) field_mcs9 = other_value.mcs9();
  else field_mcs9.clean_up();
  if (other_value.spare2().is_bound()) field_spare2 = other_value.spare2();
  else field_spare2.clean_up();
}
return *this;
}

boolean PCUIF__Flags::operator==(const PCUIF__Flags& other_value) const
{
return field_bts__active==other_value.field_bts__active
  && field_sysmo__direct__dsp==other_value.field_sysmo__direct__dsp
  && field_spare==other_value.field_spare
  && field_cs1==other_value.field_cs1
  && field_cs2==other_value.field_cs2
  && field_cs3==other_value.field_cs3
  && field_cs4==other_value.field_cs4
  && field_mcs1==other_value.field_mcs1
  && field_mcs2==other_value.field_mcs2
  && field_mcs3==other_value.field_mcs3
  && field_mcs4==other_value.field_mcs4
  && field_mcs5==other_value.field_mcs5
  && field_mcs6==other_value.field_mcs6
  && field_mcs7==other_value.field_mcs7
  && field_mcs8==other_value.field_mcs8
  && field_mcs9==other_value.field_mcs9
  && field_spare2==other_value.field_spare2;
}

boolean PCUIF__Flags::is_bound() const
{
if(field_bts__active.is_bound()) return TRUE;
if(field_sysmo__direct__dsp.is_bound()) return TRUE;
if(field_spare.is_bound()) return TRUE;
if(field_cs1.is_bound()) return TRUE;
if(field_cs2.is_bound()) return TRUE;
if(field_cs3.is_bound()) return TRUE;
if(field_cs4.is_bound()) return TRUE;
if(field_mcs1.is_bound()) return TRUE;
if(field_mcs2.is_bound()) return TRUE;
if(field_mcs3.is_bound()) return TRUE;
if(field_mcs4.is_bound()) return TRUE;
if(field_mcs5.is_bound()) return TRUE;
if(field_mcs6.is_bound()) return TRUE;
if(field_mcs7.is_bound()) return TRUE;
if(field_mcs8.is_bound()) return TRUE;
if(field_mcs9.is_bound()) return TRUE;
if(field_spare2.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__Flags::is_value() const
{
if(!field_bts__active.is_value()) return FALSE;
if(!field_sysmo__direct__dsp.is_value()) return FALSE;
if(!field_spare.is_value()) return FALSE;
if(!field_cs1.is_value()) return FALSE;
if(!field_cs2.is_value()) return FALSE;
if(!field_cs3.is_value()) return FALSE;
if(!field_cs4.is_value()) return FALSE;
if(!field_mcs1.is_value()) return FALSE;
if(!field_mcs2.is_value()) return FALSE;
if(!field_mcs3.is_value()) return FALSE;
if(!field_mcs4.is_value()) return FALSE;
if(!field_mcs5.is_value()) return FALSE;
if(!field_mcs6.is_value()) return FALSE;
if(!field_mcs7.is_value()) return FALSE;
if(!field_mcs8.is_value()) return FALSE;
if(!field_mcs9.is_value()) return FALSE;
if(!field_spare2.is_value()) return FALSE;
return TRUE;
}
void PCUIF__Flags::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ bts_active := ");
field_bts__active.log();
TTCN_Logger::log_event_str(", sysmo_direct_dsp := ");
field_sysmo__direct__dsp.log();
TTCN_Logger::log_event_str(", spare := ");
field_spare.log();
TTCN_Logger::log_event_str(", cs1 := ");
field_cs1.log();
TTCN_Logger::log_event_str(", cs2 := ");
field_cs2.log();
TTCN_Logger::log_event_str(", cs3 := ");
field_cs3.log();
TTCN_Logger::log_event_str(", cs4 := ");
field_cs4.log();
TTCN_Logger::log_event_str(", mcs1 := ");
field_mcs1.log();
TTCN_Logger::log_event_str(", mcs2 := ");
field_mcs2.log();
TTCN_Logger::log_event_str(", mcs3 := ");
field_mcs3.log();
TTCN_Logger::log_event_str(", mcs4 := ");
field_mcs4.log();
TTCN_Logger::log_event_str(", mcs5 := ");
field_mcs5.log();
TTCN_Logger::log_event_str(", mcs6 := ");
field_mcs6.log();
TTCN_Logger::log_event_str(", mcs7 := ");
field_mcs7.log();
TTCN_Logger::log_event_str(", mcs8 := ");
field_mcs8.log();
TTCN_Logger::log_event_str(", mcs9 := ");
field_mcs9.log();
TTCN_Logger::log_event_str(", spare2 := ");
field_spare2.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__Flags::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (17<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_Flags has 17 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bts__active().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sysmo__direct__dsp().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) cs1().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) cs2().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) cs3().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) cs4().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) mcs1().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) mcs2().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) mcs3().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) mcs4().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) mcs5().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) mcs6().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) mcs7().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) mcs8().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) mcs9().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) spare2().set_param(*param.get_elem(16));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bts_active")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bts__active().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sysmo_direct_dsp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sysmo__direct__dsp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs3")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs3().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs4")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs4().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs3")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs3().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs4")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs4().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs5")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs5().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs6")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs6().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs7")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs7().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs8")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs8().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs9")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs9().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_Flags: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_Flags");
  }
}

void PCUIF__Flags::set_implicit_omit()
{
if (bts__active().is_bound()) bts__active().set_implicit_omit();
if (sysmo__direct__dsp().is_bound()) sysmo__direct__dsp().set_implicit_omit();
if (spare().is_bound()) spare().set_implicit_omit();
if (cs1().is_bound()) cs1().set_implicit_omit();
if (cs2().is_bound()) cs2().set_implicit_omit();
if (cs3().is_bound()) cs3().set_implicit_omit();
if (cs4().is_bound()) cs4().set_implicit_omit();
if (mcs1().is_bound()) mcs1().set_implicit_omit();
if (mcs2().is_bound()) mcs2().set_implicit_omit();
if (mcs3().is_bound()) mcs3().set_implicit_omit();
if (mcs4().is_bound()) mcs4().set_implicit_omit();
if (mcs5().is_bound()) mcs5().set_implicit_omit();
if (mcs6().is_bound()) mcs6().set_implicit_omit();
if (mcs7().is_bound()) mcs7().set_implicit_omit();
if (mcs8().is_bound()) mcs8().set_implicit_omit();
if (mcs9().is_bound()) mcs9().set_implicit_omit();
if (spare2().is_bound()) spare2().set_implicit_omit();
}

void PCUIF__Flags::encode_text(Text_Buf& text_buf) const
{
field_bts__active.encode_text(text_buf);
field_sysmo__direct__dsp.encode_text(text_buf);
field_spare.encode_text(text_buf);
field_cs1.encode_text(text_buf);
field_cs2.encode_text(text_buf);
field_cs3.encode_text(text_buf);
field_cs4.encode_text(text_buf);
field_mcs1.encode_text(text_buf);
field_mcs2.encode_text(text_buf);
field_mcs3.encode_text(text_buf);
field_mcs4.encode_text(text_buf);
field_mcs5.encode_text(text_buf);
field_mcs6.encode_text(text_buf);
field_mcs7.encode_text(text_buf);
field_mcs8.encode_text(text_buf);
field_mcs9.encode_text(text_buf);
field_spare2.encode_text(text_buf);
}

void PCUIF__Flags::decode_text(Text_Buf& text_buf)
{
field_bts__active.decode_text(text_buf);
field_sysmo__direct__dsp.decode_text(text_buf);
field_spare.decode_text(text_buf);
field_cs1.decode_text(text_buf);
field_cs2.decode_text(text_buf);
field_cs3.decode_text(text_buf);
field_cs4.decode_text(text_buf);
field_mcs1.decode_text(text_buf);
field_mcs2.decode_text(text_buf);
field_mcs3.decode_text(text_buf);
field_mcs4.decode_text(text_buf);
field_mcs5.decode_text(text_buf);
field_mcs6.decode_text(text_buf);
field_mcs7.decode_text(text_buf);
field_mcs8.decode_text(text_buf);
field_mcs9.decode_text(text_buf);
field_spare2.decode_text(text_buf);
}

void PCUIF__Flags::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__Flags::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__Flags::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__Flags_bts__active_descr_.raw->forceomit);
  decoded_field_length = field_bts__active.RAW_decode(PCUIF__Flags_bts__active_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__Flags_sysmo__direct__dsp_descr_.raw->forceomit);
  decoded_field_length = field_sysmo__direct__dsp.RAW_decode(PCUIF__Flags_sysmo__direct__dsp_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__Flags_spare_descr_.raw->forceomit);
  decoded_field_length = field_spare.RAW_decode(PCUIF__Flags_spare_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__Flags_cs1_descr_.raw->forceomit);
  decoded_field_length = field_cs1.RAW_decode(PCUIF__Flags_cs1_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__Flags_cs2_descr_.raw->forceomit);
  decoded_field_length = field_cs2.RAW_decode(PCUIF__Flags_cs2_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__Flags_cs3_descr_.raw->forceomit);
  decoded_field_length = field_cs3.RAW_decode(PCUIF__Flags_cs3_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__Flags_cs4_descr_.raw->forceomit);
  decoded_field_length = field_cs4.RAW_decode(PCUIF__Flags_cs4_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_7_force_omit(7, force_omit, PCUIF__Flags_mcs1_descr_.raw->forceomit);
  decoded_field_length = field_mcs1.RAW_decode(PCUIF__Flags_mcs1_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_8_force_omit(8, force_omit, PCUIF__Flags_mcs2_descr_.raw->forceomit);
  decoded_field_length = field_mcs2.RAW_decode(PCUIF__Flags_mcs2_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_9_force_omit(9, force_omit, PCUIF__Flags_mcs3_descr_.raw->forceomit);
  decoded_field_length = field_mcs3.RAW_decode(PCUIF__Flags_mcs3_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_10_force_omit(10, force_omit, PCUIF__Flags_mcs4_descr_.raw->forceomit);
  decoded_field_length = field_mcs4.RAW_decode(PCUIF__Flags_mcs4_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_10_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_11_force_omit(11, force_omit, PCUIF__Flags_mcs5_descr_.raw->forceomit);
  decoded_field_length = field_mcs5.RAW_decode(PCUIF__Flags_mcs5_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_11_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_12_force_omit(12, force_omit, PCUIF__Flags_mcs6_descr_.raw->forceomit);
  decoded_field_length = field_mcs6.RAW_decode(PCUIF__Flags_mcs6_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_12_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_13_force_omit(13, force_omit, PCUIF__Flags_mcs7_descr_.raw->forceomit);
  decoded_field_length = field_mcs7.RAW_decode(PCUIF__Flags_mcs7_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_13_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_14_force_omit(14, force_omit, PCUIF__Flags_mcs8_descr_.raw->forceomit);
  decoded_field_length = field_mcs8.RAW_decode(PCUIF__Flags_mcs8_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_14_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_15_force_omit(15, force_omit, PCUIF__Flags_mcs9_descr_.raw->forceomit);
  decoded_field_length = field_mcs9.RAW_decode(PCUIF__Flags_mcs9_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_15_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_16_force_omit(16, force_omit, PCUIF__Flags_spare2_descr_.raw->forceomit);
  decoded_field_length = field_spare2.RAW_decode(PCUIF__Flags_spare2_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_16_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__Flags::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 17;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(17);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__Flags_bts__active_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__Flags_sysmo__direct__dsp_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__Flags_spare_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__Flags_cs1_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__Flags_cs2_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__Flags_cs3_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__Flags_cs4_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, PCUIF__Flags_mcs1_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, PCUIF__Flags_mcs2_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, PCUIF__Flags_mcs3_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 10, PCUIF__Flags_mcs4_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 11, PCUIF__Flags_mcs5_descr_.raw);
  myleaf.body.node.nodes[12] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 12, PCUIF__Flags_mcs6_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 13, PCUIF__Flags_mcs7_descr_.raw);
  myleaf.body.node.nodes[14] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 14, PCUIF__Flags_mcs8_descr_.raw);
  myleaf.body.node.nodes[15] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 15, PCUIF__Flags_mcs9_descr_.raw);
  myleaf.body.node.nodes[16] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 16, PCUIF__Flags_spare2_descr_.raw);
  encoded_length += field_bts__active.RAW_encode(PCUIF__Flags_bts__active_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_sysmo__direct__dsp.RAW_encode(PCUIF__Flags_sysmo__direct__dsp_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_spare.RAW_encode(PCUIF__Flags_spare_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_cs1.RAW_encode(PCUIF__Flags_cs1_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_cs2.RAW_encode(PCUIF__Flags_cs2_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_cs3.RAW_encode(PCUIF__Flags_cs3_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_cs4.RAW_encode(PCUIF__Flags_cs4_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_mcs1.RAW_encode(PCUIF__Flags_mcs1_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_mcs2.RAW_encode(PCUIF__Flags_mcs2_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_mcs3.RAW_encode(PCUIF__Flags_mcs3_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_mcs4.RAW_encode(PCUIF__Flags_mcs4_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_mcs5.RAW_encode(PCUIF__Flags_mcs5_descr_, *myleaf.body.node.nodes[11]);
  encoded_length += field_mcs6.RAW_encode(PCUIF__Flags_mcs6_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_mcs7.RAW_encode(PCUIF__Flags_mcs7_descr_, *myleaf.body.node.nodes[13]);
  encoded_length += field_mcs8.RAW_encode(PCUIF__Flags_mcs8_descr_, *myleaf.body.node.nodes[14]);
  encoded_length += field_mcs9.RAW_encode(PCUIF__Flags_mcs9_descr_, *myleaf.body.node.nodes[15]);
  encoded_length += field_spare2.RAW_encode(PCUIF__Flags_spare2_descr_, *myleaf.body.node.nodes[16]);
  return myleaf.length = encoded_length;
}

struct PCUIF__Flags_template::single_value_struct {
BOOLEAN_template field_bts__active;
BOOLEAN_template field_sysmo__direct__dsp;
BITSTRING_template field_spare;
BOOLEAN_template field_cs1;
BOOLEAN_template field_cs2;
BOOLEAN_template field_cs3;
BOOLEAN_template field_cs4;
BOOLEAN_template field_mcs1;
BOOLEAN_template field_mcs2;
BOOLEAN_template field_mcs3;
BOOLEAN_template field_mcs4;
BOOLEAN_template field_mcs5;
BOOLEAN_template field_mcs6;
BOOLEAN_template field_mcs7;
BOOLEAN_template field_mcs8;
BOOLEAN_template field_mcs9;
BITSTRING_template field_spare2;
};

void PCUIF__Flags_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_bts__active = ANY_VALUE;
single_value->field_sysmo__direct__dsp = ANY_VALUE;
single_value->field_spare = ANY_VALUE;
single_value->field_cs1 = ANY_VALUE;
single_value->field_cs2 = ANY_VALUE;
single_value->field_cs3 = ANY_VALUE;
single_value->field_cs4 = ANY_VALUE;
single_value->field_mcs1 = ANY_VALUE;
single_value->field_mcs2 = ANY_VALUE;
single_value->field_mcs3 = ANY_VALUE;
single_value->field_mcs4 = ANY_VALUE;
single_value->field_mcs5 = ANY_VALUE;
single_value->field_mcs6 = ANY_VALUE;
single_value->field_mcs7 = ANY_VALUE;
single_value->field_mcs8 = ANY_VALUE;
single_value->field_mcs9 = ANY_VALUE;
single_value->field_spare2 = ANY_VALUE;
}
}
}

void PCUIF__Flags_template::copy_value(const PCUIF__Flags& other_value)
{
single_value = new single_value_struct;
if (other_value.bts__active().is_bound()) {
  single_value->field_bts__active = other_value.bts__active();
} else {
  single_value->field_bts__active.clean_up();
}
if (other_value.sysmo__direct__dsp().is_bound()) {
  single_value->field_sysmo__direct__dsp = other_value.sysmo__direct__dsp();
} else {
  single_value->field_sysmo__direct__dsp.clean_up();
}
if (other_value.spare().is_bound()) {
  single_value->field_spare = other_value.spare();
} else {
  single_value->field_spare.clean_up();
}
if (other_value.cs1().is_bound()) {
  single_value->field_cs1 = other_value.cs1();
} else {
  single_value->field_cs1.clean_up();
}
if (other_value.cs2().is_bound()) {
  single_value->field_cs2 = other_value.cs2();
} else {
  single_value->field_cs2.clean_up();
}
if (other_value.cs3().is_bound()) {
  single_value->field_cs3 = other_value.cs3();
} else {
  single_value->field_cs3.clean_up();
}
if (other_value.cs4().is_bound()) {
  single_value->field_cs4 = other_value.cs4();
} else {
  single_value->field_cs4.clean_up();
}
if (other_value.mcs1().is_bound()) {
  single_value->field_mcs1 = other_value.mcs1();
} else {
  single_value->field_mcs1.clean_up();
}
if (other_value.mcs2().is_bound()) {
  single_value->field_mcs2 = other_value.mcs2();
} else {
  single_value->field_mcs2.clean_up();
}
if (other_value.mcs3().is_bound()) {
  single_value->field_mcs3 = other_value.mcs3();
} else {
  single_value->field_mcs3.clean_up();
}
if (other_value.mcs4().is_bound()) {
  single_value->field_mcs4 = other_value.mcs4();
} else {
  single_value->field_mcs4.clean_up();
}
if (other_value.mcs5().is_bound()) {
  single_value->field_mcs5 = other_value.mcs5();
} else {
  single_value->field_mcs5.clean_up();
}
if (other_value.mcs6().is_bound()) {
  single_value->field_mcs6 = other_value.mcs6();
} else {
  single_value->field_mcs6.clean_up();
}
if (other_value.mcs7().is_bound()) {
  single_value->field_mcs7 = other_value.mcs7();
} else {
  single_value->field_mcs7.clean_up();
}
if (other_value.mcs8().is_bound()) {
  single_value->field_mcs8 = other_value.mcs8();
} else {
  single_value->field_mcs8.clean_up();
}
if (other_value.mcs9().is_bound()) {
  single_value->field_mcs9 = other_value.mcs9();
} else {
  single_value->field_mcs9.clean_up();
}
if (other_value.spare2().is_bound()) {
  single_value->field_spare2 = other_value.spare2();
} else {
  single_value->field_spare2.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__Flags_template::copy_template(const PCUIF__Flags_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.bts__active().get_selection()) {
single_value->field_bts__active = other_value.bts__active();
} else {
single_value->field_bts__active.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sysmo__direct__dsp().get_selection()) {
single_value->field_sysmo__direct__dsp = other_value.sysmo__direct__dsp();
} else {
single_value->field_sysmo__direct__dsp.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare().get_selection()) {
single_value->field_spare = other_value.spare();
} else {
single_value->field_spare.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cs1().get_selection()) {
single_value->field_cs1 = other_value.cs1();
} else {
single_value->field_cs1.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cs2().get_selection()) {
single_value->field_cs2 = other_value.cs2();
} else {
single_value->field_cs2.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cs3().get_selection()) {
single_value->field_cs3 = other_value.cs3();
} else {
single_value->field_cs3.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cs4().get_selection()) {
single_value->field_cs4 = other_value.cs4();
} else {
single_value->field_cs4.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs1().get_selection()) {
single_value->field_mcs1 = other_value.mcs1();
} else {
single_value->field_mcs1.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs2().get_selection()) {
single_value->field_mcs2 = other_value.mcs2();
} else {
single_value->field_mcs2.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs3().get_selection()) {
single_value->field_mcs3 = other_value.mcs3();
} else {
single_value->field_mcs3.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs4().get_selection()) {
single_value->field_mcs4 = other_value.mcs4();
} else {
single_value->field_mcs4.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs5().get_selection()) {
single_value->field_mcs5 = other_value.mcs5();
} else {
single_value->field_mcs5.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs6().get_selection()) {
single_value->field_mcs6 = other_value.mcs6();
} else {
single_value->field_mcs6.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs7().get_selection()) {
single_value->field_mcs7 = other_value.mcs7();
} else {
single_value->field_mcs7.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs8().get_selection()) {
single_value->field_mcs8 = other_value.mcs8();
} else {
single_value->field_mcs8.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcs9().get_selection()) {
single_value->field_mcs9 = other_value.mcs9();
} else {
single_value->field_mcs9.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare2().get_selection()) {
single_value->field_spare2 = other_value.spare2();
} else {
single_value->field_spare2.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__Flags_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Flags.");
break;
}
set_selection(other_value);
}

PCUIF__Flags_template::PCUIF__Flags_template()
{
}

PCUIF__Flags_template::PCUIF__Flags_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__Flags_template::PCUIF__Flags_template(const PCUIF__Flags& other_value)
{
copy_value(other_value);
}

PCUIF__Flags_template::PCUIF__Flags_template(const OPTIONAL<PCUIF__Flags>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__Flags&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_Flags from an unbound optional field.");
}
}

PCUIF__Flags_template::PCUIF__Flags_template(const PCUIF__Flags_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__Flags_template::~PCUIF__Flags_template()
{
clean_up();
}

PCUIF__Flags_template& PCUIF__Flags_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__Flags_template& PCUIF__Flags_template::operator=(const PCUIF__Flags& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__Flags_template& PCUIF__Flags_template::operator=(const OPTIONAL<PCUIF__Flags>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__Flags&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_Flags.");
}
return *this;
}

PCUIF__Flags_template& PCUIF__Flags_template::operator=(const PCUIF__Flags_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__Flags_template::match(const PCUIF__Flags& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.bts__active().is_bound()) return FALSE;
if(!single_value->field_bts__active.match(other_value.bts__active(), legacy))return FALSE;
if(!other_value.sysmo__direct__dsp().is_bound()) return FALSE;
if(!single_value->field_sysmo__direct__dsp.match(other_value.sysmo__direct__dsp(), legacy))return FALSE;
if(!other_value.spare().is_bound()) return FALSE;
if(!single_value->field_spare.match(other_value.spare(), legacy))return FALSE;
if(!other_value.cs1().is_bound()) return FALSE;
if(!single_value->field_cs1.match(other_value.cs1(), legacy))return FALSE;
if(!other_value.cs2().is_bound()) return FALSE;
if(!single_value->field_cs2.match(other_value.cs2(), legacy))return FALSE;
if(!other_value.cs3().is_bound()) return FALSE;
if(!single_value->field_cs3.match(other_value.cs3(), legacy))return FALSE;
if(!other_value.cs4().is_bound()) return FALSE;
if(!single_value->field_cs4.match(other_value.cs4(), legacy))return FALSE;
if(!other_value.mcs1().is_bound()) return FALSE;
if(!single_value->field_mcs1.match(other_value.mcs1(), legacy))return FALSE;
if(!other_value.mcs2().is_bound()) return FALSE;
if(!single_value->field_mcs2.match(other_value.mcs2(), legacy))return FALSE;
if(!other_value.mcs3().is_bound()) return FALSE;
if(!single_value->field_mcs3.match(other_value.mcs3(), legacy))return FALSE;
if(!other_value.mcs4().is_bound()) return FALSE;
if(!single_value->field_mcs4.match(other_value.mcs4(), legacy))return FALSE;
if(!other_value.mcs5().is_bound()) return FALSE;
if(!single_value->field_mcs5.match(other_value.mcs5(), legacy))return FALSE;
if(!other_value.mcs6().is_bound()) return FALSE;
if(!single_value->field_mcs6.match(other_value.mcs6(), legacy))return FALSE;
if(!other_value.mcs7().is_bound()) return FALSE;
if(!single_value->field_mcs7.match(other_value.mcs7(), legacy))return FALSE;
if(!other_value.mcs8().is_bound()) return FALSE;
if(!single_value->field_mcs8.match(other_value.mcs8(), legacy))return FALSE;
if(!other_value.mcs9().is_bound()) return FALSE;
if(!single_value->field_mcs9.match(other_value.mcs9(), legacy))return FALSE;
if(!other_value.spare2().is_bound()) return FALSE;
if(!single_value->field_spare2.match(other_value.spare2(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Flags.");
}
return FALSE;
}

boolean PCUIF__Flags_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_bts__active.is_bound()) return TRUE;
if (single_value->field_sysmo__direct__dsp.is_bound()) return TRUE;
if (single_value->field_spare.is_bound()) return TRUE;
if (single_value->field_cs1.is_bound()) return TRUE;
if (single_value->field_cs2.is_bound()) return TRUE;
if (single_value->field_cs3.is_bound()) return TRUE;
if (single_value->field_cs4.is_bound()) return TRUE;
if (single_value->field_mcs1.is_bound()) return TRUE;
if (single_value->field_mcs2.is_bound()) return TRUE;
if (single_value->field_mcs3.is_bound()) return TRUE;
if (single_value->field_mcs4.is_bound()) return TRUE;
if (single_value->field_mcs5.is_bound()) return TRUE;
if (single_value->field_mcs6.is_bound()) return TRUE;
if (single_value->field_mcs7.is_bound()) return TRUE;
if (single_value->field_mcs8.is_bound()) return TRUE;
if (single_value->field_mcs9.is_bound()) return TRUE;
if (single_value->field_spare2.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__Flags_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_bts__active.is_value()) return FALSE;
if (!single_value->field_sysmo__direct__dsp.is_value()) return FALSE;
if (!single_value->field_spare.is_value()) return FALSE;
if (!single_value->field_cs1.is_value()) return FALSE;
if (!single_value->field_cs2.is_value()) return FALSE;
if (!single_value->field_cs3.is_value()) return FALSE;
if (!single_value->field_cs4.is_value()) return FALSE;
if (!single_value->field_mcs1.is_value()) return FALSE;
if (!single_value->field_mcs2.is_value()) return FALSE;
if (!single_value->field_mcs3.is_value()) return FALSE;
if (!single_value->field_mcs4.is_value()) return FALSE;
if (!single_value->field_mcs5.is_value()) return FALSE;
if (!single_value->field_mcs6.is_value()) return FALSE;
if (!single_value->field_mcs7.is_value()) return FALSE;
if (!single_value->field_mcs8.is_value()) return FALSE;
if (!single_value->field_mcs9.is_value()) return FALSE;
if (!single_value->field_spare2.is_value()) return FALSE;
return TRUE;
}

void PCUIF__Flags_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__Flags PCUIF__Flags_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
PCUIF__Flags ret_val;
if (single_value->field_bts__active.is_bound()) {
ret_val.bts__active() = single_value->field_bts__active.valueof();
}
if (single_value->field_sysmo__direct__dsp.is_bound()) {
ret_val.sysmo__direct__dsp() = single_value->field_sysmo__direct__dsp.valueof();
}
if (single_value->field_spare.is_bound()) {
ret_val.spare() = single_value->field_spare.valueof();
}
if (single_value->field_cs1.is_bound()) {
ret_val.cs1() = single_value->field_cs1.valueof();
}
if (single_value->field_cs2.is_bound()) {
ret_val.cs2() = single_value->field_cs2.valueof();
}
if (single_value->field_cs3.is_bound()) {
ret_val.cs3() = single_value->field_cs3.valueof();
}
if (single_value->field_cs4.is_bound()) {
ret_val.cs4() = single_value->field_cs4.valueof();
}
if (single_value->field_mcs1.is_bound()) {
ret_val.mcs1() = single_value->field_mcs1.valueof();
}
if (single_value->field_mcs2.is_bound()) {
ret_val.mcs2() = single_value->field_mcs2.valueof();
}
if (single_value->field_mcs3.is_bound()) {
ret_val.mcs3() = single_value->field_mcs3.valueof();
}
if (single_value->field_mcs4.is_bound()) {
ret_val.mcs4() = single_value->field_mcs4.valueof();
}
if (single_value->field_mcs5.is_bound()) {
ret_val.mcs5() = single_value->field_mcs5.valueof();
}
if (single_value->field_mcs6.is_bound()) {
ret_val.mcs6() = single_value->field_mcs6.valueof();
}
if (single_value->field_mcs7.is_bound()) {
ret_val.mcs7() = single_value->field_mcs7.valueof();
}
if (single_value->field_mcs8.is_bound()) {
ret_val.mcs8() = single_value->field_mcs8.valueof();
}
if (single_value->field_mcs9.is_bound()) {
ret_val.mcs9() = single_value->field_mcs9.valueof();
}
if (single_value->field_spare2.is_bound()) {
ret_val.spare2() = single_value->field_spare2.valueof();
}
return ret_val;
}

void PCUIF__Flags_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_Flags.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__Flags_template[list_length];
}

PCUIF__Flags_template& PCUIF__Flags_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_Flags.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_Flags.");
return value_list.list_value[list_index];
}

BOOLEAN_template& PCUIF__Flags_template::bts__active()
{
set_specific();
return single_value->field_bts__active;
}

const BOOLEAN_template& PCUIF__Flags_template::bts__active() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bts_active of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_bts__active;
}

BOOLEAN_template& PCUIF__Flags_template::sysmo__direct__dsp()
{
set_specific();
return single_value->field_sysmo__direct__dsp;
}

const BOOLEAN_template& PCUIF__Flags_template::sysmo__direct__dsp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sysmo_direct_dsp of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_sysmo__direct__dsp;
}

BITSTRING_template& PCUIF__Flags_template::spare()
{
set_specific();
return single_value->field_spare;
}

const BITSTRING_template& PCUIF__Flags_template::spare() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_spare;
}

BOOLEAN_template& PCUIF__Flags_template::cs1()
{
set_specific();
return single_value->field_cs1;
}

const BOOLEAN_template& PCUIF__Flags_template::cs1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cs1 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_cs1;
}

BOOLEAN_template& PCUIF__Flags_template::cs2()
{
set_specific();
return single_value->field_cs2;
}

const BOOLEAN_template& PCUIF__Flags_template::cs2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cs2 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_cs2;
}

BOOLEAN_template& PCUIF__Flags_template::cs3()
{
set_specific();
return single_value->field_cs3;
}

const BOOLEAN_template& PCUIF__Flags_template::cs3() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cs3 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_cs3;
}

BOOLEAN_template& PCUIF__Flags_template::cs4()
{
set_specific();
return single_value->field_cs4;
}

const BOOLEAN_template& PCUIF__Flags_template::cs4() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cs4 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_cs4;
}

BOOLEAN_template& PCUIF__Flags_template::mcs1()
{
set_specific();
return single_value->field_mcs1;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs1 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs1;
}

BOOLEAN_template& PCUIF__Flags_template::mcs2()
{
set_specific();
return single_value->field_mcs2;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs2 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs2;
}

BOOLEAN_template& PCUIF__Flags_template::mcs3()
{
set_specific();
return single_value->field_mcs3;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs3() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs3 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs3;
}

BOOLEAN_template& PCUIF__Flags_template::mcs4()
{
set_specific();
return single_value->field_mcs4;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs4() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs4 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs4;
}

BOOLEAN_template& PCUIF__Flags_template::mcs5()
{
set_specific();
return single_value->field_mcs5;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs5() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs5 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs5;
}

BOOLEAN_template& PCUIF__Flags_template::mcs6()
{
set_specific();
return single_value->field_mcs6;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs6() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs6 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs6;
}

BOOLEAN_template& PCUIF__Flags_template::mcs7()
{
set_specific();
return single_value->field_mcs7;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs7() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs7 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs7;
}

BOOLEAN_template& PCUIF__Flags_template::mcs8()
{
set_specific();
return single_value->field_mcs8;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs8() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs8 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs8;
}

BOOLEAN_template& PCUIF__Flags_template::mcs9()
{
set_specific();
return single_value->field_mcs9;
}

const BOOLEAN_template& PCUIF__Flags_template::mcs9() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcs9 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_mcs9;
}

BITSTRING_template& PCUIF__Flags_template::spare2()
{
set_specific();
return single_value->field_spare2;
}

const BITSTRING_template& PCUIF__Flags_template::spare2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare2 of a non-specific template of type @PCUIF_Types.PCUIF_Flags.");
return single_value->field_spare2;
}

int PCUIF__Flags_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 17;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Flags containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Flags.");
  }
  return 0;
}

void PCUIF__Flags_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ bts_active := ");
single_value->field_bts__active.log();
TTCN_Logger::log_event_str(", sysmo_direct_dsp := ");
single_value->field_sysmo__direct__dsp.log();
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log();
TTCN_Logger::log_event_str(", cs1 := ");
single_value->field_cs1.log();
TTCN_Logger::log_event_str(", cs2 := ");
single_value->field_cs2.log();
TTCN_Logger::log_event_str(", cs3 := ");
single_value->field_cs3.log();
TTCN_Logger::log_event_str(", cs4 := ");
single_value->field_cs4.log();
TTCN_Logger::log_event_str(", mcs1 := ");
single_value->field_mcs1.log();
TTCN_Logger::log_event_str(", mcs2 := ");
single_value->field_mcs2.log();
TTCN_Logger::log_event_str(", mcs3 := ");
single_value->field_mcs3.log();
TTCN_Logger::log_event_str(", mcs4 := ");
single_value->field_mcs4.log();
TTCN_Logger::log_event_str(", mcs5 := ");
single_value->field_mcs5.log();
TTCN_Logger::log_event_str(", mcs6 := ");
single_value->field_mcs6.log();
TTCN_Logger::log_event_str(", mcs7 := ");
single_value->field_mcs7.log();
TTCN_Logger::log_event_str(", mcs8 := ");
single_value->field_mcs8.log();
TTCN_Logger::log_event_str(", mcs9 := ");
single_value->field_mcs9.log();
TTCN_Logger::log_event_str(", spare2 := ");
single_value->field_spare2.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__Flags_template::log_match(const PCUIF__Flags& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_bts__active.match(match_value.bts__active(), legacy)){
TTCN_Logger::log_logmatch_info(".bts_active");
single_value->field_bts__active.log_match(match_value.bts__active(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sysmo__direct__dsp.match(match_value.sysmo__direct__dsp(), legacy)){
TTCN_Logger::log_logmatch_info(".sysmo_direct_dsp");
single_value->field_sysmo__direct__dsp.log_match(match_value.sysmo__direct__dsp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare.match(match_value.spare(), legacy)){
TTCN_Logger::log_logmatch_info(".spare");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cs1.match(match_value.cs1(), legacy)){
TTCN_Logger::log_logmatch_info(".cs1");
single_value->field_cs1.log_match(match_value.cs1(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cs2.match(match_value.cs2(), legacy)){
TTCN_Logger::log_logmatch_info(".cs2");
single_value->field_cs2.log_match(match_value.cs2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cs3.match(match_value.cs3(), legacy)){
TTCN_Logger::log_logmatch_info(".cs3");
single_value->field_cs3.log_match(match_value.cs3(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cs4.match(match_value.cs4(), legacy)){
TTCN_Logger::log_logmatch_info(".cs4");
single_value->field_cs4.log_match(match_value.cs4(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs1.match(match_value.mcs1(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs1");
single_value->field_mcs1.log_match(match_value.mcs1(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs2.match(match_value.mcs2(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs2");
single_value->field_mcs2.log_match(match_value.mcs2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs3.match(match_value.mcs3(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs3");
single_value->field_mcs3.log_match(match_value.mcs3(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs4.match(match_value.mcs4(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs4");
single_value->field_mcs4.log_match(match_value.mcs4(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs5.match(match_value.mcs5(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs5");
single_value->field_mcs5.log_match(match_value.mcs5(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs6.match(match_value.mcs6(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs6");
single_value->field_mcs6.log_match(match_value.mcs6(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs7.match(match_value.mcs7(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs7");
single_value->field_mcs7.log_match(match_value.mcs7(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs8.match(match_value.mcs8(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs8");
single_value->field_mcs8.log_match(match_value.mcs8(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcs9.match(match_value.mcs9(), legacy)){
TTCN_Logger::log_logmatch_info(".mcs9");
single_value->field_mcs9.log_match(match_value.mcs9(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare2.match(match_value.spare2(), legacy)){
TTCN_Logger::log_logmatch_info(".spare2");
single_value->field_spare2.log_match(match_value.spare2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ bts_active := ");
single_value->field_bts__active.log_match(match_value.bts__active(), legacy);
TTCN_Logger::log_event_str(", sysmo_direct_dsp := ");
single_value->field_sysmo__direct__dsp.log_match(match_value.sysmo__direct__dsp(), legacy);
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::log_event_str(", cs1 := ");
single_value->field_cs1.log_match(match_value.cs1(), legacy);
TTCN_Logger::log_event_str(", cs2 := ");
single_value->field_cs2.log_match(match_value.cs2(), legacy);
TTCN_Logger::log_event_str(", cs3 := ");
single_value->field_cs3.log_match(match_value.cs3(), legacy);
TTCN_Logger::log_event_str(", cs4 := ");
single_value->field_cs4.log_match(match_value.cs4(), legacy);
TTCN_Logger::log_event_str(", mcs1 := ");
single_value->field_mcs1.log_match(match_value.mcs1(), legacy);
TTCN_Logger::log_event_str(", mcs2 := ");
single_value->field_mcs2.log_match(match_value.mcs2(), legacy);
TTCN_Logger::log_event_str(", mcs3 := ");
single_value->field_mcs3.log_match(match_value.mcs3(), legacy);
TTCN_Logger::log_event_str(", mcs4 := ");
single_value->field_mcs4.log_match(match_value.mcs4(), legacy);
TTCN_Logger::log_event_str(", mcs5 := ");
single_value->field_mcs5.log_match(match_value.mcs5(), legacy);
TTCN_Logger::log_event_str(", mcs6 := ");
single_value->field_mcs6.log_match(match_value.mcs6(), legacy);
TTCN_Logger::log_event_str(", mcs7 := ");
single_value->field_mcs7.log_match(match_value.mcs7(), legacy);
TTCN_Logger::log_event_str(", mcs8 := ");
single_value->field_mcs8.log_match(match_value.mcs8(), legacy);
TTCN_Logger::log_event_str(", mcs9 := ");
single_value->field_mcs9.log_match(match_value.mcs9(), legacy);
TTCN_Logger::log_event_str(", spare2 := ");
single_value->field_spare2.log_match(match_value.spare2(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__Flags_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_bts__active.encode_text(text_buf);
single_value->field_sysmo__direct__dsp.encode_text(text_buf);
single_value->field_spare.encode_text(text_buf);
single_value->field_cs1.encode_text(text_buf);
single_value->field_cs2.encode_text(text_buf);
single_value->field_cs3.encode_text(text_buf);
single_value->field_cs4.encode_text(text_buf);
single_value->field_mcs1.encode_text(text_buf);
single_value->field_mcs2.encode_text(text_buf);
single_value->field_mcs3.encode_text(text_buf);
single_value->field_mcs4.encode_text(text_buf);
single_value->field_mcs5.encode_text(text_buf);
single_value->field_mcs6.encode_text(text_buf);
single_value->field_mcs7.encode_text(text_buf);
single_value->field_mcs8.encode_text(text_buf);
single_value->field_mcs9.encode_text(text_buf);
single_value->field_spare2.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Flags.");
}
}

void PCUIF__Flags_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_bts__active.decode_text(text_buf);
single_value->field_sysmo__direct__dsp.decode_text(text_buf);
single_value->field_spare.decode_text(text_buf);
single_value->field_cs1.decode_text(text_buf);
single_value->field_cs2.decode_text(text_buf);
single_value->field_cs3.decode_text(text_buf);
single_value->field_cs4.decode_text(text_buf);
single_value->field_mcs1.decode_text(text_buf);
single_value->field_mcs2.decode_text(text_buf);
single_value->field_mcs3.decode_text(text_buf);
single_value->field_mcs4.decode_text(text_buf);
single_value->field_mcs5.decode_text(text_buf);
single_value->field_mcs6.decode_text(text_buf);
single_value->field_mcs7.decode_text(text_buf);
single_value->field_mcs8.decode_text(text_buf);
single_value->field_mcs9.decode_text(text_buf);
single_value->field_spare2.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__Flags_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_Flags.");
}
}

void PCUIF__Flags_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__Flags_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (17<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_Flags has 17 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bts__active().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sysmo__direct__dsp().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) cs1().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) cs2().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) cs3().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) cs4().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) mcs1().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) mcs2().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) mcs3().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) mcs4().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) mcs5().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) mcs6().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) mcs7().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) mcs8().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) mcs9().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) spare2().set_param(*param.get_elem(16));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bts_active")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bts__active().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sysmo_direct_dsp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sysmo__direct__dsp().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs3")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs3().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cs4")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cs4().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs3")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs3().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs4")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs4().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs5")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs5().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs6")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs6().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs7")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs7().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs8")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs8().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcs9")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcs9().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare2().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_Flags: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_Flags");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__Flags_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_bts__active.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_sysmo__direct__dsp.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_spare.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_cs1.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_cs2.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_cs3.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_cs4.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs1.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs2.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs3.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs4.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs5.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs6.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs7.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs8.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_mcs9.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
single_value->field_spare2.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_Flags");
}

boolean PCUIF__Flags_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__Flags_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__TextType::PCUIF__TextType()
{
enum_value = UNBOUND_VALUE;
}

PCUIF__TextType::PCUIF__TextType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @PCUIF_Types.PCUIF_TextType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PCUIF__TextType::PCUIF__TextType(enum_type other_value)
{
enum_value = other_value;
}

PCUIF__TextType::PCUIF__TextType(const PCUIF__TextType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
enum_value = other_value.enum_value;
}

PCUIF__TextType& PCUIF__TextType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_TextType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PCUIF__TextType& PCUIF__TextType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PCUIF__TextType& PCUIF__TextType::operator=(const PCUIF__TextType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
enum_value = other_value.enum_value;
return *this;
}

boolean PCUIF__TextType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value == other_value;
}

boolean PCUIF__TextType::operator==(const PCUIF__TextType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value == other_value.enum_value;
}

boolean PCUIF__TextType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value < other_value;
}

boolean PCUIF__TextType::operator<(const PCUIF__TextType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value < other_value.enum_value;
}

boolean PCUIF__TextType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value > other_value;
}

boolean PCUIF__TextType::operator>(const PCUIF__TextType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value > other_value.enum_value;
}

const char *PCUIF__TextType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case PCU__VERSION: return "PCU_VERSION";
case PCU__OML__ALERT: return "PCU_OML_ALERT";
default: return "<unknown>";
}
}

PCUIF__TextType::enum_type PCUIF__TextType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "PCU_VERSION")) return PCU__VERSION;
else if (!strcmp(str_par, "PCU_OML_ALERT")) return PCU__OML__ALERT;
else return UNKNOWN_VALUE;
}

boolean PCUIF__TextType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int PCUIF__TextType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_TextType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PCUIF__TextType::enum2int(const PCUIF__TextType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_TextType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PCUIF__TextType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_TextType.", int_val);
enum_value = (enum_type)int_val;
}

PCUIF__TextType::operator PCUIF__TextType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @PCUIF_Types.PCUIF_TextType.");
return enum_value;
}

void PCUIF__TextType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PCUIF__TextType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@PCUIF_Types.PCUIF_TextType");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_TextType.");
  }
}

void PCUIF__TextType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
text_buf.push_int(enum_value);
}

void PCUIF__TextType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @PCUIF_Types.PCUIF_TextType.", enum_value);
}

void PCUIF__TextType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__TextType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__TextType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int PCUIF__TextType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

void PCUIF__TextType_template::copy_template(const PCUIF__TextType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__TextType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_TextType.");
}
}

PCUIF__TextType_template::PCUIF__TextType_template()
{
}

PCUIF__TextType_template::PCUIF__TextType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__TextType_template::PCUIF__TextType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PCUIF__TextType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @PCUIF_Types.PCUIF_TextType with unknown numeric value %d.", other_value);
single_value = (PCUIF__TextType::enum_type)other_value;
}

PCUIF__TextType_template::PCUIF__TextType_template(PCUIF__TextType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PCUIF__TextType_template::PCUIF__TextType_template(const PCUIF__TextType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PCUIF__TextType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType.");
single_value = other_value.enum_value;
}

PCUIF__TextType_template::PCUIF__TextType_template(const OPTIONAL<PCUIF__TextType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__TextType::enum_type)(const PCUIF__TextType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @PCUIF_Types.PCUIF_TextType from an unbound optional field.");
}
}

PCUIF__TextType_template::PCUIF__TextType_template(const PCUIF__TextType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PCUIF__TextType_template::~PCUIF__TextType_template()
{
clean_up();
}

boolean PCUIF__TextType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PCUIF__TextType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PCUIF__TextType::UNBOUND_VALUE;
}

void PCUIF__TextType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(int other_value)
{
if (!PCUIF__TextType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @PCUIF_Types.PCUIF_TextType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__TextType::enum_type)other_value;
return *this;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(PCUIF__TextType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(const PCUIF__TextType& other_value)
{
if (other_value.enum_value == PCUIF__TextType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_TextType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(const OPTIONAL<PCUIF__TextType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__TextType::enum_type)(const PCUIF__TextType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @PCUIF_Types.PCUIF_TextType.");
}
return *this;
}

PCUIF__TextType_template& PCUIF__TextType_template::operator=(const PCUIF__TextType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__TextType_template::match(PCUIF__TextType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_TextType.");
}
return FALSE;
}

boolean PCUIF__TextType_template::match(const PCUIF__TextType& other_value, boolean) const
{
if (other_value.enum_value == PCUIF__TextType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @PCUIF_Types.PCUIF_TextType with an unbound value.");
return match(other_value.enum_value);
}

PCUIF__TextType::enum_type PCUIF__TextType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @PCUIF_Types.PCUIF_TextType.");
return single_value;
}

void PCUIF__TextType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @PCUIF_Types.PCUIF_TextType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__TextType_template[list_length];
}

PCUIF__TextType_template& PCUIF__TextType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @PCUIF_Types.PCUIF_TextType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @PCUIF_Types.PCUIF_TextType.");
return value_list.list_value[list_index];
}

void PCUIF__TextType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PCUIF__TextType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__TextType_template::log_match(const PCUIF__TextType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PCUIF__TextType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_TextType.");
}
}

void PCUIF__TextType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PCUIF__TextType::enum_type)text_buf.pull_int().get_val();
if (!PCUIF__TextType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @PCUIF_Types.PCUIF_TextType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__TextType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @PCUIF_Types.PCUIF_TextType.");
}
}

boolean PCUIF__TextType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__TextType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__TextType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__TextType_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PCUIF__TextType::enum_type enum_val = PCUIF__TextType::str_to_enum(m_p->get_enumerated());
    if (!PCUIF__TextType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_TextType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@PCUIF_Types.PCUIF_TextType");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__TextType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_TextType");
}

PCUIF__txt__ind::PCUIF__txt__ind()
{
}

PCUIF__txt__ind::PCUIF__txt__ind(const PCUIF__TextType& par_txt__type,
    const CHARSTRING& par_text)
  :   field_txt__type(par_txt__type),
  field_text(par_text)
{
}

PCUIF__txt__ind::PCUIF__txt__ind(const PCUIF__txt__ind& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_txt_ind.");
if (other_value.txt__type().is_bound()) field_txt__type = other_value.txt__type();
else field_txt__type.clean_up();
if (other_value.text().is_bound()) field_text = other_value.text();
else field_text.clean_up();
}

void PCUIF__txt__ind::clean_up()
{
field_txt__type.clean_up();
field_text.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__txt__ind::get_descriptor() const { return &PCUIF__txt__ind_descr_; }
PCUIF__txt__ind& PCUIF__txt__ind::operator=(const PCUIF__txt__ind& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_txt_ind.");
  if (other_value.txt__type().is_bound()) field_txt__type = other_value.txt__type();
  else field_txt__type.clean_up();
  if (other_value.text().is_bound()) field_text = other_value.text();
  else field_text.clean_up();
}
return *this;
}

boolean PCUIF__txt__ind::operator==(const PCUIF__txt__ind& other_value) const
{
return field_txt__type==other_value.field_txt__type
  && field_text==other_value.field_text;
}

boolean PCUIF__txt__ind::is_bound() const
{
if(field_txt__type.is_bound()) return TRUE;
if(field_text.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__txt__ind::is_value() const
{
if(!field_txt__type.is_value()) return FALSE;
if(!field_text.is_value()) return FALSE;
return TRUE;
}
void PCUIF__txt__ind::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ txt_type := ");
field_txt__type.log();
TTCN_Logger::log_event_str(", text := ");
field_text.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__txt__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_txt_ind has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) txt__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) text().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "txt_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          txt__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_txt_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_txt_ind");
  }
}

void PCUIF__txt__ind::set_implicit_omit()
{
if (txt__type().is_bound()) txt__type().set_implicit_omit();
if (text().is_bound()) text().set_implicit_omit();
}

void PCUIF__txt__ind::encode_text(Text_Buf& text_buf) const
{
field_txt__type.encode_text(text_buf);
field_text.encode_text(text_buf);
}

void PCUIF__txt__ind::decode_text(Text_Buf& text_buf)
{
field_txt__type.decode_text(text_buf);
field_text.decode_text(text_buf);
}

void PCUIF__txt__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__txt__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__txt__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__txt__ind_txt__type_descr_.raw->forceomit);
  decoded_field_length = field_txt__type.RAW_decode(PCUIF__txt__ind_txt__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__txt__ind_text_descr_.raw->forceomit);
  decoded_field_length = field_text.RAW_decode(PCUIF__txt__ind_text_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__txt__ind::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__txt__ind_txt__type_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__txt__ind_text_descr_.raw);
  encoded_length += field_txt__type.RAW_encode(PCUIF__txt__ind_txt__type_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_text.RAW_encode(PCUIF__txt__ind_text_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

struct PCUIF__txt__ind_template::single_value_struct {
PCUIF__TextType_template field_txt__type;
CHARSTRING_template field_text;
};

void PCUIF__txt__ind_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_txt__type = ANY_VALUE;
single_value->field_text = ANY_VALUE;
}
}
}

void PCUIF__txt__ind_template::copy_value(const PCUIF__txt__ind& other_value)
{
single_value = new single_value_struct;
if (other_value.txt__type().is_bound()) {
  single_value->field_txt__type = other_value.txt__type();
} else {
  single_value->field_txt__type.clean_up();
}
if (other_value.text().is_bound()) {
  single_value->field_text = other_value.text();
} else {
  single_value->field_text.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__txt__ind_template::copy_template(const PCUIF__txt__ind_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.txt__type().get_selection()) {
single_value->field_txt__type = other_value.txt__type();
} else {
single_value->field_txt__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.text().get_selection()) {
single_value->field_text = other_value.text();
} else {
single_value->field_text.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__txt__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_txt_ind.");
break;
}
set_selection(other_value);
}

PCUIF__txt__ind_template::PCUIF__txt__ind_template()
{
}

PCUIF__txt__ind_template::PCUIF__txt__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__txt__ind_template::PCUIF__txt__ind_template(const PCUIF__txt__ind& other_value)
{
copy_value(other_value);
}

PCUIF__txt__ind_template::PCUIF__txt__ind_template(const OPTIONAL<PCUIF__txt__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__txt__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_txt_ind from an unbound optional field.");
}
}

PCUIF__txt__ind_template::PCUIF__txt__ind_template(const PCUIF__txt__ind_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__txt__ind_template::~PCUIF__txt__ind_template()
{
clean_up();
}

PCUIF__txt__ind_template& PCUIF__txt__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__txt__ind_template& PCUIF__txt__ind_template::operator=(const PCUIF__txt__ind& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__txt__ind_template& PCUIF__txt__ind_template::operator=(const OPTIONAL<PCUIF__txt__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__txt__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_txt_ind.");
}
return *this;
}

PCUIF__txt__ind_template& PCUIF__txt__ind_template::operator=(const PCUIF__txt__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__txt__ind_template::match(const PCUIF__txt__ind& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.txt__type().is_bound()) return FALSE;
if(!single_value->field_txt__type.match(other_value.txt__type(), legacy))return FALSE;
if(!other_value.text().is_bound()) return FALSE;
if(!single_value->field_text.match(other_value.text(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_txt_ind.");
}
return FALSE;
}

boolean PCUIF__txt__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_txt__type.is_bound()) return TRUE;
if (single_value->field_text.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__txt__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_txt__type.is_value()) return FALSE;
if (!single_value->field_text.is_value()) return FALSE;
return TRUE;
}

void PCUIF__txt__ind_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__txt__ind PCUIF__txt__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_txt_ind.");
PCUIF__txt__ind ret_val;
if (single_value->field_txt__type.is_bound()) {
ret_val.txt__type() = single_value->field_txt__type.valueof();
}
if (single_value->field_text.is_bound()) {
ret_val.text() = single_value->field_text.valueof();
}
return ret_val;
}

void PCUIF__txt__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_txt_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__txt__ind_template[list_length];
}

PCUIF__txt__ind_template& PCUIF__txt__ind_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_txt_ind.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_txt_ind.");
return value_list.list_value[list_index];
}

PCUIF__TextType_template& PCUIF__txt__ind_template::txt__type()
{
set_specific();
return single_value->field_txt__type;
}

const PCUIF__TextType_template& PCUIF__txt__ind_template::txt__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field txt_type of a non-specific template of type @PCUIF_Types.PCUIF_txt_ind.");
return single_value->field_txt__type;
}

CHARSTRING_template& PCUIF__txt__ind_template::text()
{
set_specific();
return single_value->field_text;
}

const CHARSTRING_template& PCUIF__txt__ind_template::text() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field text of a non-specific template of type @PCUIF_Types.PCUIF_txt_ind.");
return single_value->field_text;
}

int PCUIF__txt__ind_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_txt_ind containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_txt_ind.");
  }
  return 0;
}

void PCUIF__txt__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ txt_type := ");
single_value->field_txt__type.log();
TTCN_Logger::log_event_str(", text := ");
single_value->field_text.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__txt__ind_template::log_match(const PCUIF__txt__ind& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_txt__type.match(match_value.txt__type(), legacy)){
TTCN_Logger::log_logmatch_info(".txt_type");
single_value->field_txt__type.log_match(match_value.txt__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_text.match(match_value.text(), legacy)){
TTCN_Logger::log_logmatch_info(".text");
single_value->field_text.log_match(match_value.text(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ txt_type := ");
single_value->field_txt__type.log_match(match_value.txt__type(), legacy);
TTCN_Logger::log_event_str(", text := ");
single_value->field_text.log_match(match_value.text(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__txt__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_txt__type.encode_text(text_buf);
single_value->field_text.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_txt_ind.");
}
}

void PCUIF__txt__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_txt__type.decode_text(text_buf);
single_value->field_text.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__txt__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_txt_ind.");
}
}

void PCUIF__txt__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__txt__ind_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_txt_ind has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) txt__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) text().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "txt_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          txt__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_txt_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_txt_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__txt__ind_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_txt__type.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_txt_ind");
single_value->field_text.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_txt_ind");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_txt_ind");
}

boolean PCUIF__txt__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__txt__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__data::PCUIF__data()
{
}

PCUIF__data::PCUIF__data(const PCUIF__Sapi& par_sapi,
    const INTEGER& par_len,
    const OCTETSTRING& par_data,
    const INTEGER& par_fn,
    const INTEGER& par_arfcn,
    const INTEGER& par_trx__nr,
    const INTEGER& par_ts__nr,
    const INTEGER& par_block__nr,
    const INTEGER& par_rssi,
    const INTEGER& par_ber10k,
    const INTEGER& par_ta__offs__qbits,
    const INTEGER& par_lqual__cb)
  :   field_sapi(par_sapi),
  field_len(par_len),
  field_data(par_data),
  field_fn(par_fn),
  field_arfcn(par_arfcn),
  field_trx__nr(par_trx__nr),
  field_ts__nr(par_ts__nr),
  field_block__nr(par_block__nr),
  field_rssi(par_rssi),
  field_ber10k(par_ber10k),
  field_ta__offs__qbits(par_ta__offs__qbits),
  field_lqual__cb(par_lqual__cb)
{
}

PCUIF__data::PCUIF__data(const PCUIF__data& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_data.");
if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
else field_sapi.clean_up();
if (other_value.len().is_bound()) field_len = other_value.len();
else field_len.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
if (other_value.fn().is_bound()) field_fn = other_value.fn();
else field_fn.clean_up();
if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
else field_arfcn.clean_up();
if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
else field_trx__nr.clean_up();
if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
else field_ts__nr.clean_up();
if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
else field_block__nr.clean_up();
if (other_value.rssi().is_bound()) field_rssi = other_value.rssi();
else field_rssi.clean_up();
if (other_value.ber10k().is_bound()) field_ber10k = other_value.ber10k();
else field_ber10k.clean_up();
if (other_value.ta__offs__qbits().is_bound()) field_ta__offs__qbits = other_value.ta__offs__qbits();
else field_ta__offs__qbits.clean_up();
if (other_value.lqual__cb().is_bound()) field_lqual__cb = other_value.lqual__cb();
else field_lqual__cb.clean_up();
}

void PCUIF__data::clean_up()
{
field_sapi.clean_up();
field_len.clean_up();
field_data.clean_up();
field_fn.clean_up();
field_arfcn.clean_up();
field_trx__nr.clean_up();
field_ts__nr.clean_up();
field_block__nr.clean_up();
field_rssi.clean_up();
field_ber10k.clean_up();
field_ta__offs__qbits.clean_up();
field_lqual__cb.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__data::get_descriptor() const { return &PCUIF__data_descr_; }
PCUIF__data& PCUIF__data::operator=(const PCUIF__data& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_data.");
  if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
  else field_sapi.clean_up();
  if (other_value.len().is_bound()) field_len = other_value.len();
  else field_len.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
  if (other_value.fn().is_bound()) field_fn = other_value.fn();
  else field_fn.clean_up();
  if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
  else field_arfcn.clean_up();
  if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
  else field_trx__nr.clean_up();
  if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
  else field_ts__nr.clean_up();
  if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
  else field_block__nr.clean_up();
  if (other_value.rssi().is_bound()) field_rssi = other_value.rssi();
  else field_rssi.clean_up();
  if (other_value.ber10k().is_bound()) field_ber10k = other_value.ber10k();
  else field_ber10k.clean_up();
  if (other_value.ta__offs__qbits().is_bound()) field_ta__offs__qbits = other_value.ta__offs__qbits();
  else field_ta__offs__qbits.clean_up();
  if (other_value.lqual__cb().is_bound()) field_lqual__cb = other_value.lqual__cb();
  else field_lqual__cb.clean_up();
}
return *this;
}

boolean PCUIF__data::operator==(const PCUIF__data& other_value) const
{
return field_sapi==other_value.field_sapi
  && field_len==other_value.field_len
  && field_data==other_value.field_data
  && field_fn==other_value.field_fn
  && field_arfcn==other_value.field_arfcn
  && field_trx__nr==other_value.field_trx__nr
  && field_ts__nr==other_value.field_ts__nr
  && field_block__nr==other_value.field_block__nr
  && field_rssi==other_value.field_rssi
  && field_ber10k==other_value.field_ber10k
  && field_ta__offs__qbits==other_value.field_ta__offs__qbits
  && field_lqual__cb==other_value.field_lqual__cb;
}

boolean PCUIF__data::is_bound() const
{
if(field_sapi.is_bound()) return TRUE;
if(field_len.is_bound()) return TRUE;
if(field_data.is_bound()) return TRUE;
if(field_fn.is_bound()) return TRUE;
if(field_arfcn.is_bound()) return TRUE;
if(field_trx__nr.is_bound()) return TRUE;
if(field_ts__nr.is_bound()) return TRUE;
if(field_block__nr.is_bound()) return TRUE;
if(field_rssi.is_bound()) return TRUE;
if(field_ber10k.is_bound()) return TRUE;
if(field_ta__offs__qbits.is_bound()) return TRUE;
if(field_lqual__cb.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__data::is_value() const
{
if(!field_sapi.is_value()) return FALSE;
if(!field_len.is_value()) return FALSE;
if(!field_data.is_value()) return FALSE;
if(!field_fn.is_value()) return FALSE;
if(!field_arfcn.is_value()) return FALSE;
if(!field_trx__nr.is_value()) return FALSE;
if(!field_ts__nr.is_value()) return FALSE;
if(!field_block__nr.is_value()) return FALSE;
if(!field_rssi.is_value()) return FALSE;
if(!field_ber10k.is_value()) return FALSE;
if(!field_ta__offs__qbits.is_value()) return FALSE;
if(!field_lqual__cb.is_value()) return FALSE;
return TRUE;
}
void PCUIF__data::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sapi := ");
field_sapi.log();
TTCN_Logger::log_event_str(", len := ");
field_len.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(", fn := ");
field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
field_block__nr.log();
TTCN_Logger::log_event_str(", rssi := ");
field_rssi.log();
TTCN_Logger::log_event_str(", ber10k := ");
field_ber10k.log();
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
field_ta__offs__qbits.log();
TTCN_Logger::log_event_str(", lqual_cb := ");
field_lqual__cb.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__data::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (12<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_data has 12 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) len().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) rssi().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ber10k().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) ta__offs__qbits().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) lqual__cb().set_param(*param.get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          len().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rssi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rssi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ber10k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ber10k().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ta_offs_qbits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ta__offs__qbits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lqual_cb")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lqual__cb().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_data");
  }
}

void PCUIF__data::set_implicit_omit()
{
if (sapi().is_bound()) sapi().set_implicit_omit();
if (len().is_bound()) len().set_implicit_omit();
if (data().is_bound()) data().set_implicit_omit();
if (fn().is_bound()) fn().set_implicit_omit();
if (arfcn().is_bound()) arfcn().set_implicit_omit();
if (trx__nr().is_bound()) trx__nr().set_implicit_omit();
if (ts__nr().is_bound()) ts__nr().set_implicit_omit();
if (block__nr().is_bound()) block__nr().set_implicit_omit();
if (rssi().is_bound()) rssi().set_implicit_omit();
if (ber10k().is_bound()) ber10k().set_implicit_omit();
if (ta__offs__qbits().is_bound()) ta__offs__qbits().set_implicit_omit();
if (lqual__cb().is_bound()) lqual__cb().set_implicit_omit();
}

void PCUIF__data::encode_text(Text_Buf& text_buf) const
{
field_sapi.encode_text(text_buf);
field_len.encode_text(text_buf);
field_data.encode_text(text_buf);
field_fn.encode_text(text_buf);
field_arfcn.encode_text(text_buf);
field_trx__nr.encode_text(text_buf);
field_ts__nr.encode_text(text_buf);
field_block__nr.encode_text(text_buf);
field_rssi.encode_text(text_buf);
field_ber10k.encode_text(text_buf);
field_ta__offs__qbits.encode_text(text_buf);
field_lqual__cb.encode_text(text_buf);
}

void PCUIF__data::decode_text(Text_Buf& text_buf)
{
field_sapi.decode_text(text_buf);
field_len.decode_text(text_buf);
field_data.decode_text(text_buf);
field_fn.decode_text(text_buf);
field_arfcn.decode_text(text_buf);
field_trx__nr.decode_text(text_buf);
field_ts__nr.decode_text(text_buf);
field_block__nr.decode_text(text_buf);
field_rssi.decode_text(text_buf);
field_ber10k.decode_text(text_buf);
field_ta__offs__qbits.decode_text(text_buf);
field_lqual__cb.decode_text(text_buf);
}

void PCUIF__data::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__data::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__data::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__data_sapi_descr_.raw->forceomit);
  decoded_field_length = field_sapi.RAW_decode(PCUIF__data_sapi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__data_len_descr_.raw->forceomit);
  decoded_field_length = field_len.RAW_decode(PCUIF__data_len_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__data_data_descr_.raw->forceomit);
  decoded_field_length = field_data.RAW_decode(PCUIF__data_data_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__data_fn_descr_.raw->forceomit);
  decoded_field_length = field_fn.RAW_decode(PCUIF__data_fn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__data_arfcn_descr_.raw->forceomit);
  decoded_field_length = field_arfcn.RAW_decode(PCUIF__data_arfcn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__data_trx__nr_descr_.raw->forceomit);
  decoded_field_length = field_trx__nr.RAW_decode(PCUIF__data_trx__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__data_ts__nr_descr_.raw->forceomit);
  decoded_field_length = field_ts__nr.RAW_decode(PCUIF__data_ts__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_7_force_omit(7, force_omit, PCUIF__data_block__nr_descr_.raw->forceomit);
  decoded_field_length = field_block__nr.RAW_decode(PCUIF__data_block__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_8_force_omit(8, force_omit, PCUIF__data_rssi_descr_.raw->forceomit);
  decoded_field_length = field_rssi.RAW_decode(PCUIF__data_rssi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_9_force_omit(9, force_omit, PCUIF__data_ber10k_descr_.raw->forceomit);
  decoded_field_length = field_ber10k.RAW_decode(PCUIF__data_ber10k_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_10_force_omit(10, force_omit, PCUIF__data_ta__offs__qbits_descr_.raw->forceomit);
  decoded_field_length = field_ta__offs__qbits.RAW_decode(PCUIF__data_ta__offs__qbits_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_10_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_11_force_omit(11, force_omit, PCUIF__data_lqual__cb_descr_.raw->forceomit);
  decoded_field_length = field_lqual__cb.RAW_decode(PCUIF__data_lqual__cb_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_11_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__data::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 12;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(12);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__data_sapi_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__data_len_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__data_data_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__data_fn_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__data_arfcn_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__data_trx__nr_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__data_ts__nr_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, PCUIF__data_block__nr_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, PCUIF__data_rssi_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, PCUIF__data_ber10k_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 10, PCUIF__data_ta__offs__qbits_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 11, PCUIF__data_lqual__cb_descr_.raw);
  encoded_length += field_sapi.RAW_encode(PCUIF__data_sapi_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_len.RAW_encode(PCUIF__data_len_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_data.RAW_encode(PCUIF__data_data_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_fn.RAW_encode(PCUIF__data_fn_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_arfcn.RAW_encode(PCUIF__data_arfcn_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_trx__nr.RAW_encode(PCUIF__data_trx__nr_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_ts__nr.RAW_encode(PCUIF__data_ts__nr_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_block__nr.RAW_encode(PCUIF__data_block__nr_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_rssi.RAW_encode(PCUIF__data_rssi_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_ber10k.RAW_encode(PCUIF__data_ber10k_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_ta__offs__qbits.RAW_encode(PCUIF__data_ta__offs__qbits_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_lqual__cb.RAW_encode(PCUIF__data_lqual__cb_descr_, *myleaf.body.node.nodes[11]);
  return myleaf.length = encoded_length;
}

struct PCUIF__data_template::single_value_struct {
PCUIF__Sapi_template field_sapi;
INTEGER_template field_len;
OCTETSTRING_template field_data;
INTEGER_template field_fn;
INTEGER_template field_arfcn;
INTEGER_template field_trx__nr;
INTEGER_template field_ts__nr;
INTEGER_template field_block__nr;
INTEGER_template field_rssi;
INTEGER_template field_ber10k;
INTEGER_template field_ta__offs__qbits;
INTEGER_template field_lqual__cb;
};

void PCUIF__data_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sapi = ANY_VALUE;
single_value->field_len = ANY_VALUE;
single_value->field_data = ANY_VALUE;
single_value->field_fn = ANY_VALUE;
single_value->field_arfcn = ANY_VALUE;
single_value->field_trx__nr = ANY_VALUE;
single_value->field_ts__nr = ANY_VALUE;
single_value->field_block__nr = ANY_VALUE;
single_value->field_rssi = ANY_VALUE;
single_value->field_ber10k = ANY_VALUE;
single_value->field_ta__offs__qbits = ANY_VALUE;
single_value->field_lqual__cb = ANY_VALUE;
}
}
}

void PCUIF__data_template::copy_value(const PCUIF__data& other_value)
{
single_value = new single_value_struct;
if (other_value.sapi().is_bound()) {
  single_value->field_sapi = other_value.sapi();
} else {
  single_value->field_sapi.clean_up();
}
if (other_value.len().is_bound()) {
  single_value->field_len = other_value.len();
} else {
  single_value->field_len.clean_up();
}
if (other_value.data().is_bound()) {
  single_value->field_data = other_value.data();
} else {
  single_value->field_data.clean_up();
}
if (other_value.fn().is_bound()) {
  single_value->field_fn = other_value.fn();
} else {
  single_value->field_fn.clean_up();
}
if (other_value.arfcn().is_bound()) {
  single_value->field_arfcn = other_value.arfcn();
} else {
  single_value->field_arfcn.clean_up();
}
if (other_value.trx__nr().is_bound()) {
  single_value->field_trx__nr = other_value.trx__nr();
} else {
  single_value->field_trx__nr.clean_up();
}
if (other_value.ts__nr().is_bound()) {
  single_value->field_ts__nr = other_value.ts__nr();
} else {
  single_value->field_ts__nr.clean_up();
}
if (other_value.block__nr().is_bound()) {
  single_value->field_block__nr = other_value.block__nr();
} else {
  single_value->field_block__nr.clean_up();
}
if (other_value.rssi().is_bound()) {
  single_value->field_rssi = other_value.rssi();
} else {
  single_value->field_rssi.clean_up();
}
if (other_value.ber10k().is_bound()) {
  single_value->field_ber10k = other_value.ber10k();
} else {
  single_value->field_ber10k.clean_up();
}
if (other_value.ta__offs__qbits().is_bound()) {
  single_value->field_ta__offs__qbits = other_value.ta__offs__qbits();
} else {
  single_value->field_ta__offs__qbits.clean_up();
}
if (other_value.lqual__cb().is_bound()) {
  single_value->field_lqual__cb = other_value.lqual__cb();
} else {
  single_value->field_lqual__cb.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__data_template::copy_template(const PCUIF__data_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sapi().get_selection()) {
single_value->field_sapi = other_value.sapi();
} else {
single_value->field_sapi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.len().get_selection()) {
single_value->field_len = other_value.len();
} else {
single_value->field_len.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.fn().get_selection()) {
single_value->field_fn = other_value.fn();
} else {
single_value->field_fn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.arfcn().get_selection()) {
single_value->field_arfcn = other_value.arfcn();
} else {
single_value->field_arfcn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trx__nr().get_selection()) {
single_value->field_trx__nr = other_value.trx__nr();
} else {
single_value->field_trx__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ts__nr().get_selection()) {
single_value->field_ts__nr = other_value.ts__nr();
} else {
single_value->field_ts__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.block__nr().get_selection()) {
single_value->field_block__nr = other_value.block__nr();
} else {
single_value->field_block__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rssi().get_selection()) {
single_value->field_rssi = other_value.rssi();
} else {
single_value->field_rssi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ber10k().get_selection()) {
single_value->field_ber10k = other_value.ber10k();
} else {
single_value->field_ber10k.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ta__offs__qbits().get_selection()) {
single_value->field_ta__offs__qbits = other_value.ta__offs__qbits();
} else {
single_value->field_ta__offs__qbits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lqual__cb().get_selection()) {
single_value->field_lqual__cb = other_value.lqual__cb();
} else {
single_value->field_lqual__cb.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data.");
break;
}
set_selection(other_value);
}

PCUIF__data_template::PCUIF__data_template()
{
}

PCUIF__data_template::PCUIF__data_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__data_template::PCUIF__data_template(const PCUIF__data& other_value)
{
copy_value(other_value);
}

PCUIF__data_template::PCUIF__data_template(const OPTIONAL<PCUIF__data>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_data from an unbound optional field.");
}
}

PCUIF__data_template::PCUIF__data_template(const PCUIF__data_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__data_template::~PCUIF__data_template()
{
clean_up();
}

PCUIF__data_template& PCUIF__data_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__data_template& PCUIF__data_template::operator=(const PCUIF__data& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__data_template& PCUIF__data_template::operator=(const OPTIONAL<PCUIF__data>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__data&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_data.");
}
return *this;
}

PCUIF__data_template& PCUIF__data_template::operator=(const PCUIF__data_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__data_template::match(const PCUIF__data& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sapi().is_bound()) return FALSE;
if(!single_value->field_sapi.match(other_value.sapi(), legacy))return FALSE;
if(!other_value.len().is_bound()) return FALSE;
if(!single_value->field_len.match(other_value.len(), legacy))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if(!single_value->field_data.match(other_value.data(), legacy))return FALSE;
if(!other_value.fn().is_bound()) return FALSE;
if(!single_value->field_fn.match(other_value.fn(), legacy))return FALSE;
if(!other_value.arfcn().is_bound()) return FALSE;
if(!single_value->field_arfcn.match(other_value.arfcn(), legacy))return FALSE;
if(!other_value.trx__nr().is_bound()) return FALSE;
if(!single_value->field_trx__nr.match(other_value.trx__nr(), legacy))return FALSE;
if(!other_value.ts__nr().is_bound()) return FALSE;
if(!single_value->field_ts__nr.match(other_value.ts__nr(), legacy))return FALSE;
if(!other_value.block__nr().is_bound()) return FALSE;
if(!single_value->field_block__nr.match(other_value.block__nr(), legacy))return FALSE;
if(!other_value.rssi().is_bound()) return FALSE;
if(!single_value->field_rssi.match(other_value.rssi(), legacy))return FALSE;
if(!other_value.ber10k().is_bound()) return FALSE;
if(!single_value->field_ber10k.match(other_value.ber10k(), legacy))return FALSE;
if(!other_value.ta__offs__qbits().is_bound()) return FALSE;
if(!single_value->field_ta__offs__qbits.match(other_value.ta__offs__qbits(), legacy))return FALSE;
if(!other_value.lqual__cb().is_bound()) return FALSE;
if(!single_value->field_lqual__cb.match(other_value.lqual__cb(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data.");
}
return FALSE;
}

boolean PCUIF__data_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sapi.is_bound()) return TRUE;
if (single_value->field_len.is_bound()) return TRUE;
if (single_value->field_data.is_bound()) return TRUE;
if (single_value->field_fn.is_bound()) return TRUE;
if (single_value->field_arfcn.is_bound()) return TRUE;
if (single_value->field_trx__nr.is_bound()) return TRUE;
if (single_value->field_ts__nr.is_bound()) return TRUE;
if (single_value->field_block__nr.is_bound()) return TRUE;
if (single_value->field_rssi.is_bound()) return TRUE;
if (single_value->field_ber10k.is_bound()) return TRUE;
if (single_value->field_ta__offs__qbits.is_bound()) return TRUE;
if (single_value->field_lqual__cb.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__data_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sapi.is_value()) return FALSE;
if (!single_value->field_len.is_value()) return FALSE;
if (!single_value->field_data.is_value()) return FALSE;
if (!single_value->field_fn.is_value()) return FALSE;
if (!single_value->field_arfcn.is_value()) return FALSE;
if (!single_value->field_trx__nr.is_value()) return FALSE;
if (!single_value->field_ts__nr.is_value()) return FALSE;
if (!single_value->field_block__nr.is_value()) return FALSE;
if (!single_value->field_rssi.is_value()) return FALSE;
if (!single_value->field_ber10k.is_value()) return FALSE;
if (!single_value->field_ta__offs__qbits.is_value()) return FALSE;
if (!single_value->field_lqual__cb.is_value()) return FALSE;
return TRUE;
}

void PCUIF__data_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__data PCUIF__data_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_data.");
PCUIF__data ret_val;
if (single_value->field_sapi.is_bound()) {
ret_val.sapi() = single_value->field_sapi.valueof();
}
if (single_value->field_len.is_bound()) {
ret_val.len() = single_value->field_len.valueof();
}
if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
if (single_value->field_fn.is_bound()) {
ret_val.fn() = single_value->field_fn.valueof();
}
if (single_value->field_arfcn.is_bound()) {
ret_val.arfcn() = single_value->field_arfcn.valueof();
}
if (single_value->field_trx__nr.is_bound()) {
ret_val.trx__nr() = single_value->field_trx__nr.valueof();
}
if (single_value->field_ts__nr.is_bound()) {
ret_val.ts__nr() = single_value->field_ts__nr.valueof();
}
if (single_value->field_block__nr.is_bound()) {
ret_val.block__nr() = single_value->field_block__nr.valueof();
}
if (single_value->field_rssi.is_bound()) {
ret_val.rssi() = single_value->field_rssi.valueof();
}
if (single_value->field_ber10k.is_bound()) {
ret_val.ber10k() = single_value->field_ber10k.valueof();
}
if (single_value->field_ta__offs__qbits.is_bound()) {
ret_val.ta__offs__qbits() = single_value->field_ta__offs__qbits.valueof();
}
if (single_value->field_lqual__cb.is_bound()) {
ret_val.lqual__cb() = single_value->field_lqual__cb.valueof();
}
return ret_val;
}

void PCUIF__data_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_data.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__data_template[list_length];
}

PCUIF__data_template& PCUIF__data_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_data.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_data.");
return value_list.list_value[list_index];
}

PCUIF__Sapi_template& PCUIF__data_template::sapi()
{
set_specific();
return single_value->field_sapi;
}

const PCUIF__Sapi_template& PCUIF__data_template::sapi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sapi of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_sapi;
}

INTEGER_template& PCUIF__data_template::len()
{
set_specific();
return single_value->field_len;
}

const INTEGER_template& PCUIF__data_template::len() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field len of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_len;
}

OCTETSTRING_template& PCUIF__data_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& PCUIF__data_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_data;
}

INTEGER_template& PCUIF__data_template::fn()
{
set_specific();
return single_value->field_fn;
}

const INTEGER_template& PCUIF__data_template::fn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fn of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_fn;
}

INTEGER_template& PCUIF__data_template::arfcn()
{
set_specific();
return single_value->field_arfcn;
}

const INTEGER_template& PCUIF__data_template::arfcn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field arfcn of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_arfcn;
}

INTEGER_template& PCUIF__data_template::trx__nr()
{
set_specific();
return single_value->field_trx__nr;
}

const INTEGER_template& PCUIF__data_template::trx__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trx_nr of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_trx__nr;
}

INTEGER_template& PCUIF__data_template::ts__nr()
{
set_specific();
return single_value->field_ts__nr;
}

const INTEGER_template& PCUIF__data_template::ts__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ts_nr of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_ts__nr;
}

INTEGER_template& PCUIF__data_template::block__nr()
{
set_specific();
return single_value->field_block__nr;
}

const INTEGER_template& PCUIF__data_template::block__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field block_nr of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_block__nr;
}

INTEGER_template& PCUIF__data_template::rssi()
{
set_specific();
return single_value->field_rssi;
}

const INTEGER_template& PCUIF__data_template::rssi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rssi of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_rssi;
}

INTEGER_template& PCUIF__data_template::ber10k()
{
set_specific();
return single_value->field_ber10k;
}

const INTEGER_template& PCUIF__data_template::ber10k() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ber10k of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_ber10k;
}

INTEGER_template& PCUIF__data_template::ta__offs__qbits()
{
set_specific();
return single_value->field_ta__offs__qbits;
}

const INTEGER_template& PCUIF__data_template::ta__offs__qbits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ta_offs_qbits of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_ta__offs__qbits;
}

INTEGER_template& PCUIF__data_template::lqual__cb()
{
set_specific();
return single_value->field_lqual__cb;
}

const INTEGER_template& PCUIF__data_template::lqual__cb() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lqual_cb of a non-specific template of type @PCUIF_Types.PCUIF_data.");
return single_value->field_lqual__cb;
}

int PCUIF__data_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 12;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data.");
  }
  return 0;
}

void PCUIF__data_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log();
TTCN_Logger::log_event_str(", len := ");
single_value->field_len.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log();
TTCN_Logger::log_event_str(", rssi := ");
single_value->field_rssi.log();
TTCN_Logger::log_event_str(", ber10k := ");
single_value->field_ber10k.log();
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
single_value->field_ta__offs__qbits.log();
TTCN_Logger::log_event_str(", lqual_cb := ");
single_value->field_lqual__cb.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__data_template::log_match(const PCUIF__data& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_sapi.match(match_value.sapi(), legacy)){
TTCN_Logger::log_logmatch_info(".sapi");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_len.match(match_value.len(), legacy)){
TTCN_Logger::log_logmatch_info(".len");
single_value->field_len.log_match(match_value.len(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_data.match(match_value.data(), legacy)){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_fn.match(match_value.fn(), legacy)){
TTCN_Logger::log_logmatch_info(".fn");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_arfcn.match(match_value.arfcn(), legacy)){
TTCN_Logger::log_logmatch_info(".arfcn");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trx__nr.match(match_value.trx__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".trx_nr");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ts__nr.match(match_value.ts__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".ts_nr");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_block__nr.match(match_value.block__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".block_nr");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rssi.match(match_value.rssi(), legacy)){
TTCN_Logger::log_logmatch_info(".rssi");
single_value->field_rssi.log_match(match_value.rssi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ber10k.match(match_value.ber10k(), legacy)){
TTCN_Logger::log_logmatch_info(".ber10k");
single_value->field_ber10k.log_match(match_value.ber10k(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ta__offs__qbits.match(match_value.ta__offs__qbits(), legacy)){
TTCN_Logger::log_logmatch_info(".ta_offs_qbits");
single_value->field_ta__offs__qbits.log_match(match_value.ta__offs__qbits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lqual__cb.match(match_value.lqual__cb(), legacy)){
TTCN_Logger::log_logmatch_info(".lqual_cb");
single_value->field_lqual__cb.log_match(match_value.lqual__cb(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::log_event_str(", len := ");
single_value->field_len.log_match(match_value.len(), legacy);
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::log_event_str(", rssi := ");
single_value->field_rssi.log_match(match_value.rssi(), legacy);
TTCN_Logger::log_event_str(", ber10k := ");
single_value->field_ber10k.log_match(match_value.ber10k(), legacy);
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
single_value->field_ta__offs__qbits.log_match(match_value.ta__offs__qbits(), legacy);
TTCN_Logger::log_event_str(", lqual_cb := ");
single_value->field_lqual__cb.log_match(match_value.lqual__cb(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__data_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sapi.encode_text(text_buf);
single_value->field_len.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
single_value->field_fn.encode_text(text_buf);
single_value->field_arfcn.encode_text(text_buf);
single_value->field_trx__nr.encode_text(text_buf);
single_value->field_ts__nr.encode_text(text_buf);
single_value->field_block__nr.encode_text(text_buf);
single_value->field_rssi.encode_text(text_buf);
single_value->field_ber10k.encode_text(text_buf);
single_value->field_ta__offs__qbits.encode_text(text_buf);
single_value->field_lqual__cb.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data.");
}
}

void PCUIF__data_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sapi.decode_text(text_buf);
single_value->field_len.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
single_value->field_fn.decode_text(text_buf);
single_value->field_arfcn.decode_text(text_buf);
single_value->field_trx__nr.decode_text(text_buf);
single_value->field_ts__nr.decode_text(text_buf);
single_value->field_block__nr.decode_text(text_buf);
single_value->field_rssi.decode_text(text_buf);
single_value->field_ber10k.decode_text(text_buf);
single_value->field_ta__offs__qbits.decode_text(text_buf);
single_value->field_lqual__cb.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__data_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_data.");
}
}

void PCUIF__data_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__data_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (12<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_data has 12 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) len().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) rssi().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ber10k().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) ta__offs__qbits().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) lqual__cb().set_param(*param.get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "len")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          len().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rssi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rssi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ber10k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ber10k().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ta_offs_qbits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ta__offs__qbits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lqual_cb")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lqual__cb().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_data: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_data");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__data_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sapi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_len.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_fn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_arfcn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_trx__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_ts__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_block__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_rssi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_ber10k.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_ta__offs__qbits.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
single_value->field_lqual__cb.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_data");
}

boolean PCUIF__data_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__data_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__data__cnf__dt::PCUIF__data__cnf__dt()
{
}

PCUIF__data__cnf__dt::PCUIF__data__cnf__dt(const PCUIF__Sapi& par_sapi,
    const OCTETSTRING& par_tlli,
    const INTEGER& par_fn,
    const INTEGER& par_arfcn,
    const INTEGER& par_trx__nr,
    const INTEGER& par_ts__nr,
    const INTEGER& par_block__nr,
    const INTEGER& par_rssi,
    const INTEGER& par_ber10k,
    const INTEGER& par_ta__offs__qbits,
    const INTEGER& par_lqual__cb)
  :   field_sapi(par_sapi),
  field_tlli(par_tlli),
  field_fn(par_fn),
  field_arfcn(par_arfcn),
  field_trx__nr(par_trx__nr),
  field_ts__nr(par_ts__nr),
  field_block__nr(par_block__nr),
  field_rssi(par_rssi),
  field_ber10k(par_ber10k),
  field_ta__offs__qbits(par_ta__offs__qbits),
  field_lqual__cb(par_lqual__cb)
{
}

PCUIF__data__cnf__dt::PCUIF__data__cnf__dt(const PCUIF__data__cnf__dt& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_data_cnf_dt.");
if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
else field_sapi.clean_up();
if (other_value.tlli().is_bound()) field_tlli = other_value.tlli();
else field_tlli.clean_up();
if (other_value.fn().is_bound()) field_fn = other_value.fn();
else field_fn.clean_up();
if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
else field_arfcn.clean_up();
if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
else field_trx__nr.clean_up();
if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
else field_ts__nr.clean_up();
if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
else field_block__nr.clean_up();
if (other_value.rssi().is_bound()) field_rssi = other_value.rssi();
else field_rssi.clean_up();
if (other_value.ber10k().is_bound()) field_ber10k = other_value.ber10k();
else field_ber10k.clean_up();
if (other_value.ta__offs__qbits().is_bound()) field_ta__offs__qbits = other_value.ta__offs__qbits();
else field_ta__offs__qbits.clean_up();
if (other_value.lqual__cb().is_bound()) field_lqual__cb = other_value.lqual__cb();
else field_lqual__cb.clean_up();
}

void PCUIF__data__cnf__dt::clean_up()
{
field_sapi.clean_up();
field_tlli.clean_up();
field_fn.clean_up();
field_arfcn.clean_up();
field_trx__nr.clean_up();
field_ts__nr.clean_up();
field_block__nr.clean_up();
field_rssi.clean_up();
field_ber10k.clean_up();
field_ta__offs__qbits.clean_up();
field_lqual__cb.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__data__cnf__dt::get_descriptor() const { return &PCUIF__data__cnf__dt_descr_; }
PCUIF__data__cnf__dt& PCUIF__data__cnf__dt::operator=(const PCUIF__data__cnf__dt& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_data_cnf_dt.");
  if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
  else field_sapi.clean_up();
  if (other_value.tlli().is_bound()) field_tlli = other_value.tlli();
  else field_tlli.clean_up();
  if (other_value.fn().is_bound()) field_fn = other_value.fn();
  else field_fn.clean_up();
  if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
  else field_arfcn.clean_up();
  if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
  else field_trx__nr.clean_up();
  if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
  else field_ts__nr.clean_up();
  if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
  else field_block__nr.clean_up();
  if (other_value.rssi().is_bound()) field_rssi = other_value.rssi();
  else field_rssi.clean_up();
  if (other_value.ber10k().is_bound()) field_ber10k = other_value.ber10k();
  else field_ber10k.clean_up();
  if (other_value.ta__offs__qbits().is_bound()) field_ta__offs__qbits = other_value.ta__offs__qbits();
  else field_ta__offs__qbits.clean_up();
  if (other_value.lqual__cb().is_bound()) field_lqual__cb = other_value.lqual__cb();
  else field_lqual__cb.clean_up();
}
return *this;
}

boolean PCUIF__data__cnf__dt::operator==(const PCUIF__data__cnf__dt& other_value) const
{
return field_sapi==other_value.field_sapi
  && field_tlli==other_value.field_tlli
  && field_fn==other_value.field_fn
  && field_arfcn==other_value.field_arfcn
  && field_trx__nr==other_value.field_trx__nr
  && field_ts__nr==other_value.field_ts__nr
  && field_block__nr==other_value.field_block__nr
  && field_rssi==other_value.field_rssi
  && field_ber10k==other_value.field_ber10k
  && field_ta__offs__qbits==other_value.field_ta__offs__qbits
  && field_lqual__cb==other_value.field_lqual__cb;
}

boolean PCUIF__data__cnf__dt::is_bound() const
{
if(field_sapi.is_bound()) return TRUE;
if(field_tlli.is_bound()) return TRUE;
if(field_fn.is_bound()) return TRUE;
if(field_arfcn.is_bound()) return TRUE;
if(field_trx__nr.is_bound()) return TRUE;
if(field_ts__nr.is_bound()) return TRUE;
if(field_block__nr.is_bound()) return TRUE;
if(field_rssi.is_bound()) return TRUE;
if(field_ber10k.is_bound()) return TRUE;
if(field_ta__offs__qbits.is_bound()) return TRUE;
if(field_lqual__cb.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__data__cnf__dt::is_value() const
{
if(!field_sapi.is_value()) return FALSE;
if(!field_tlli.is_value()) return FALSE;
if(!field_fn.is_value()) return FALSE;
if(!field_arfcn.is_value()) return FALSE;
if(!field_trx__nr.is_value()) return FALSE;
if(!field_ts__nr.is_value()) return FALSE;
if(!field_block__nr.is_value()) return FALSE;
if(!field_rssi.is_value()) return FALSE;
if(!field_ber10k.is_value()) return FALSE;
if(!field_ta__offs__qbits.is_value()) return FALSE;
if(!field_lqual__cb.is_value()) return FALSE;
return TRUE;
}
void PCUIF__data__cnf__dt::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sapi := ");
field_sapi.log();
TTCN_Logger::log_event_str(", tlli := ");
field_tlli.log();
TTCN_Logger::log_event_str(", fn := ");
field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
field_block__nr.log();
TTCN_Logger::log_event_str(", rssi := ");
field_rssi.log();
TTCN_Logger::log_event_str(", ber10k := ");
field_ber10k.log();
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
field_ta__offs__qbits.log();
TTCN_Logger::log_event_str(", lqual_cb := ");
field_lqual__cb.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__data__cnf__dt::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (11<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_data_cnf_dt has 11 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) tlli().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) rssi().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) ber10k().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ta__offs__qbits().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) lqual__cb().set_param(*param.get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlli")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlli().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rssi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rssi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ber10k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ber10k().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ta_offs_qbits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ta__offs__qbits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lqual_cb")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lqual__cb().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_data_cnf_dt: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_data_cnf_dt");
  }
}

void PCUIF__data__cnf__dt::set_implicit_omit()
{
if (sapi().is_bound()) sapi().set_implicit_omit();
if (tlli().is_bound()) tlli().set_implicit_omit();
if (fn().is_bound()) fn().set_implicit_omit();
if (arfcn().is_bound()) arfcn().set_implicit_omit();
if (trx__nr().is_bound()) trx__nr().set_implicit_omit();
if (ts__nr().is_bound()) ts__nr().set_implicit_omit();
if (block__nr().is_bound()) block__nr().set_implicit_omit();
if (rssi().is_bound()) rssi().set_implicit_omit();
if (ber10k().is_bound()) ber10k().set_implicit_omit();
if (ta__offs__qbits().is_bound()) ta__offs__qbits().set_implicit_omit();
if (lqual__cb().is_bound()) lqual__cb().set_implicit_omit();
}

void PCUIF__data__cnf__dt::encode_text(Text_Buf& text_buf) const
{
field_sapi.encode_text(text_buf);
field_tlli.encode_text(text_buf);
field_fn.encode_text(text_buf);
field_arfcn.encode_text(text_buf);
field_trx__nr.encode_text(text_buf);
field_ts__nr.encode_text(text_buf);
field_block__nr.encode_text(text_buf);
field_rssi.encode_text(text_buf);
field_ber10k.encode_text(text_buf);
field_ta__offs__qbits.encode_text(text_buf);
field_lqual__cb.encode_text(text_buf);
}

void PCUIF__data__cnf__dt::decode_text(Text_Buf& text_buf)
{
field_sapi.decode_text(text_buf);
field_tlli.decode_text(text_buf);
field_fn.decode_text(text_buf);
field_arfcn.decode_text(text_buf);
field_trx__nr.decode_text(text_buf);
field_ts__nr.decode_text(text_buf);
field_block__nr.decode_text(text_buf);
field_rssi.decode_text(text_buf);
field_ber10k.decode_text(text_buf);
field_ta__offs__qbits.decode_text(text_buf);
field_lqual__cb.decode_text(text_buf);
}

void PCUIF__data__cnf__dt::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__data__cnf__dt::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__data__cnf__dt::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__data__cnf__dt_sapi_descr_.raw->forceomit);
  decoded_field_length = field_sapi.RAW_decode(PCUIF__data__cnf__dt_sapi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__data__cnf__dt_tlli_descr_.raw->forceomit);
  decoded_field_length = field_tlli.RAW_decode(PCUIF__data__cnf__dt_tlli_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__data__cnf__dt_fn_descr_.raw->forceomit);
  decoded_field_length = field_fn.RAW_decode(PCUIF__data__cnf__dt_fn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__data__cnf__dt_arfcn_descr_.raw->forceomit);
  decoded_field_length = field_arfcn.RAW_decode(PCUIF__data__cnf__dt_arfcn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__data__cnf__dt_trx__nr_descr_.raw->forceomit);
  decoded_field_length = field_trx__nr.RAW_decode(PCUIF__data__cnf__dt_trx__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__data__cnf__dt_ts__nr_descr_.raw->forceomit);
  decoded_field_length = field_ts__nr.RAW_decode(PCUIF__data__cnf__dt_ts__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__data__cnf__dt_block__nr_descr_.raw->forceomit);
  decoded_field_length = field_block__nr.RAW_decode(PCUIF__data__cnf__dt_block__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_7_force_omit(7, force_omit, PCUIF__data__cnf__dt_rssi_descr_.raw->forceomit);
  decoded_field_length = field_rssi.RAW_decode(PCUIF__data__cnf__dt_rssi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_8_force_omit(8, force_omit, PCUIF__data__cnf__dt_ber10k_descr_.raw->forceomit);
  decoded_field_length = field_ber10k.RAW_decode(PCUIF__data__cnf__dt_ber10k_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_9_force_omit(9, force_omit, PCUIF__data__cnf__dt_ta__offs__qbits_descr_.raw->forceomit);
  decoded_field_length = field_ta__offs__qbits.RAW_decode(PCUIF__data__cnf__dt_ta__offs__qbits_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_10_force_omit(10, force_omit, PCUIF__data__cnf__dt_lqual__cb_descr_.raw->forceomit);
  decoded_field_length = field_lqual__cb.RAW_decode(PCUIF__data__cnf__dt_lqual__cb_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_10_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__data__cnf__dt::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 11;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(11);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__data__cnf__dt_sapi_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__data__cnf__dt_tlli_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__data__cnf__dt_fn_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__data__cnf__dt_arfcn_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__data__cnf__dt_trx__nr_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__data__cnf__dt_ts__nr_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__data__cnf__dt_block__nr_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, PCUIF__data__cnf__dt_rssi_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, PCUIF__data__cnf__dt_ber10k_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, PCUIF__data__cnf__dt_ta__offs__qbits_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 10, PCUIF__data__cnf__dt_lqual__cb_descr_.raw);
  encoded_length += field_sapi.RAW_encode(PCUIF__data__cnf__dt_sapi_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_tlli.RAW_encode(PCUIF__data__cnf__dt_tlli_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_fn.RAW_encode(PCUIF__data__cnf__dt_fn_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_arfcn.RAW_encode(PCUIF__data__cnf__dt_arfcn_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_trx__nr.RAW_encode(PCUIF__data__cnf__dt_trx__nr_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_ts__nr.RAW_encode(PCUIF__data__cnf__dt_ts__nr_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_block__nr.RAW_encode(PCUIF__data__cnf__dt_block__nr_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_rssi.RAW_encode(PCUIF__data__cnf__dt_rssi_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_ber10k.RAW_encode(PCUIF__data__cnf__dt_ber10k_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_ta__offs__qbits.RAW_encode(PCUIF__data__cnf__dt_ta__offs__qbits_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_lqual__cb.RAW_encode(PCUIF__data__cnf__dt_lqual__cb_descr_, *myleaf.body.node.nodes[10]);
  return myleaf.length = encoded_length;
}

struct PCUIF__data__cnf__dt_template::single_value_struct {
PCUIF__Sapi_template field_sapi;
OCTETSTRING_template field_tlli;
INTEGER_template field_fn;
INTEGER_template field_arfcn;
INTEGER_template field_trx__nr;
INTEGER_template field_ts__nr;
INTEGER_template field_block__nr;
INTEGER_template field_rssi;
INTEGER_template field_ber10k;
INTEGER_template field_ta__offs__qbits;
INTEGER_template field_lqual__cb;
};

void PCUIF__data__cnf__dt_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sapi = ANY_VALUE;
single_value->field_tlli = ANY_VALUE;
single_value->field_fn = ANY_VALUE;
single_value->field_arfcn = ANY_VALUE;
single_value->field_trx__nr = ANY_VALUE;
single_value->field_ts__nr = ANY_VALUE;
single_value->field_block__nr = ANY_VALUE;
single_value->field_rssi = ANY_VALUE;
single_value->field_ber10k = ANY_VALUE;
single_value->field_ta__offs__qbits = ANY_VALUE;
single_value->field_lqual__cb = ANY_VALUE;
}
}
}

void PCUIF__data__cnf__dt_template::copy_value(const PCUIF__data__cnf__dt& other_value)
{
single_value = new single_value_struct;
if (other_value.sapi().is_bound()) {
  single_value->field_sapi = other_value.sapi();
} else {
  single_value->field_sapi.clean_up();
}
if (other_value.tlli().is_bound()) {
  single_value->field_tlli = other_value.tlli();
} else {
  single_value->field_tlli.clean_up();
}
if (other_value.fn().is_bound()) {
  single_value->field_fn = other_value.fn();
} else {
  single_value->field_fn.clean_up();
}
if (other_value.arfcn().is_bound()) {
  single_value->field_arfcn = other_value.arfcn();
} else {
  single_value->field_arfcn.clean_up();
}
if (other_value.trx__nr().is_bound()) {
  single_value->field_trx__nr = other_value.trx__nr();
} else {
  single_value->field_trx__nr.clean_up();
}
if (other_value.ts__nr().is_bound()) {
  single_value->field_ts__nr = other_value.ts__nr();
} else {
  single_value->field_ts__nr.clean_up();
}
if (other_value.block__nr().is_bound()) {
  single_value->field_block__nr = other_value.block__nr();
} else {
  single_value->field_block__nr.clean_up();
}
if (other_value.rssi().is_bound()) {
  single_value->field_rssi = other_value.rssi();
} else {
  single_value->field_rssi.clean_up();
}
if (other_value.ber10k().is_bound()) {
  single_value->field_ber10k = other_value.ber10k();
} else {
  single_value->field_ber10k.clean_up();
}
if (other_value.ta__offs__qbits().is_bound()) {
  single_value->field_ta__offs__qbits = other_value.ta__offs__qbits();
} else {
  single_value->field_ta__offs__qbits.clean_up();
}
if (other_value.lqual__cb().is_bound()) {
  single_value->field_lqual__cb = other_value.lqual__cb();
} else {
  single_value->field_lqual__cb.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__data__cnf__dt_template::copy_template(const PCUIF__data__cnf__dt_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sapi().get_selection()) {
single_value->field_sapi = other_value.sapi();
} else {
single_value->field_sapi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tlli().get_selection()) {
single_value->field_tlli = other_value.tlli();
} else {
single_value->field_tlli.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.fn().get_selection()) {
single_value->field_fn = other_value.fn();
} else {
single_value->field_fn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.arfcn().get_selection()) {
single_value->field_arfcn = other_value.arfcn();
} else {
single_value->field_arfcn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trx__nr().get_selection()) {
single_value->field_trx__nr = other_value.trx__nr();
} else {
single_value->field_trx__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ts__nr().get_selection()) {
single_value->field_ts__nr = other_value.ts__nr();
} else {
single_value->field_ts__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.block__nr().get_selection()) {
single_value->field_block__nr = other_value.block__nr();
} else {
single_value->field_block__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rssi().get_selection()) {
single_value->field_rssi = other_value.rssi();
} else {
single_value->field_rssi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ber10k().get_selection()) {
single_value->field_ber10k = other_value.ber10k();
} else {
single_value->field_ber10k.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ta__offs__qbits().get_selection()) {
single_value->field_ta__offs__qbits = other_value.ta__offs__qbits();
} else {
single_value->field_ta__offs__qbits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lqual__cb().get_selection()) {
single_value->field_lqual__cb = other_value.lqual__cb();
} else {
single_value->field_lqual__cb.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__data__cnf__dt_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
break;
}
set_selection(other_value);
}

PCUIF__data__cnf__dt_template::PCUIF__data__cnf__dt_template()
{
}

PCUIF__data__cnf__dt_template::PCUIF__data__cnf__dt_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__data__cnf__dt_template::PCUIF__data__cnf__dt_template(const PCUIF__data__cnf__dt& other_value)
{
copy_value(other_value);
}

PCUIF__data__cnf__dt_template::PCUIF__data__cnf__dt_template(const OPTIONAL<PCUIF__data__cnf__dt>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__data__cnf__dt&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_data_cnf_dt from an unbound optional field.");
}
}

PCUIF__data__cnf__dt_template::PCUIF__data__cnf__dt_template(const PCUIF__data__cnf__dt_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__data__cnf__dt_template::~PCUIF__data__cnf__dt_template()
{
clean_up();
}

PCUIF__data__cnf__dt_template& PCUIF__data__cnf__dt_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__data__cnf__dt_template& PCUIF__data__cnf__dt_template::operator=(const PCUIF__data__cnf__dt& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__data__cnf__dt_template& PCUIF__data__cnf__dt_template::operator=(const OPTIONAL<PCUIF__data__cnf__dt>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__data__cnf__dt&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
}
return *this;
}

PCUIF__data__cnf__dt_template& PCUIF__data__cnf__dt_template::operator=(const PCUIF__data__cnf__dt_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__data__cnf__dt_template::match(const PCUIF__data__cnf__dt& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sapi().is_bound()) return FALSE;
if(!single_value->field_sapi.match(other_value.sapi(), legacy))return FALSE;
if(!other_value.tlli().is_bound()) return FALSE;
if(!single_value->field_tlli.match(other_value.tlli(), legacy))return FALSE;
if(!other_value.fn().is_bound()) return FALSE;
if(!single_value->field_fn.match(other_value.fn(), legacy))return FALSE;
if(!other_value.arfcn().is_bound()) return FALSE;
if(!single_value->field_arfcn.match(other_value.arfcn(), legacy))return FALSE;
if(!other_value.trx__nr().is_bound()) return FALSE;
if(!single_value->field_trx__nr.match(other_value.trx__nr(), legacy))return FALSE;
if(!other_value.ts__nr().is_bound()) return FALSE;
if(!single_value->field_ts__nr.match(other_value.ts__nr(), legacy))return FALSE;
if(!other_value.block__nr().is_bound()) return FALSE;
if(!single_value->field_block__nr.match(other_value.block__nr(), legacy))return FALSE;
if(!other_value.rssi().is_bound()) return FALSE;
if(!single_value->field_rssi.match(other_value.rssi(), legacy))return FALSE;
if(!other_value.ber10k().is_bound()) return FALSE;
if(!single_value->field_ber10k.match(other_value.ber10k(), legacy))return FALSE;
if(!other_value.ta__offs__qbits().is_bound()) return FALSE;
if(!single_value->field_ta__offs__qbits.match(other_value.ta__offs__qbits(), legacy))return FALSE;
if(!other_value.lqual__cb().is_bound()) return FALSE;
if(!single_value->field_lqual__cb.match(other_value.lqual__cb(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
}
return FALSE;
}

boolean PCUIF__data__cnf__dt_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sapi.is_bound()) return TRUE;
if (single_value->field_tlli.is_bound()) return TRUE;
if (single_value->field_fn.is_bound()) return TRUE;
if (single_value->field_arfcn.is_bound()) return TRUE;
if (single_value->field_trx__nr.is_bound()) return TRUE;
if (single_value->field_ts__nr.is_bound()) return TRUE;
if (single_value->field_block__nr.is_bound()) return TRUE;
if (single_value->field_rssi.is_bound()) return TRUE;
if (single_value->field_ber10k.is_bound()) return TRUE;
if (single_value->field_ta__offs__qbits.is_bound()) return TRUE;
if (single_value->field_lqual__cb.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__data__cnf__dt_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sapi.is_value()) return FALSE;
if (!single_value->field_tlli.is_value()) return FALSE;
if (!single_value->field_fn.is_value()) return FALSE;
if (!single_value->field_arfcn.is_value()) return FALSE;
if (!single_value->field_trx__nr.is_value()) return FALSE;
if (!single_value->field_ts__nr.is_value()) return FALSE;
if (!single_value->field_block__nr.is_value()) return FALSE;
if (!single_value->field_rssi.is_value()) return FALSE;
if (!single_value->field_ber10k.is_value()) return FALSE;
if (!single_value->field_ta__offs__qbits.is_value()) return FALSE;
if (!single_value->field_lqual__cb.is_value()) return FALSE;
return TRUE;
}

void PCUIF__data__cnf__dt_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__data__cnf__dt PCUIF__data__cnf__dt_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
PCUIF__data__cnf__dt ret_val;
if (single_value->field_sapi.is_bound()) {
ret_val.sapi() = single_value->field_sapi.valueof();
}
if (single_value->field_tlli.is_bound()) {
ret_val.tlli() = single_value->field_tlli.valueof();
}
if (single_value->field_fn.is_bound()) {
ret_val.fn() = single_value->field_fn.valueof();
}
if (single_value->field_arfcn.is_bound()) {
ret_val.arfcn() = single_value->field_arfcn.valueof();
}
if (single_value->field_trx__nr.is_bound()) {
ret_val.trx__nr() = single_value->field_trx__nr.valueof();
}
if (single_value->field_ts__nr.is_bound()) {
ret_val.ts__nr() = single_value->field_ts__nr.valueof();
}
if (single_value->field_block__nr.is_bound()) {
ret_val.block__nr() = single_value->field_block__nr.valueof();
}
if (single_value->field_rssi.is_bound()) {
ret_val.rssi() = single_value->field_rssi.valueof();
}
if (single_value->field_ber10k.is_bound()) {
ret_val.ber10k() = single_value->field_ber10k.valueof();
}
if (single_value->field_ta__offs__qbits.is_bound()) {
ret_val.ta__offs__qbits() = single_value->field_ta__offs__qbits.valueof();
}
if (single_value->field_lqual__cb.is_bound()) {
ret_val.lqual__cb() = single_value->field_lqual__cb.valueof();
}
return ret_val;
}

void PCUIF__data__cnf__dt_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__data__cnf__dt_template[list_length];
}

PCUIF__data__cnf__dt_template& PCUIF__data__cnf__dt_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return value_list.list_value[list_index];
}

PCUIF__Sapi_template& PCUIF__data__cnf__dt_template::sapi()
{
set_specific();
return single_value->field_sapi;
}

const PCUIF__Sapi_template& PCUIF__data__cnf__dt_template::sapi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sapi of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_sapi;
}

OCTETSTRING_template& PCUIF__data__cnf__dt_template::tlli()
{
set_specific();
return single_value->field_tlli;
}

const OCTETSTRING_template& PCUIF__data__cnf__dt_template::tlli() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tlli of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_tlli;
}

INTEGER_template& PCUIF__data__cnf__dt_template::fn()
{
set_specific();
return single_value->field_fn;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::fn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fn of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_fn;
}

INTEGER_template& PCUIF__data__cnf__dt_template::arfcn()
{
set_specific();
return single_value->field_arfcn;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::arfcn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field arfcn of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_arfcn;
}

INTEGER_template& PCUIF__data__cnf__dt_template::trx__nr()
{
set_specific();
return single_value->field_trx__nr;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::trx__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trx_nr of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_trx__nr;
}

INTEGER_template& PCUIF__data__cnf__dt_template::ts__nr()
{
set_specific();
return single_value->field_ts__nr;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::ts__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ts_nr of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_ts__nr;
}

INTEGER_template& PCUIF__data__cnf__dt_template::block__nr()
{
set_specific();
return single_value->field_block__nr;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::block__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field block_nr of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_block__nr;
}

INTEGER_template& PCUIF__data__cnf__dt_template::rssi()
{
set_specific();
return single_value->field_rssi;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::rssi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rssi of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_rssi;
}

INTEGER_template& PCUIF__data__cnf__dt_template::ber10k()
{
set_specific();
return single_value->field_ber10k;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::ber10k() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ber10k of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_ber10k;
}

INTEGER_template& PCUIF__data__cnf__dt_template::ta__offs__qbits()
{
set_specific();
return single_value->field_ta__offs__qbits;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::ta__offs__qbits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ta_offs_qbits of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_ta__offs__qbits;
}

INTEGER_template& PCUIF__data__cnf__dt_template::lqual__cb()
{
set_specific();
return single_value->field_lqual__cb;
}

const INTEGER_template& PCUIF__data__cnf__dt_template::lqual__cb() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lqual_cb of a non-specific template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
return single_value->field_lqual__cb;
}

int PCUIF__data__cnf__dt_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 11;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_data_cnf_dt containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
  }
  return 0;
}

void PCUIF__data__cnf__dt_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log();
TTCN_Logger::log_event_str(", tlli := ");
single_value->field_tlli.log();
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log();
TTCN_Logger::log_event_str(", rssi := ");
single_value->field_rssi.log();
TTCN_Logger::log_event_str(", ber10k := ");
single_value->field_ber10k.log();
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
single_value->field_ta__offs__qbits.log();
TTCN_Logger::log_event_str(", lqual_cb := ");
single_value->field_lqual__cb.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__data__cnf__dt_template::log_match(const PCUIF__data__cnf__dt& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_sapi.match(match_value.sapi(), legacy)){
TTCN_Logger::log_logmatch_info(".sapi");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tlli.match(match_value.tlli(), legacy)){
TTCN_Logger::log_logmatch_info(".tlli");
single_value->field_tlli.log_match(match_value.tlli(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_fn.match(match_value.fn(), legacy)){
TTCN_Logger::log_logmatch_info(".fn");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_arfcn.match(match_value.arfcn(), legacy)){
TTCN_Logger::log_logmatch_info(".arfcn");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trx__nr.match(match_value.trx__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".trx_nr");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ts__nr.match(match_value.ts__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".ts_nr");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_block__nr.match(match_value.block__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".block_nr");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rssi.match(match_value.rssi(), legacy)){
TTCN_Logger::log_logmatch_info(".rssi");
single_value->field_rssi.log_match(match_value.rssi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ber10k.match(match_value.ber10k(), legacy)){
TTCN_Logger::log_logmatch_info(".ber10k");
single_value->field_ber10k.log_match(match_value.ber10k(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ta__offs__qbits.match(match_value.ta__offs__qbits(), legacy)){
TTCN_Logger::log_logmatch_info(".ta_offs_qbits");
single_value->field_ta__offs__qbits.log_match(match_value.ta__offs__qbits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lqual__cb.match(match_value.lqual__cb(), legacy)){
TTCN_Logger::log_logmatch_info(".lqual_cb");
single_value->field_lqual__cb.log_match(match_value.lqual__cb(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::log_event_str(", tlli := ");
single_value->field_tlli.log_match(match_value.tlli(), legacy);
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::log_event_str(", rssi := ");
single_value->field_rssi.log_match(match_value.rssi(), legacy);
TTCN_Logger::log_event_str(", ber10k := ");
single_value->field_ber10k.log_match(match_value.ber10k(), legacy);
TTCN_Logger::log_event_str(", ta_offs_qbits := ");
single_value->field_ta__offs__qbits.log_match(match_value.ta__offs__qbits(), legacy);
TTCN_Logger::log_event_str(", lqual_cb := ");
single_value->field_lqual__cb.log_match(match_value.lqual__cb(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__data__cnf__dt_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sapi.encode_text(text_buf);
single_value->field_tlli.encode_text(text_buf);
single_value->field_fn.encode_text(text_buf);
single_value->field_arfcn.encode_text(text_buf);
single_value->field_trx__nr.encode_text(text_buf);
single_value->field_ts__nr.encode_text(text_buf);
single_value->field_block__nr.encode_text(text_buf);
single_value->field_rssi.encode_text(text_buf);
single_value->field_ber10k.encode_text(text_buf);
single_value->field_ta__offs__qbits.encode_text(text_buf);
single_value->field_lqual__cb.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
}
}

void PCUIF__data__cnf__dt_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sapi.decode_text(text_buf);
single_value->field_tlli.decode_text(text_buf);
single_value->field_fn.decode_text(text_buf);
single_value->field_arfcn.decode_text(text_buf);
single_value->field_trx__nr.decode_text(text_buf);
single_value->field_ts__nr.decode_text(text_buf);
single_value->field_block__nr.decode_text(text_buf);
single_value->field_rssi.decode_text(text_buf);
single_value->field_ber10k.decode_text(text_buf);
single_value->field_ta__offs__qbits.decode_text(text_buf);
single_value->field_lqual__cb.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__data__cnf__dt_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_data_cnf_dt.");
}
}

void PCUIF__data__cnf__dt_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__data__cnf__dt_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (11<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_data_cnf_dt has 11 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) tlli().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) rssi().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) ber10k().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ta__offs__qbits().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) lqual__cb().set_param(*param.get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlli")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlli().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rssi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rssi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ber10k")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ber10k().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ta_offs_qbits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ta__offs__qbits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lqual_cb")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lqual__cb().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_data_cnf_dt: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_data_cnf_dt");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__data__cnf__dt_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sapi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_tlli.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_fn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_arfcn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_trx__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_ts__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_block__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_rssi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_ber10k.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_ta__offs__qbits.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
single_value->field_lqual__cb.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_data_cnf_dt");
}

boolean PCUIF__data__cnf__dt_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__data__cnf__dt_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__rts__req::PCUIF__rts__req()
{
}

PCUIF__rts__req::PCUIF__rts__req(const PCUIF__Sapi& par_sapi,
    const OCTETSTRING& par_spare,
    const INTEGER& par_fn,
    const INTEGER& par_arfcn,
    const INTEGER& par_trx__nr,
    const INTEGER& par_ts__nr,
    const INTEGER& par_block__nr)
  :   field_sapi(par_sapi),
  field_spare(par_spare),
  field_fn(par_fn),
  field_arfcn(par_arfcn),
  field_trx__nr(par_trx__nr),
  field_ts__nr(par_ts__nr),
  field_block__nr(par_block__nr)
{
}

PCUIF__rts__req::PCUIF__rts__req(const PCUIF__rts__req& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_rts_req.");
if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
else field_sapi.clean_up();
if (other_value.spare().is_bound()) field_spare = other_value.spare();
else field_spare.clean_up();
if (other_value.fn().is_bound()) field_fn = other_value.fn();
else field_fn.clean_up();
if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
else field_arfcn.clean_up();
if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
else field_trx__nr.clean_up();
if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
else field_ts__nr.clean_up();
if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
else field_block__nr.clean_up();
}

void PCUIF__rts__req::clean_up()
{
field_sapi.clean_up();
field_spare.clean_up();
field_fn.clean_up();
field_arfcn.clean_up();
field_trx__nr.clean_up();
field_ts__nr.clean_up();
field_block__nr.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__rts__req::get_descriptor() const { return &PCUIF__rts__req_descr_; }
PCUIF__rts__req& PCUIF__rts__req::operator=(const PCUIF__rts__req& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_rts_req.");
  if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
  else field_sapi.clean_up();
  if (other_value.spare().is_bound()) field_spare = other_value.spare();
  else field_spare.clean_up();
  if (other_value.fn().is_bound()) field_fn = other_value.fn();
  else field_fn.clean_up();
  if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
  else field_arfcn.clean_up();
  if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
  else field_trx__nr.clean_up();
  if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
  else field_ts__nr.clean_up();
  if (other_value.block__nr().is_bound()) field_block__nr = other_value.block__nr();
  else field_block__nr.clean_up();
}
return *this;
}

boolean PCUIF__rts__req::operator==(const PCUIF__rts__req& other_value) const
{
return field_sapi==other_value.field_sapi
  && field_spare==other_value.field_spare
  && field_fn==other_value.field_fn
  && field_arfcn==other_value.field_arfcn
  && field_trx__nr==other_value.field_trx__nr
  && field_ts__nr==other_value.field_ts__nr
  && field_block__nr==other_value.field_block__nr;
}

boolean PCUIF__rts__req::is_bound() const
{
if(field_sapi.is_bound()) return TRUE;
if(field_spare.is_bound()) return TRUE;
if(field_fn.is_bound()) return TRUE;
if(field_arfcn.is_bound()) return TRUE;
if(field_trx__nr.is_bound()) return TRUE;
if(field_ts__nr.is_bound()) return TRUE;
if(field_block__nr.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__rts__req::is_value() const
{
if(!field_sapi.is_value()) return FALSE;
if(!field_spare.is_value()) return FALSE;
if(!field_fn.is_value()) return FALSE;
if(!field_arfcn.is_value()) return FALSE;
if(!field_trx__nr.is_value()) return FALSE;
if(!field_ts__nr.is_value()) return FALSE;
if(!field_block__nr.is_value()) return FALSE;
return TRUE;
}
void PCUIF__rts__req::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sapi := ");
field_sapi.log();
TTCN_Logger::log_event_str(", spare := ");
field_spare.log();
TTCN_Logger::log_event_str(", fn := ");
field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
field_block__nr.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__rts__req::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_rts_req has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_rts_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_rts_req");
  }
}

void PCUIF__rts__req::set_implicit_omit()
{
if (sapi().is_bound()) sapi().set_implicit_omit();
if (spare().is_bound()) spare().set_implicit_omit();
if (fn().is_bound()) fn().set_implicit_omit();
if (arfcn().is_bound()) arfcn().set_implicit_omit();
if (trx__nr().is_bound()) trx__nr().set_implicit_omit();
if (ts__nr().is_bound()) ts__nr().set_implicit_omit();
if (block__nr().is_bound()) block__nr().set_implicit_omit();
}

void PCUIF__rts__req::encode_text(Text_Buf& text_buf) const
{
field_sapi.encode_text(text_buf);
field_spare.encode_text(text_buf);
field_fn.encode_text(text_buf);
field_arfcn.encode_text(text_buf);
field_trx__nr.encode_text(text_buf);
field_ts__nr.encode_text(text_buf);
field_block__nr.encode_text(text_buf);
}

void PCUIF__rts__req::decode_text(Text_Buf& text_buf)
{
field_sapi.decode_text(text_buf);
field_spare.decode_text(text_buf);
field_fn.decode_text(text_buf);
field_arfcn.decode_text(text_buf);
field_trx__nr.decode_text(text_buf);
field_ts__nr.decode_text(text_buf);
field_block__nr.decode_text(text_buf);
}

void PCUIF__rts__req::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__rts__req::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__rts__req::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__rts__req_sapi_descr_.raw->forceomit);
  decoded_field_length = field_sapi.RAW_decode(PCUIF__rts__req_sapi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__rts__req_spare_descr_.raw->forceomit);
  decoded_field_length = field_spare.RAW_decode(PCUIF__rts__req_spare_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__rts__req_fn_descr_.raw->forceomit);
  decoded_field_length = field_fn.RAW_decode(PCUIF__rts__req_fn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__rts__req_arfcn_descr_.raw->forceomit);
  decoded_field_length = field_arfcn.RAW_decode(PCUIF__rts__req_arfcn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__rts__req_trx__nr_descr_.raw->forceomit);
  decoded_field_length = field_trx__nr.RAW_decode(PCUIF__rts__req_trx__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__rts__req_ts__nr_descr_.raw->forceomit);
  decoded_field_length = field_ts__nr.RAW_decode(PCUIF__rts__req_ts__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__rts__req_block__nr_descr_.raw->forceomit);
  decoded_field_length = field_block__nr.RAW_decode(PCUIF__rts__req_block__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__rts__req::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__rts__req_sapi_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__rts__req_spare_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__rts__req_fn_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__rts__req_arfcn_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__rts__req_trx__nr_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__rts__req_ts__nr_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__rts__req_block__nr_descr_.raw);
  encoded_length += field_sapi.RAW_encode(PCUIF__rts__req_sapi_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_spare.RAW_encode(PCUIF__rts__req_spare_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_fn.RAW_encode(PCUIF__rts__req_fn_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_arfcn.RAW_encode(PCUIF__rts__req_arfcn_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_trx__nr.RAW_encode(PCUIF__rts__req_trx__nr_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_ts__nr.RAW_encode(PCUIF__rts__req_ts__nr_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_block__nr.RAW_encode(PCUIF__rts__req_block__nr_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

struct PCUIF__rts__req_template::single_value_struct {
PCUIF__Sapi_template field_sapi;
OCTETSTRING_template field_spare;
INTEGER_template field_fn;
INTEGER_template field_arfcn;
INTEGER_template field_trx__nr;
INTEGER_template field_ts__nr;
INTEGER_template field_block__nr;
};

void PCUIF__rts__req_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sapi = ANY_VALUE;
single_value->field_spare = ANY_VALUE;
single_value->field_fn = ANY_VALUE;
single_value->field_arfcn = ANY_VALUE;
single_value->field_trx__nr = ANY_VALUE;
single_value->field_ts__nr = ANY_VALUE;
single_value->field_block__nr = ANY_VALUE;
}
}
}

void PCUIF__rts__req_template::copy_value(const PCUIF__rts__req& other_value)
{
single_value = new single_value_struct;
if (other_value.sapi().is_bound()) {
  single_value->field_sapi = other_value.sapi();
} else {
  single_value->field_sapi.clean_up();
}
if (other_value.spare().is_bound()) {
  single_value->field_spare = other_value.spare();
} else {
  single_value->field_spare.clean_up();
}
if (other_value.fn().is_bound()) {
  single_value->field_fn = other_value.fn();
} else {
  single_value->field_fn.clean_up();
}
if (other_value.arfcn().is_bound()) {
  single_value->field_arfcn = other_value.arfcn();
} else {
  single_value->field_arfcn.clean_up();
}
if (other_value.trx__nr().is_bound()) {
  single_value->field_trx__nr = other_value.trx__nr();
} else {
  single_value->field_trx__nr.clean_up();
}
if (other_value.ts__nr().is_bound()) {
  single_value->field_ts__nr = other_value.ts__nr();
} else {
  single_value->field_ts__nr.clean_up();
}
if (other_value.block__nr().is_bound()) {
  single_value->field_block__nr = other_value.block__nr();
} else {
  single_value->field_block__nr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__rts__req_template::copy_template(const PCUIF__rts__req_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sapi().get_selection()) {
single_value->field_sapi = other_value.sapi();
} else {
single_value->field_sapi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare().get_selection()) {
single_value->field_spare = other_value.spare();
} else {
single_value->field_spare.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.fn().get_selection()) {
single_value->field_fn = other_value.fn();
} else {
single_value->field_fn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.arfcn().get_selection()) {
single_value->field_arfcn = other_value.arfcn();
} else {
single_value->field_arfcn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trx__nr().get_selection()) {
single_value->field_trx__nr = other_value.trx__nr();
} else {
single_value->field_trx__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ts__nr().get_selection()) {
single_value->field_ts__nr = other_value.ts__nr();
} else {
single_value->field_ts__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.block__nr().get_selection()) {
single_value->field_block__nr = other_value.block__nr();
} else {
single_value->field_block__nr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__rts__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rts_req.");
break;
}
set_selection(other_value);
}

PCUIF__rts__req_template::PCUIF__rts__req_template()
{
}

PCUIF__rts__req_template::PCUIF__rts__req_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__rts__req_template::PCUIF__rts__req_template(const PCUIF__rts__req& other_value)
{
copy_value(other_value);
}

PCUIF__rts__req_template::PCUIF__rts__req_template(const OPTIONAL<PCUIF__rts__req>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__rts__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_rts_req from an unbound optional field.");
}
}

PCUIF__rts__req_template::PCUIF__rts__req_template(const PCUIF__rts__req_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__rts__req_template::~PCUIF__rts__req_template()
{
clean_up();
}

PCUIF__rts__req_template& PCUIF__rts__req_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__rts__req_template& PCUIF__rts__req_template::operator=(const PCUIF__rts__req& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__rts__req_template& PCUIF__rts__req_template::operator=(const OPTIONAL<PCUIF__rts__req>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__rts__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_rts_req.");
}
return *this;
}

PCUIF__rts__req_template& PCUIF__rts__req_template::operator=(const PCUIF__rts__req_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__rts__req_template::match(const PCUIF__rts__req& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sapi().is_bound()) return FALSE;
if(!single_value->field_sapi.match(other_value.sapi(), legacy))return FALSE;
if(!other_value.spare().is_bound()) return FALSE;
if(!single_value->field_spare.match(other_value.spare(), legacy))return FALSE;
if(!other_value.fn().is_bound()) return FALSE;
if(!single_value->field_fn.match(other_value.fn(), legacy))return FALSE;
if(!other_value.arfcn().is_bound()) return FALSE;
if(!single_value->field_arfcn.match(other_value.arfcn(), legacy))return FALSE;
if(!other_value.trx__nr().is_bound()) return FALSE;
if(!single_value->field_trx__nr.match(other_value.trx__nr(), legacy))return FALSE;
if(!other_value.ts__nr().is_bound()) return FALSE;
if(!single_value->field_ts__nr.match(other_value.ts__nr(), legacy))return FALSE;
if(!other_value.block__nr().is_bound()) return FALSE;
if(!single_value->field_block__nr.match(other_value.block__nr(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rts_req.");
}
return FALSE;
}

boolean PCUIF__rts__req_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sapi.is_bound()) return TRUE;
if (single_value->field_spare.is_bound()) return TRUE;
if (single_value->field_fn.is_bound()) return TRUE;
if (single_value->field_arfcn.is_bound()) return TRUE;
if (single_value->field_trx__nr.is_bound()) return TRUE;
if (single_value->field_ts__nr.is_bound()) return TRUE;
if (single_value->field_block__nr.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__rts__req_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sapi.is_value()) return FALSE;
if (!single_value->field_spare.is_value()) return FALSE;
if (!single_value->field_fn.is_value()) return FALSE;
if (!single_value->field_arfcn.is_value()) return FALSE;
if (!single_value->field_trx__nr.is_value()) return FALSE;
if (!single_value->field_ts__nr.is_value()) return FALSE;
if (!single_value->field_block__nr.is_value()) return FALSE;
return TRUE;
}

void PCUIF__rts__req_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__rts__req PCUIF__rts__req_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
PCUIF__rts__req ret_val;
if (single_value->field_sapi.is_bound()) {
ret_val.sapi() = single_value->field_sapi.valueof();
}
if (single_value->field_spare.is_bound()) {
ret_val.spare() = single_value->field_spare.valueof();
}
if (single_value->field_fn.is_bound()) {
ret_val.fn() = single_value->field_fn.valueof();
}
if (single_value->field_arfcn.is_bound()) {
ret_val.arfcn() = single_value->field_arfcn.valueof();
}
if (single_value->field_trx__nr.is_bound()) {
ret_val.trx__nr() = single_value->field_trx__nr.valueof();
}
if (single_value->field_ts__nr.is_bound()) {
ret_val.ts__nr() = single_value->field_ts__nr.valueof();
}
if (single_value->field_block__nr.is_bound()) {
ret_val.block__nr() = single_value->field_block__nr.valueof();
}
return ret_val;
}

void PCUIF__rts__req_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_rts_req.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__rts__req_template[list_length];
}

PCUIF__rts__req_template& PCUIF__rts__req_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_rts_req.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_rts_req.");
return value_list.list_value[list_index];
}

PCUIF__Sapi_template& PCUIF__rts__req_template::sapi()
{
set_specific();
return single_value->field_sapi;
}

const PCUIF__Sapi_template& PCUIF__rts__req_template::sapi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sapi of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_sapi;
}

OCTETSTRING_template& PCUIF__rts__req_template::spare()
{
set_specific();
return single_value->field_spare;
}

const OCTETSTRING_template& PCUIF__rts__req_template::spare() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_spare;
}

INTEGER_template& PCUIF__rts__req_template::fn()
{
set_specific();
return single_value->field_fn;
}

const INTEGER_template& PCUIF__rts__req_template::fn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fn of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_fn;
}

INTEGER_template& PCUIF__rts__req_template::arfcn()
{
set_specific();
return single_value->field_arfcn;
}

const INTEGER_template& PCUIF__rts__req_template::arfcn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field arfcn of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_arfcn;
}

INTEGER_template& PCUIF__rts__req_template::trx__nr()
{
set_specific();
return single_value->field_trx__nr;
}

const INTEGER_template& PCUIF__rts__req_template::trx__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trx_nr of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_trx__nr;
}

INTEGER_template& PCUIF__rts__req_template::ts__nr()
{
set_specific();
return single_value->field_ts__nr;
}

const INTEGER_template& PCUIF__rts__req_template::ts__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ts_nr of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_ts__nr;
}

INTEGER_template& PCUIF__rts__req_template::block__nr()
{
set_specific();
return single_value->field_block__nr;
}

const INTEGER_template& PCUIF__rts__req_template::block__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field block_nr of a non-specific template of type @PCUIF_Types.PCUIF_rts_req.");
return single_value->field_block__nr;
}

int PCUIF__rts__req_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rts_req containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rts_req.");
  }
  return 0;
}

void PCUIF__rts__req_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log();
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log();
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log();
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log();
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__rts__req_template::log_match(const PCUIF__rts__req& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_sapi.match(match_value.sapi(), legacy)){
TTCN_Logger::log_logmatch_info(".sapi");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare.match(match_value.spare(), legacy)){
TTCN_Logger::log_logmatch_info(".spare");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_fn.match(match_value.fn(), legacy)){
TTCN_Logger::log_logmatch_info(".fn");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_arfcn.match(match_value.arfcn(), legacy)){
TTCN_Logger::log_logmatch_info(".arfcn");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trx__nr.match(match_value.trx__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".trx_nr");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ts__nr.match(match_value.ts__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".ts_nr");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_block__nr.match(match_value.block__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".block_nr");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::log_event_str(", block_nr := ");
single_value->field_block__nr.log_match(match_value.block__nr(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__rts__req_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sapi.encode_text(text_buf);
single_value->field_spare.encode_text(text_buf);
single_value->field_fn.encode_text(text_buf);
single_value->field_arfcn.encode_text(text_buf);
single_value->field_trx__nr.encode_text(text_buf);
single_value->field_ts__nr.encode_text(text_buf);
single_value->field_block__nr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rts_req.");
}
}

void PCUIF__rts__req_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sapi.decode_text(text_buf);
single_value->field_spare.decode_text(text_buf);
single_value->field_fn.decode_text(text_buf);
single_value->field_arfcn.decode_text(text_buf);
single_value->field_trx__nr.decode_text(text_buf);
single_value->field_ts__nr.decode_text(text_buf);
single_value->field_block__nr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__rts__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_rts_req.");
}
}

void PCUIF__rts__req_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__rts__req_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_rts_req has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) block__nr().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "block_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          block__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_rts_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_rts_req");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__rts__req_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sapi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_spare.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_fn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_arfcn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_trx__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_ts__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
single_value->field_block__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_rts_req");
}

boolean PCUIF__rts__req_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__rts__req_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__BurstType::PCUIF__BurstType()
{
enum_value = UNBOUND_VALUE;
}

PCUIF__BurstType::PCUIF__BurstType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @PCUIF_Types.PCUIF_BurstType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PCUIF__BurstType::PCUIF__BurstType(enum_type other_value)
{
enum_value = other_value;
}

PCUIF__BurstType::PCUIF__BurstType(const PCUIF__BurstType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
enum_value = other_value.enum_value;
}

PCUIF__BurstType& PCUIF__BurstType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_BurstType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PCUIF__BurstType& PCUIF__BurstType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PCUIF__BurstType& PCUIF__BurstType::operator=(const PCUIF__BurstType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
enum_value = other_value.enum_value;
return *this;
}

boolean PCUIF__BurstType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value == other_value;
}

boolean PCUIF__BurstType::operator==(const PCUIF__BurstType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value == other_value.enum_value;
}

boolean PCUIF__BurstType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value < other_value;
}

boolean PCUIF__BurstType::operator<(const PCUIF__BurstType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value < other_value.enum_value;
}

boolean PCUIF__BurstType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value > other_value;
}

boolean PCUIF__BurstType::operator>(const PCUIF__BurstType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value > other_value.enum_value;
}

const char *PCUIF__BurstType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case BURST__TYPE__NONE: return "BURST_TYPE_NONE";
case BURST__TYPE__0: return "BURST_TYPE_0";
case BURST__TYPE__1: return "BURST_TYPE_1";
case BURST__TYPE__2: return "BURST_TYPE_2";
default: return "<unknown>";
}
}

PCUIF__BurstType::enum_type PCUIF__BurstType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "BURST_TYPE_NONE")) return BURST__TYPE__NONE;
else if (!strcmp(str_par, "BURST_TYPE_0")) return BURST__TYPE__0;
else if (!strcmp(str_par, "BURST_TYPE_1")) return BURST__TYPE__1;
else if (!strcmp(str_par, "BURST_TYPE_2")) return BURST__TYPE__2;
else return UNKNOWN_VALUE;
}

boolean PCUIF__BurstType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int PCUIF__BurstType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_BurstType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PCUIF__BurstType::enum2int(const PCUIF__BurstType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @PCUIF_Types.PCUIF_BurstType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PCUIF__BurstType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @PCUIF_Types.PCUIF_BurstType.", int_val);
enum_value = (enum_type)int_val;
}

PCUIF__BurstType::operator PCUIF__BurstType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return enum_value;
}

void PCUIF__BurstType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PCUIF__BurstType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@PCUIF_Types.PCUIF_BurstType");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_BurstType.");
  }
}

void PCUIF__BurstType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
text_buf.push_int(enum_value);
}

void PCUIF__BurstType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @PCUIF_Types.PCUIF_BurstType.", enum_value);
}

void PCUIF__BurstType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__BurstType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__BurstType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit*)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int PCUIF__BurstType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void PCUIF__BurstType_template::copy_template(const PCUIF__BurstType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__BurstType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
}
}

PCUIF__BurstType_template::PCUIF__BurstType_template()
{
}

PCUIF__BurstType_template::PCUIF__BurstType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__BurstType_template::PCUIF__BurstType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PCUIF__BurstType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @PCUIF_Types.PCUIF_BurstType with unknown numeric value %d.", other_value);
single_value = (PCUIF__BurstType::enum_type)other_value;
}

PCUIF__BurstType_template::PCUIF__BurstType_template(PCUIF__BurstType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PCUIF__BurstType_template::PCUIF__BurstType_template(const PCUIF__BurstType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PCUIF__BurstType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType.");
single_value = other_value.enum_value;
}

PCUIF__BurstType_template::PCUIF__BurstType_template(const OPTIONAL<PCUIF__BurstType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__BurstType::enum_type)(const PCUIF__BurstType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @PCUIF_Types.PCUIF_BurstType from an unbound optional field.");
}
}

PCUIF__BurstType_template::PCUIF__BurstType_template(const PCUIF__BurstType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PCUIF__BurstType_template::~PCUIF__BurstType_template()
{
clean_up();
}

boolean PCUIF__BurstType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PCUIF__BurstType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PCUIF__BurstType::UNBOUND_VALUE;
}

void PCUIF__BurstType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(int other_value)
{
if (!PCUIF__BurstType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @PCUIF_Types.PCUIF_BurstType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__BurstType::enum_type)other_value;
return *this;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(PCUIF__BurstType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(const PCUIF__BurstType& other_value)
{
if (other_value.enum_value == PCUIF__BurstType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @PCUIF_Types.PCUIF_BurstType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(const OPTIONAL<PCUIF__BurstType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PCUIF__BurstType::enum_type)(const PCUIF__BurstType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
}
return *this;
}

PCUIF__BurstType_template& PCUIF__BurstType_template::operator=(const PCUIF__BurstType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__BurstType_template::match(PCUIF__BurstType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
}
return FALSE;
}

boolean PCUIF__BurstType_template::match(const PCUIF__BurstType& other_value, boolean) const
{
if (other_value.enum_value == PCUIF__BurstType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @PCUIF_Types.PCUIF_BurstType with an unbound value.");
return match(other_value.enum_value);
}

PCUIF__BurstType::enum_type PCUIF__BurstType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return single_value;
}

void PCUIF__BurstType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__BurstType_template[list_length];
}

PCUIF__BurstType_template& PCUIF__BurstType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
return value_list.list_value[list_index];
}

void PCUIF__BurstType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PCUIF__BurstType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__BurstType_template::log_match(const PCUIF__BurstType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PCUIF__BurstType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
}
}

void PCUIF__BurstType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PCUIF__BurstType::enum_type)text_buf.pull_int().get_val();
if (!PCUIF__BurstType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @PCUIF_Types.PCUIF_BurstType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__BurstType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @PCUIF_Types.PCUIF_BurstType.");
}
}

boolean PCUIF__BurstType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__BurstType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__BurstType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__BurstType_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PCUIF__BurstType::enum_type enum_val = PCUIF__BurstType::str_to_enum(m_p->get_enumerated());
    if (!PCUIF__BurstType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @PCUIF_Types.PCUIF_BurstType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@PCUIF_Types.PCUIF_BurstType");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__BurstType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_BurstType");
}

PCUIF__rach__ind::PCUIF__rach__ind()
{
}

PCUIF__rach__ind::PCUIF__rach__ind(const PCUIF__Sapi& par_sapi,
    const INTEGER& par_ra,
    const INTEGER& par_qta,
    const INTEGER& par_fn,
    const INTEGER& par_arfcn,
    const INTEGER& par_is__11bit,
    const PCUIF__BurstType& par_burst__type)
  :   field_sapi(par_sapi),
  field_ra(par_ra),
  field_qta(par_qta),
  field_fn(par_fn),
  field_arfcn(par_arfcn),
  field_is__11bit(par_is__11bit),
  field_burst__type(par_burst__type)
{
}

PCUIF__rach__ind::PCUIF__rach__ind(const PCUIF__rach__ind& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_rach_ind.");
if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
else field_sapi.clean_up();
if (other_value.ra().is_bound()) field_ra = other_value.ra();
else field_ra.clean_up();
if (other_value.qta().is_bound()) field_qta = other_value.qta();
else field_qta.clean_up();
if (other_value.fn().is_bound()) field_fn = other_value.fn();
else field_fn.clean_up();
if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
else field_arfcn.clean_up();
if (other_value.is__11bit().is_bound()) field_is__11bit = other_value.is__11bit();
else field_is__11bit.clean_up();
if (other_value.burst__type().is_bound()) field_burst__type = other_value.burst__type();
else field_burst__type.clean_up();
}

void PCUIF__rach__ind::clean_up()
{
field_sapi.clean_up();
field_ra.clean_up();
field_qta.clean_up();
field_fn.clean_up();
field_arfcn.clean_up();
field_is__11bit.clean_up();
field_burst__type.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__rach__ind::get_descriptor() const { return &PCUIF__rach__ind_descr_; }
PCUIF__rach__ind& PCUIF__rach__ind::operator=(const PCUIF__rach__ind& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_rach_ind.");
  if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
  else field_sapi.clean_up();
  if (other_value.ra().is_bound()) field_ra = other_value.ra();
  else field_ra.clean_up();
  if (other_value.qta().is_bound()) field_qta = other_value.qta();
  else field_qta.clean_up();
  if (other_value.fn().is_bound()) field_fn = other_value.fn();
  else field_fn.clean_up();
  if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
  else field_arfcn.clean_up();
  if (other_value.is__11bit().is_bound()) field_is__11bit = other_value.is__11bit();
  else field_is__11bit.clean_up();
  if (other_value.burst__type().is_bound()) field_burst__type = other_value.burst__type();
  else field_burst__type.clean_up();
}
return *this;
}

boolean PCUIF__rach__ind::operator==(const PCUIF__rach__ind& other_value) const
{
return field_sapi==other_value.field_sapi
  && field_ra==other_value.field_ra
  && field_qta==other_value.field_qta
  && field_fn==other_value.field_fn
  && field_arfcn==other_value.field_arfcn
  && field_is__11bit==other_value.field_is__11bit
  && field_burst__type==other_value.field_burst__type;
}

boolean PCUIF__rach__ind::is_bound() const
{
if(field_sapi.is_bound()) return TRUE;
if(field_ra.is_bound()) return TRUE;
if(field_qta.is_bound()) return TRUE;
if(field_fn.is_bound()) return TRUE;
if(field_arfcn.is_bound()) return TRUE;
if(field_is__11bit.is_bound()) return TRUE;
if(field_burst__type.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__rach__ind::is_value() const
{
if(!field_sapi.is_value()) return FALSE;
if(!field_ra.is_value()) return FALSE;
if(!field_qta.is_value()) return FALSE;
if(!field_fn.is_value()) return FALSE;
if(!field_arfcn.is_value()) return FALSE;
if(!field_is__11bit.is_value()) return FALSE;
if(!field_burst__type.is_value()) return FALSE;
return TRUE;
}
void PCUIF__rach__ind::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sapi := ");
field_sapi.log();
TTCN_Logger::log_event_str(", ra := ");
field_ra.log();
TTCN_Logger::log_event_str(", qta := ");
field_qta.log();
TTCN_Logger::log_event_str(", fn := ");
field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
field_arfcn.log();
TTCN_Logger::log_event_str(", is_11bit := ");
field_is__11bit.log();
TTCN_Logger::log_event_str(", burst_type := ");
field_burst__type.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__rach__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_rach_ind has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ra().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) qta().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) is__11bit().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) burst__type().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ra")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ra().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "qta")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          qta().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "is_11bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          is__11bit().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "burst_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          burst__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_rach_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_rach_ind");
  }
}

void PCUIF__rach__ind::set_implicit_omit()
{
if (sapi().is_bound()) sapi().set_implicit_omit();
if (ra().is_bound()) ra().set_implicit_omit();
if (qta().is_bound()) qta().set_implicit_omit();
if (fn().is_bound()) fn().set_implicit_omit();
if (arfcn().is_bound()) arfcn().set_implicit_omit();
if (is__11bit().is_bound()) is__11bit().set_implicit_omit();
if (burst__type().is_bound()) burst__type().set_implicit_omit();
}

void PCUIF__rach__ind::encode_text(Text_Buf& text_buf) const
{
field_sapi.encode_text(text_buf);
field_ra.encode_text(text_buf);
field_qta.encode_text(text_buf);
field_fn.encode_text(text_buf);
field_arfcn.encode_text(text_buf);
field_is__11bit.encode_text(text_buf);
field_burst__type.encode_text(text_buf);
}

void PCUIF__rach__ind::decode_text(Text_Buf& text_buf)
{
field_sapi.decode_text(text_buf);
field_ra.decode_text(text_buf);
field_qta.decode_text(text_buf);
field_fn.decode_text(text_buf);
field_arfcn.decode_text(text_buf);
field_is__11bit.decode_text(text_buf);
field_burst__type.decode_text(text_buf);
}

void PCUIF__rach__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__rach__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__rach__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__rach__ind_sapi_descr_.raw->forceomit);
  decoded_field_length = field_sapi.RAW_decode(PCUIF__rach__ind_sapi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__rach__ind_ra_descr_.raw->forceomit);
  decoded_field_length = field_ra.RAW_decode(PCUIF__rach__ind_ra_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__rach__ind_qta_descr_.raw->forceomit);
  decoded_field_length = field_qta.RAW_decode(PCUIF__rach__ind_qta_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__rach__ind_fn_descr_.raw->forceomit);
  decoded_field_length = field_fn.RAW_decode(PCUIF__rach__ind_fn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__rach__ind_arfcn_descr_.raw->forceomit);
  decoded_field_length = field_arfcn.RAW_decode(PCUIF__rach__ind_arfcn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__rach__ind_is__11bit_descr_.raw->forceomit);
  decoded_field_length = field_is__11bit.RAW_decode(PCUIF__rach__ind_is__11bit_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__rach__ind_burst__type_descr_.raw->forceomit);
  decoded_field_length = field_burst__type.RAW_decode(PCUIF__rach__ind_burst__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__rach__ind::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__rach__ind_sapi_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__rach__ind_ra_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__rach__ind_qta_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__rach__ind_fn_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__rach__ind_arfcn_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__rach__ind_is__11bit_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__rach__ind_burst__type_descr_.raw);
  encoded_length += field_sapi.RAW_encode(PCUIF__rach__ind_sapi_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_ra.RAW_encode(PCUIF__rach__ind_ra_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_qta.RAW_encode(PCUIF__rach__ind_qta_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_fn.RAW_encode(PCUIF__rach__ind_fn_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_arfcn.RAW_encode(PCUIF__rach__ind_arfcn_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_is__11bit.RAW_encode(PCUIF__rach__ind_is__11bit_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_burst__type.RAW_encode(PCUIF__rach__ind_burst__type_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

struct PCUIF__rach__ind_template::single_value_struct {
PCUIF__Sapi_template field_sapi;
INTEGER_template field_ra;
INTEGER_template field_qta;
INTEGER_template field_fn;
INTEGER_template field_arfcn;
INTEGER_template field_is__11bit;
PCUIF__BurstType_template field_burst__type;
};

void PCUIF__rach__ind_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sapi = ANY_VALUE;
single_value->field_ra = ANY_VALUE;
single_value->field_qta = ANY_VALUE;
single_value->field_fn = ANY_VALUE;
single_value->field_arfcn = ANY_VALUE;
single_value->field_is__11bit = ANY_VALUE;
single_value->field_burst__type = ANY_VALUE;
}
}
}

void PCUIF__rach__ind_template::copy_value(const PCUIF__rach__ind& other_value)
{
single_value = new single_value_struct;
if (other_value.sapi().is_bound()) {
  single_value->field_sapi = other_value.sapi();
} else {
  single_value->field_sapi.clean_up();
}
if (other_value.ra().is_bound()) {
  single_value->field_ra = other_value.ra();
} else {
  single_value->field_ra.clean_up();
}
if (other_value.qta().is_bound()) {
  single_value->field_qta = other_value.qta();
} else {
  single_value->field_qta.clean_up();
}
if (other_value.fn().is_bound()) {
  single_value->field_fn = other_value.fn();
} else {
  single_value->field_fn.clean_up();
}
if (other_value.arfcn().is_bound()) {
  single_value->field_arfcn = other_value.arfcn();
} else {
  single_value->field_arfcn.clean_up();
}
if (other_value.is__11bit().is_bound()) {
  single_value->field_is__11bit = other_value.is__11bit();
} else {
  single_value->field_is__11bit.clean_up();
}
if (other_value.burst__type().is_bound()) {
  single_value->field_burst__type = other_value.burst__type();
} else {
  single_value->field_burst__type.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__rach__ind_template::copy_template(const PCUIF__rach__ind_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sapi().get_selection()) {
single_value->field_sapi = other_value.sapi();
} else {
single_value->field_sapi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ra().get_selection()) {
single_value->field_ra = other_value.ra();
} else {
single_value->field_ra.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.qta().get_selection()) {
single_value->field_qta = other_value.qta();
} else {
single_value->field_qta.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.fn().get_selection()) {
single_value->field_fn = other_value.fn();
} else {
single_value->field_fn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.arfcn().get_selection()) {
single_value->field_arfcn = other_value.arfcn();
} else {
single_value->field_arfcn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.is__11bit().get_selection()) {
single_value->field_is__11bit = other_value.is__11bit();
} else {
single_value->field_is__11bit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.burst__type().get_selection()) {
single_value->field_burst__type = other_value.burst__type();
} else {
single_value->field_burst__type.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__rach__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rach_ind.");
break;
}
set_selection(other_value);
}

PCUIF__rach__ind_template::PCUIF__rach__ind_template()
{
}

PCUIF__rach__ind_template::PCUIF__rach__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__rach__ind_template::PCUIF__rach__ind_template(const PCUIF__rach__ind& other_value)
{
copy_value(other_value);
}

PCUIF__rach__ind_template::PCUIF__rach__ind_template(const OPTIONAL<PCUIF__rach__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__rach__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_rach_ind from an unbound optional field.");
}
}

PCUIF__rach__ind_template::PCUIF__rach__ind_template(const PCUIF__rach__ind_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__rach__ind_template::~PCUIF__rach__ind_template()
{
clean_up();
}

PCUIF__rach__ind_template& PCUIF__rach__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__rach__ind_template& PCUIF__rach__ind_template::operator=(const PCUIF__rach__ind& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__rach__ind_template& PCUIF__rach__ind_template::operator=(const OPTIONAL<PCUIF__rach__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__rach__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_rach_ind.");
}
return *this;
}

PCUIF__rach__ind_template& PCUIF__rach__ind_template::operator=(const PCUIF__rach__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__rach__ind_template::match(const PCUIF__rach__ind& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sapi().is_bound()) return FALSE;
if(!single_value->field_sapi.match(other_value.sapi(), legacy))return FALSE;
if(!other_value.ra().is_bound()) return FALSE;
if(!single_value->field_ra.match(other_value.ra(), legacy))return FALSE;
if(!other_value.qta().is_bound()) return FALSE;
if(!single_value->field_qta.match(other_value.qta(), legacy))return FALSE;
if(!other_value.fn().is_bound()) return FALSE;
if(!single_value->field_fn.match(other_value.fn(), legacy))return FALSE;
if(!other_value.arfcn().is_bound()) return FALSE;
if(!single_value->field_arfcn.match(other_value.arfcn(), legacy))return FALSE;
if(!other_value.is__11bit().is_bound()) return FALSE;
if(!single_value->field_is__11bit.match(other_value.is__11bit(), legacy))return FALSE;
if(!other_value.burst__type().is_bound()) return FALSE;
if(!single_value->field_burst__type.match(other_value.burst__type(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rach_ind.");
}
return FALSE;
}

boolean PCUIF__rach__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sapi.is_bound()) return TRUE;
if (single_value->field_ra.is_bound()) return TRUE;
if (single_value->field_qta.is_bound()) return TRUE;
if (single_value->field_fn.is_bound()) return TRUE;
if (single_value->field_arfcn.is_bound()) return TRUE;
if (single_value->field_is__11bit.is_bound()) return TRUE;
if (single_value->field_burst__type.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__rach__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sapi.is_value()) return FALSE;
if (!single_value->field_ra.is_value()) return FALSE;
if (!single_value->field_qta.is_value()) return FALSE;
if (!single_value->field_fn.is_value()) return FALSE;
if (!single_value->field_arfcn.is_value()) return FALSE;
if (!single_value->field_is__11bit.is_value()) return FALSE;
if (!single_value->field_burst__type.is_value()) return FALSE;
return TRUE;
}

void PCUIF__rach__ind_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__rach__ind PCUIF__rach__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
PCUIF__rach__ind ret_val;
if (single_value->field_sapi.is_bound()) {
ret_val.sapi() = single_value->field_sapi.valueof();
}
if (single_value->field_ra.is_bound()) {
ret_val.ra() = single_value->field_ra.valueof();
}
if (single_value->field_qta.is_bound()) {
ret_val.qta() = single_value->field_qta.valueof();
}
if (single_value->field_fn.is_bound()) {
ret_val.fn() = single_value->field_fn.valueof();
}
if (single_value->field_arfcn.is_bound()) {
ret_val.arfcn() = single_value->field_arfcn.valueof();
}
if (single_value->field_is__11bit.is_bound()) {
ret_val.is__11bit() = single_value->field_is__11bit.valueof();
}
if (single_value->field_burst__type.is_bound()) {
ret_val.burst__type() = single_value->field_burst__type.valueof();
}
return ret_val;
}

void PCUIF__rach__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_rach_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__rach__ind_template[list_length];
}

PCUIF__rach__ind_template& PCUIF__rach__ind_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_rach_ind.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_rach_ind.");
return value_list.list_value[list_index];
}

PCUIF__Sapi_template& PCUIF__rach__ind_template::sapi()
{
set_specific();
return single_value->field_sapi;
}

const PCUIF__Sapi_template& PCUIF__rach__ind_template::sapi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sapi of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_sapi;
}

INTEGER_template& PCUIF__rach__ind_template::ra()
{
set_specific();
return single_value->field_ra;
}

const INTEGER_template& PCUIF__rach__ind_template::ra() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ra of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_ra;
}

INTEGER_template& PCUIF__rach__ind_template::qta()
{
set_specific();
return single_value->field_qta;
}

const INTEGER_template& PCUIF__rach__ind_template::qta() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field qta of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_qta;
}

INTEGER_template& PCUIF__rach__ind_template::fn()
{
set_specific();
return single_value->field_fn;
}

const INTEGER_template& PCUIF__rach__ind_template::fn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fn of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_fn;
}

INTEGER_template& PCUIF__rach__ind_template::arfcn()
{
set_specific();
return single_value->field_arfcn;
}

const INTEGER_template& PCUIF__rach__ind_template::arfcn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field arfcn of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_arfcn;
}

INTEGER_template& PCUIF__rach__ind_template::is__11bit()
{
set_specific();
return single_value->field_is__11bit;
}

const INTEGER_template& PCUIF__rach__ind_template::is__11bit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field is_11bit of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_is__11bit;
}

PCUIF__BurstType_template& PCUIF__rach__ind_template::burst__type()
{
set_specific();
return single_value->field_burst__type;
}

const PCUIF__BurstType_template& PCUIF__rach__ind_template::burst__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field burst_type of a non-specific template of type @PCUIF_Types.PCUIF_rach_ind.");
return single_value->field_burst__type;
}

int PCUIF__rach__ind_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_rach_ind containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rach_ind.");
  }
  return 0;
}

void PCUIF__rach__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log();
TTCN_Logger::log_event_str(", ra := ");
single_value->field_ra.log();
TTCN_Logger::log_event_str(", qta := ");
single_value->field_qta.log();
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log();
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log();
TTCN_Logger::log_event_str(", is_11bit := ");
single_value->field_is__11bit.log();
TTCN_Logger::log_event_str(", burst_type := ");
single_value->field_burst__type.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__rach__ind_template::log_match(const PCUIF__rach__ind& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_sapi.match(match_value.sapi(), legacy)){
TTCN_Logger::log_logmatch_info(".sapi");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ra.match(match_value.ra(), legacy)){
TTCN_Logger::log_logmatch_info(".ra");
single_value->field_ra.log_match(match_value.ra(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_qta.match(match_value.qta(), legacy)){
TTCN_Logger::log_logmatch_info(".qta");
single_value->field_qta.log_match(match_value.qta(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_fn.match(match_value.fn(), legacy)){
TTCN_Logger::log_logmatch_info(".fn");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_arfcn.match(match_value.arfcn(), legacy)){
TTCN_Logger::log_logmatch_info(".arfcn");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_is__11bit.match(match_value.is__11bit(), legacy)){
TTCN_Logger::log_logmatch_info(".is_11bit");
single_value->field_is__11bit.log_match(match_value.is__11bit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_burst__type.match(match_value.burst__type(), legacy)){
TTCN_Logger::log_logmatch_info(".burst_type");
single_value->field_burst__type.log_match(match_value.burst__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::log_event_str(", ra := ");
single_value->field_ra.log_match(match_value.ra(), legacy);
TTCN_Logger::log_event_str(", qta := ");
single_value->field_qta.log_match(match_value.qta(), legacy);
TTCN_Logger::log_event_str(", fn := ");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::log_event_str(", arfcn := ");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::log_event_str(", is_11bit := ");
single_value->field_is__11bit.log_match(match_value.is__11bit(), legacy);
TTCN_Logger::log_event_str(", burst_type := ");
single_value->field_burst__type.log_match(match_value.burst__type(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__rach__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sapi.encode_text(text_buf);
single_value->field_ra.encode_text(text_buf);
single_value->field_qta.encode_text(text_buf);
single_value->field_fn.encode_text(text_buf);
single_value->field_arfcn.encode_text(text_buf);
single_value->field_is__11bit.encode_text(text_buf);
single_value->field_burst__type.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_rach_ind.");
}
}

void PCUIF__rach__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sapi.decode_text(text_buf);
single_value->field_ra.decode_text(text_buf);
single_value->field_qta.decode_text(text_buf);
single_value->field_fn.decode_text(text_buf);
single_value->field_arfcn.decode_text(text_buf);
single_value->field_is__11bit.decode_text(text_buf);
single_value->field_burst__type.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__rach__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_rach_ind.");
}
}

void PCUIF__rach__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__rach__ind_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_rach_ind has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ra().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) qta().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) is__11bit().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) burst__type().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ra")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ra().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "qta")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          qta().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "is_11bit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          is__11bit().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "burst_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          burst__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_rach_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_rach_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__rach__ind_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sapi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_ra.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_qta.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_fn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_arfcn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_is__11bit.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
single_value->field_burst__type.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_rach_ind");
}

boolean PCUIF__rach__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__rach__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__InfoTrx::PCUIF__InfoTrx()
{
}

PCUIF__InfoTrx::PCUIF__InfoTrx(const INTEGER& par_arfcn,
    const BITSTRING& par_pdch__mask,
    const OCTETSTRING& par_spare,
    const OCTETSTRING& par_tsc,
    const INTEGER& par_hLayer1)
  :   field_arfcn(par_arfcn),
  field_pdch__mask(par_pdch__mask),
  field_spare(par_spare),
  field_tsc(par_tsc),
  field_hLayer1(par_hLayer1)
{
}

PCUIF__InfoTrx::PCUIF__InfoTrx(const PCUIF__InfoTrx& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_InfoTrx.");
if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
else field_arfcn.clean_up();
if (other_value.pdch__mask().is_bound()) field_pdch__mask = other_value.pdch__mask();
else field_pdch__mask.clean_up();
if (other_value.spare().is_bound()) field_spare = other_value.spare();
else field_spare.clean_up();
if (other_value.tsc().is_bound()) field_tsc = other_value.tsc();
else field_tsc.clean_up();
if (other_value.hLayer1().is_bound()) field_hLayer1 = other_value.hLayer1();
else field_hLayer1.clean_up();
}

void PCUIF__InfoTrx::clean_up()
{
field_arfcn.clean_up();
field_pdch__mask.clean_up();
field_spare.clean_up();
field_tsc.clean_up();
field_hLayer1.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__InfoTrx::get_descriptor() const { return &PCUIF__InfoTrx_descr_; }
PCUIF__InfoTrx& PCUIF__InfoTrx::operator=(const PCUIF__InfoTrx& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_InfoTrx.");
  if (other_value.arfcn().is_bound()) field_arfcn = other_value.arfcn();
  else field_arfcn.clean_up();
  if (other_value.pdch__mask().is_bound()) field_pdch__mask = other_value.pdch__mask();
  else field_pdch__mask.clean_up();
  if (other_value.spare().is_bound()) field_spare = other_value.spare();
  else field_spare.clean_up();
  if (other_value.tsc().is_bound()) field_tsc = other_value.tsc();
  else field_tsc.clean_up();
  if (other_value.hLayer1().is_bound()) field_hLayer1 = other_value.hLayer1();
  else field_hLayer1.clean_up();
}
return *this;
}

boolean PCUIF__InfoTrx::operator==(const PCUIF__InfoTrx& other_value) const
{
return field_arfcn==other_value.field_arfcn
  && field_pdch__mask==other_value.field_pdch__mask
  && field_spare==other_value.field_spare
  && field_tsc==other_value.field_tsc
  && field_hLayer1==other_value.field_hLayer1;
}

boolean PCUIF__InfoTrx::is_bound() const
{
if(field_arfcn.is_bound()) return TRUE;
if(field_pdch__mask.is_bound()) return TRUE;
if(field_spare.is_bound()) return TRUE;
if(field_tsc.is_bound()) return TRUE;
if(field_hLayer1.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__InfoTrx::is_value() const
{
if(!field_arfcn.is_value()) return FALSE;
if(!field_pdch__mask.is_value()) return FALSE;
if(!field_spare.is_value()) return FALSE;
if(!field_tsc.is_value()) return FALSE;
if(!field_hLayer1.is_value()) return FALSE;
return TRUE;
}
void PCUIF__InfoTrx::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ arfcn := ");
field_arfcn.log();
TTCN_Logger::log_event_str(", pdch_mask := ");
field_pdch__mask.log();
TTCN_Logger::log_event_str(", spare := ");
field_spare.log();
TTCN_Logger::log_event_str(", tsc := ");
field_tsc.log();
TTCN_Logger::log_event_str(", hLayer1 := ");
field_hLayer1.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__InfoTrx::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_InfoTrx has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pdch__mask().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tsc().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) hLayer1().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pdch_mask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pdch__mask().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tsc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tsc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hLayer1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hLayer1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_InfoTrx: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_InfoTrx");
  }
}

void PCUIF__InfoTrx::set_implicit_omit()
{
if (arfcn().is_bound()) arfcn().set_implicit_omit();
if (pdch__mask().is_bound()) pdch__mask().set_implicit_omit();
if (spare().is_bound()) spare().set_implicit_omit();
if (tsc().is_bound()) tsc().set_implicit_omit();
if (hLayer1().is_bound()) hLayer1().set_implicit_omit();
}

void PCUIF__InfoTrx::encode_text(Text_Buf& text_buf) const
{
field_arfcn.encode_text(text_buf);
field_pdch__mask.encode_text(text_buf);
field_spare.encode_text(text_buf);
field_tsc.encode_text(text_buf);
field_hLayer1.encode_text(text_buf);
}

void PCUIF__InfoTrx::decode_text(Text_Buf& text_buf)
{
field_arfcn.decode_text(text_buf);
field_pdch__mask.decode_text(text_buf);
field_spare.decode_text(text_buf);
field_tsc.decode_text(text_buf);
field_hLayer1.decode_text(text_buf);
}

void PCUIF__InfoTrx::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__InfoTrx::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__InfoTrx::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__InfoTrx_arfcn_descr_.raw->forceomit);
  decoded_field_length = field_arfcn.RAW_decode(PCUIF__InfoTrx_arfcn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__InfoTrx_pdch__mask_descr_.raw->forceomit);
  decoded_field_length = field_pdch__mask.RAW_decode(PCUIF__InfoTrx_pdch__mask_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__InfoTrx_spare_descr_.raw->forceomit);
  decoded_field_length = field_spare.RAW_decode(PCUIF__InfoTrx_spare_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__InfoTrx_tsc_descr_.raw->forceomit);
  decoded_field_length = field_tsc.RAW_decode(PCUIF__InfoTrx_tsc_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__InfoTrx_hLayer1_descr_.raw->forceomit);
  decoded_field_length = field_hLayer1.RAW_decode(PCUIF__InfoTrx_hLayer1_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__InfoTrx::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__InfoTrx_arfcn_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__InfoTrx_pdch__mask_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__InfoTrx_spare_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__InfoTrx_tsc_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__InfoTrx_hLayer1_descr_.raw);
  encoded_length += field_arfcn.RAW_encode(PCUIF__InfoTrx_arfcn_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_pdch__mask.RAW_encode(PCUIF__InfoTrx_pdch__mask_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_spare.RAW_encode(PCUIF__InfoTrx_spare_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_tsc.RAW_encode(PCUIF__InfoTrx_tsc_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_hLayer1.RAW_encode(PCUIF__InfoTrx_hLayer1_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

struct PCUIF__InfoTrx_template::single_value_struct {
INTEGER_template field_arfcn;
BITSTRING_template field_pdch__mask;
OCTETSTRING_template field_spare;
OCTETSTRING_template field_tsc;
INTEGER_template field_hLayer1;
};

void PCUIF__InfoTrx_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_arfcn = ANY_VALUE;
single_value->field_pdch__mask = ANY_VALUE;
single_value->field_spare = ANY_VALUE;
single_value->field_tsc = ANY_VALUE;
single_value->field_hLayer1 = ANY_VALUE;
}
}
}

void PCUIF__InfoTrx_template::copy_value(const PCUIF__InfoTrx& other_value)
{
single_value = new single_value_struct;
if (other_value.arfcn().is_bound()) {
  single_value->field_arfcn = other_value.arfcn();
} else {
  single_value->field_arfcn.clean_up();
}
if (other_value.pdch__mask().is_bound()) {
  single_value->field_pdch__mask = other_value.pdch__mask();
} else {
  single_value->field_pdch__mask.clean_up();
}
if (other_value.spare().is_bound()) {
  single_value->field_spare = other_value.spare();
} else {
  single_value->field_spare.clean_up();
}
if (other_value.tsc().is_bound()) {
  single_value->field_tsc = other_value.tsc();
} else {
  single_value->field_tsc.clean_up();
}
if (other_value.hLayer1().is_bound()) {
  single_value->field_hLayer1 = other_value.hLayer1();
} else {
  single_value->field_hLayer1.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__InfoTrx_template::copy_template(const PCUIF__InfoTrx_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.arfcn().get_selection()) {
single_value->field_arfcn = other_value.arfcn();
} else {
single_value->field_arfcn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pdch__mask().get_selection()) {
single_value->field_pdch__mask = other_value.pdch__mask();
} else {
single_value->field_pdch__mask.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare().get_selection()) {
single_value->field_spare = other_value.spare();
} else {
single_value->field_spare.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tsc().get_selection()) {
single_value->field_tsc = other_value.tsc();
} else {
single_value->field_tsc.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hLayer1().get_selection()) {
single_value->field_hLayer1 = other_value.hLayer1();
} else {
single_value->field_hLayer1.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__InfoTrx_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrx.");
break;
}
set_selection(other_value);
}

PCUIF__InfoTrx_template::PCUIF__InfoTrx_template()
{
}

PCUIF__InfoTrx_template::PCUIF__InfoTrx_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__InfoTrx_template::PCUIF__InfoTrx_template(const PCUIF__InfoTrx& other_value)
{
copy_value(other_value);
}

PCUIF__InfoTrx_template::PCUIF__InfoTrx_template(const OPTIONAL<PCUIF__InfoTrx>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__InfoTrx&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_InfoTrx from an unbound optional field.");
}
}

PCUIF__InfoTrx_template::PCUIF__InfoTrx_template(const PCUIF__InfoTrx_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__InfoTrx_template::~PCUIF__InfoTrx_template()
{
clean_up();
}

PCUIF__InfoTrx_template& PCUIF__InfoTrx_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__InfoTrx_template& PCUIF__InfoTrx_template::operator=(const PCUIF__InfoTrx& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__InfoTrx_template& PCUIF__InfoTrx_template::operator=(const OPTIONAL<PCUIF__InfoTrx>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__InfoTrx&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_InfoTrx.");
}
return *this;
}

PCUIF__InfoTrx_template& PCUIF__InfoTrx_template::operator=(const PCUIF__InfoTrx_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__InfoTrx_template::match(const PCUIF__InfoTrx& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.arfcn().is_bound()) return FALSE;
if(!single_value->field_arfcn.match(other_value.arfcn(), legacy))return FALSE;
if(!other_value.pdch__mask().is_bound()) return FALSE;
if(!single_value->field_pdch__mask.match(other_value.pdch__mask(), legacy))return FALSE;
if(!other_value.spare().is_bound()) return FALSE;
if(!single_value->field_spare.match(other_value.spare(), legacy))return FALSE;
if(!other_value.tsc().is_bound()) return FALSE;
if(!single_value->field_tsc.match(other_value.tsc(), legacy))return FALSE;
if(!other_value.hLayer1().is_bound()) return FALSE;
if(!single_value->field_hLayer1.match(other_value.hLayer1(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrx.");
}
return FALSE;
}

boolean PCUIF__InfoTrx_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_arfcn.is_bound()) return TRUE;
if (single_value->field_pdch__mask.is_bound()) return TRUE;
if (single_value->field_spare.is_bound()) return TRUE;
if (single_value->field_tsc.is_bound()) return TRUE;
if (single_value->field_hLayer1.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__InfoTrx_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_arfcn.is_value()) return FALSE;
if (!single_value->field_pdch__mask.is_value()) return FALSE;
if (!single_value->field_spare.is_value()) return FALSE;
if (!single_value->field_tsc.is_value()) return FALSE;
if (!single_value->field_hLayer1.is_value()) return FALSE;
return TRUE;
}

void PCUIF__InfoTrx_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__InfoTrx PCUIF__InfoTrx_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
PCUIF__InfoTrx ret_val;
if (single_value->field_arfcn.is_bound()) {
ret_val.arfcn() = single_value->field_arfcn.valueof();
}
if (single_value->field_pdch__mask.is_bound()) {
ret_val.pdch__mask() = single_value->field_pdch__mask.valueof();
}
if (single_value->field_spare.is_bound()) {
ret_val.spare() = single_value->field_spare.valueof();
}
if (single_value->field_tsc.is_bound()) {
ret_val.tsc() = single_value->field_tsc.valueof();
}
if (single_value->field_hLayer1.is_bound()) {
ret_val.hLayer1() = single_value->field_hLayer1.valueof();
}
return ret_val;
}

void PCUIF__InfoTrx_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_InfoTrx.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__InfoTrx_template[list_length];
}

PCUIF__InfoTrx_template& PCUIF__InfoTrx_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_InfoTrx.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_InfoTrx.");
return value_list.list_value[list_index];
}

INTEGER_template& PCUIF__InfoTrx_template::arfcn()
{
set_specific();
return single_value->field_arfcn;
}

const INTEGER_template& PCUIF__InfoTrx_template::arfcn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field arfcn of a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
return single_value->field_arfcn;
}

BITSTRING_template& PCUIF__InfoTrx_template::pdch__mask()
{
set_specific();
return single_value->field_pdch__mask;
}

const BITSTRING_template& PCUIF__InfoTrx_template::pdch__mask() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pdch_mask of a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
return single_value->field_pdch__mask;
}

OCTETSTRING_template& PCUIF__InfoTrx_template::spare()
{
set_specific();
return single_value->field_spare;
}

const OCTETSTRING_template& PCUIF__InfoTrx_template::spare() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare of a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
return single_value->field_spare;
}

OCTETSTRING_template& PCUIF__InfoTrx_template::tsc()
{
set_specific();
return single_value->field_tsc;
}

const OCTETSTRING_template& PCUIF__InfoTrx_template::tsc() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tsc of a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
return single_value->field_tsc;
}

INTEGER_template& PCUIF__InfoTrx_template::hLayer1()
{
set_specific();
return single_value->field_hLayer1;
}

const INTEGER_template& PCUIF__InfoTrx_template::hLayer1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hLayer1 of a non-specific template of type @PCUIF_Types.PCUIF_InfoTrx.");
return single_value->field_hLayer1;
}

int PCUIF__InfoTrx_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrx containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrx.");
  }
  return 0;
}

void PCUIF__InfoTrx_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ arfcn := ");
single_value->field_arfcn.log();
TTCN_Logger::log_event_str(", pdch_mask := ");
single_value->field_pdch__mask.log();
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log();
TTCN_Logger::log_event_str(", tsc := ");
single_value->field_tsc.log();
TTCN_Logger::log_event_str(", hLayer1 := ");
single_value->field_hLayer1.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__InfoTrx_template::log_match(const PCUIF__InfoTrx& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_arfcn.match(match_value.arfcn(), legacy)){
TTCN_Logger::log_logmatch_info(".arfcn");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_pdch__mask.match(match_value.pdch__mask(), legacy)){
TTCN_Logger::log_logmatch_info(".pdch_mask");
single_value->field_pdch__mask.log_match(match_value.pdch__mask(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare.match(match_value.spare(), legacy)){
TTCN_Logger::log_logmatch_info(".spare");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tsc.match(match_value.tsc(), legacy)){
TTCN_Logger::log_logmatch_info(".tsc");
single_value->field_tsc.log_match(match_value.tsc(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hLayer1.match(match_value.hLayer1(), legacy)){
TTCN_Logger::log_logmatch_info(".hLayer1");
single_value->field_hLayer1.log_match(match_value.hLayer1(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ arfcn := ");
single_value->field_arfcn.log_match(match_value.arfcn(), legacy);
TTCN_Logger::log_event_str(", pdch_mask := ");
single_value->field_pdch__mask.log_match(match_value.pdch__mask(), legacy);
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::log_event_str(", tsc := ");
single_value->field_tsc.log_match(match_value.tsc(), legacy);
TTCN_Logger::log_event_str(", hLayer1 := ");
single_value->field_hLayer1.log_match(match_value.hLayer1(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__InfoTrx_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_arfcn.encode_text(text_buf);
single_value->field_pdch__mask.encode_text(text_buf);
single_value->field_spare.encode_text(text_buf);
single_value->field_tsc.encode_text(text_buf);
single_value->field_hLayer1.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrx.");
}
}

void PCUIF__InfoTrx_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_arfcn.decode_text(text_buf);
single_value->field_pdch__mask.decode_text(text_buf);
single_value->field_spare.decode_text(text_buf);
single_value->field_tsc.decode_text(text_buf);
single_value->field_hLayer1.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__InfoTrx_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_InfoTrx.");
}
}

void PCUIF__InfoTrx_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__InfoTrx_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_InfoTrx has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) arfcn().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pdch__mask().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tsc().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) hLayer1().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "arfcn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          arfcn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pdch_mask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pdch__mask().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tsc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tsc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hLayer1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hLayer1().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_InfoTrx: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_InfoTrx");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__InfoTrx_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_arfcn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
single_value->field_pdch__mask.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
single_value->field_spare.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
single_value->field_tsc.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
single_value->field_hLayer1.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrx");
}

boolean PCUIF__InfoTrx_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__InfoTrx_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const PCUIF__InfoTrx PCUIF__InfoTrxs::UNBOUND_ELEM;
PCUIF__InfoTrxs::PCUIF__InfoTrxs()
{
val_ptr = NULL;
}

PCUIF__InfoTrxs::PCUIF__InfoTrxs(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PCUIF__InfoTrxs::PCUIF__InfoTrxs(const PCUIF__InfoTrxs& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PCUIF__InfoTrxs::~PCUIF__InfoTrxs()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PCUIF__InfoTrxs::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PCUIF__InfoTrxs& PCUIF__InfoTrxs::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PCUIF__InfoTrxs& PCUIF__InfoTrxs::operator=(const PCUIF__InfoTrxs& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PCUIF__InfoTrxs::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
return val_ptr->n_elements == 0 ;
}

boolean PCUIF__InfoTrxs::operator==(const PCUIF__InfoTrxs& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

PCUIF__InfoTrx& PCUIF__InfoTrxs::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @PCUIF_Types.PCUIF_InfoTrxs using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (PCUIF__InfoTrx**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PCUIF__InfoTrx(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new PCUIF__InfoTrx;
}
return *val_ptr->value_elements[index_value];
}

PCUIF__InfoTrx& PCUIF__InfoTrxs::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @PCUIF_Types.PCUIF_InfoTrxs.");
return (*this)[(int)index_value];
}

const PCUIF__InfoTrx& PCUIF__InfoTrxs::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (index_value < 0) TTCN_error("Accessing an element of type @PCUIF_Types.PCUIF_InfoTrxs using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @PCUIF_Types.PCUIF_InfoTrxs: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] == NULL) ?
UNBOUND_ELEM : *val_ptr->value_elements[index_value];
}

const PCUIF__InfoTrx& PCUIF__InfoTrxs::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @PCUIF_Types.PCUIF_InfoTrxs.");
return (*this)[(int)index_value];
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PCUIF__InfoTrxs ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new PCUIF__InfoTrx(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::operator+(const PCUIF__InfoTrxs& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @PCUIF_Types.PCUIF_InfoTrxs concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PCUIF__InfoTrxs ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PCUIF__InfoTrx(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new PCUIF__InfoTrx(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@PCUIF_Types.PCUIF_InfoTrxs","element");
PCUIF__InfoTrxs ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new PCUIF__InfoTrx(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::replace(int index, int len, const PCUIF__InfoTrxs& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
check_replace_arguments(val_ptr->n_elements, index, len, "@PCUIF_Types.PCUIF_InfoTrxs","element");
PCUIF__InfoTrxs ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PCUIF__InfoTrx(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new PCUIF__InfoTrx(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new PCUIF__InfoTrx(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs::replace(int index, int len, const PCUIF__InfoTrxs_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PCUIF__InfoTrxs::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (PCUIF__InfoTrx**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PCUIF__InfoTrx(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (PCUIF__InfoTrx**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @PCUIF_Types.PCUIF_InfoTrxs: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (PCUIF__InfoTrx**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PCUIF__InfoTrxs::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PCUIF__InfoTrxs::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
return val_ptr->n_elements;
}

int PCUIF__InfoTrxs::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PCUIF__InfoTrxs::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PCUIF__InfoTrxs::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@PCUIF_Types.PCUIF_InfoTrxs");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@PCUIF_Types.PCUIF_InfoTrxs");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void PCUIF__InfoTrxs::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PCUIF__InfoTrxs::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PCUIF__InfoTrxs::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @PCUIF_Types.PCUIF_InfoTrxs.");
val_ptr->value_elements = (PCUIF__InfoTrx**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new PCUIF__InfoTrx;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PCUIF__InfoTrxs::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__InfoTrxs::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__InfoTrxs::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call, const RAW_Force_Omit*){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    int a=start_field;
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int PCUIF__InfoTrxs::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void PCUIF__InfoTrxs_template::copy_value(const PCUIF__InfoTrxs& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @PCUIF_Types.PCUIF_InfoTrxs with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (PCUIF__InfoTrx_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__InfoTrxs_template::copy_template(const PCUIF__InfoTrxs_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (PCUIF__InfoTrx_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__InfoTrxs_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrxs.");
break;
}
set_selection(other_value);
}

boolean PCUIF__InfoTrxs_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PCUIF__InfoTrxs_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PCUIF__InfoTrxs*)value_ptr)[value_index], legacy);
else return ((const PCUIF__InfoTrxs_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template()
{
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template(const PCUIF__InfoTrxs& other_value)
{
copy_value(other_value);
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template(const OPTIONAL<PCUIF__InfoTrxs>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__InfoTrxs&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_InfoTrxs from an unbound optional field.");
}
}

PCUIF__InfoTrxs_template::PCUIF__InfoTrxs_template(const PCUIF__InfoTrxs_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

PCUIF__InfoTrxs_template::~PCUIF__InfoTrxs_template()
{
clean_up();
}

void PCUIF__InfoTrxs_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::operator=(const PCUIF__InfoTrxs& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::operator=(const OPTIONAL<PCUIF__InfoTrxs>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__InfoTrxs&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
}
return *this;
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::operator=(const PCUIF__InfoTrxs_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

PCUIF__InfoTrx_template& PCUIF__InfoTrxs_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @PCUIF_Types.PCUIF_InfoTrxs using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @PCUIF_Types.PCUIF_InfoTrxs.");
    break;
}
return *single_value.value_elements[index_value];
}

PCUIF__InfoTrx_template& PCUIF__InfoTrxs_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
return (*this)[(int)index_value];
}

const PCUIF__InfoTrx_template& PCUIF__InfoTrxs_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @PCUIF_Types.PCUIF_InfoTrxs using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @PCUIF_Types.PCUIF_InfoTrxs.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @PCUIF_Types.PCUIF_InfoTrxs: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const PCUIF__InfoTrx_template& PCUIF__InfoTrxs_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
return (*this)[(int)index_value];
}

void PCUIF__InfoTrxs_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (PCUIF__InfoTrx_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (PCUIF__InfoTrx_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PCUIF__InfoTrxs_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PCUIF__InfoTrxs_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @PCUIF_Types.PCUIF_InfoTrxs containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrxs.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @PCUIF_Types.PCUIF_InfoTrxs");
}

boolean PCUIF__InfoTrxs_template::match(const PCUIF__InfoTrxs& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrxs.");
}
return FALSE;
}

boolean PCUIF__InfoTrxs_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_InfoTrxs.");
PCUIF__InfoTrxs ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PCUIF__InfoTrxs PCUIF__InfoTrxs_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PCUIF__InfoTrxs PCUIF__InfoTrxs_template::replace(int index, int len, const PCUIF__InfoTrxs_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PCUIF__InfoTrxs PCUIF__InfoTrxs_template::replace(int index, int len, const PCUIF__InfoTrxs& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PCUIF__InfoTrxs_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PCUIF__InfoTrxs_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
}
set_selection(template_type);
}

PCUIF__InfoTrxs_template& PCUIF__InfoTrxs_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_InfoTrxs.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @PCUIF_Types.PCUIF_InfoTrxs.");
return value_list.list_value[list_index];
}

void PCUIF__InfoTrxs_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PCUIF__InfoTrxs_template::log_match(const PCUIF__InfoTrxs& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__InfoTrxs_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_InfoTrxs.");
}
}

void PCUIF__InfoTrxs_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
single_value.value_elements = (PCUIF__InfoTrx_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new PCUIF__InfoTrx_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__InfoTrxs_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @PCUIF_Types.PCUIF_InfoTrxs.");
}
}

boolean PCUIF__InfoTrxs_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__InfoTrxs_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__InfoTrxs_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__InfoTrxs_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        Module_Param* param_i = param.get_elem(p_i);
        for (size_t perm_i=0; perm_i<param_i->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param_i->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@PCUIF_Types.PCUIF_InfoTrxs");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void PCUIF__InfoTrxs_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrxs");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_InfoTrxs");
}

boolean PCUIF__InfoTrxs_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
PCUIF__info__ind::PCUIF__info__ind()
{
}

PCUIF__info__ind::PCUIF__info__ind(const INTEGER& par_version,
    const PCUIF__Flags& par_flags,
    const PCUIF__InfoTrxs& par_trx,
    const INTEGER& par_bsic,
    const INTEGER& par_mcc,
    const INTEGER& par_mnc,
    const INTEGER& par_mnc__3__digits,
    const INTEGER& par_lac,
    const INTEGER& par_rac,
    const INTEGER& par_nsei,
    const PCUIF__info__ind_nse__timer& par_nse__timer,
    const PCUIF__info__ind_cell__timer& par_cell__timer,
    const INTEGER& par_cell__id,
    const INTEGER& par_repeat__time,
    const INTEGER& par_repeat__count,
    const INTEGER& par_bvci,
    const INTEGER& par_t3142,
    const INTEGER& par_t3169,
    const INTEGER& par_t3191,
    const INTEGER& par_t3193__10ms,
    const INTEGER& par_t3195,
    const INTEGER& par_t3101,
    const INTEGER& par_t3103,
    const INTEGER& par_t3105,
    const INTEGER& par_cv__countdown,
    const INTEGER& par_dl__tbf__ext,
    const INTEGER& par_ul__tbf__ext,
    const INTEGER& par_initial__cs,
    const INTEGER& par_initial__mcs,
    const PCUIF__info__ind_nsvci& par_nsvci,
    const PCUIF__info__ind_local__pprt& par_local__pprt,
    const PCUIF__info__ind_remote__port& par_remote__port,
    const PCUIF__info__ind_remote__ip& par_remote__ip)
  :   field_version(par_version),
  field_flags(par_flags),
  field_trx(par_trx),
  field_bsic(par_bsic),
  field_mcc(par_mcc),
  field_mnc(par_mnc),
  field_mnc__3__digits(par_mnc__3__digits),
  field_lac(par_lac),
  field_rac(par_rac),
  field_nsei(par_nsei),
  field_nse__timer(par_nse__timer),
  field_cell__timer(par_cell__timer),
  field_cell__id(par_cell__id),
  field_repeat__time(par_repeat__time),
  field_repeat__count(par_repeat__count),
  field_bvci(par_bvci),
  field_t3142(par_t3142),
  field_t3169(par_t3169),
  field_t3191(par_t3191),
  field_t3193__10ms(par_t3193__10ms),
  field_t3195(par_t3195),
  field_t3101(par_t3101),
  field_t3103(par_t3103),
  field_t3105(par_t3105),
  field_cv__countdown(par_cv__countdown),
  field_dl__tbf__ext(par_dl__tbf__ext),
  field_ul__tbf__ext(par_ul__tbf__ext),
  field_initial__cs(par_initial__cs),
  field_initial__mcs(par_initial__mcs),
  field_nsvci(par_nsvci),
  field_local__pprt(par_local__pprt),
  field_remote__port(par_remote__port),
  field_remote__ip(par_remote__ip)
{
}

PCUIF__info__ind::PCUIF__info__ind(const PCUIF__info__ind& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_info_ind.");
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.flags().is_bound()) field_flags = other_value.flags();
else field_flags.clean_up();
if (other_value.trx().is_bound()) field_trx = other_value.trx();
else field_trx.clean_up();
if (other_value.bsic().is_bound()) field_bsic = other_value.bsic();
else field_bsic.clean_up();
if (other_value.mcc().is_bound()) field_mcc = other_value.mcc();
else field_mcc.clean_up();
if (other_value.mnc().is_bound()) field_mnc = other_value.mnc();
else field_mnc.clean_up();
if (other_value.mnc__3__digits().is_bound()) field_mnc__3__digits = other_value.mnc__3__digits();
else field_mnc__3__digits.clean_up();
if (other_value.lac().is_bound()) field_lac = other_value.lac();
else field_lac.clean_up();
if (other_value.rac().is_bound()) field_rac = other_value.rac();
else field_rac.clean_up();
if (other_value.nsei().is_bound()) field_nsei = other_value.nsei();
else field_nsei.clean_up();
if (other_value.nse__timer().is_bound()) field_nse__timer = other_value.nse__timer();
else field_nse__timer.clean_up();
if (other_value.cell__timer().is_bound()) field_cell__timer = other_value.cell__timer();
else field_cell__timer.clean_up();
if (other_value.cell__id().is_bound()) field_cell__id = other_value.cell__id();
else field_cell__id.clean_up();
if (other_value.repeat__time().is_bound()) field_repeat__time = other_value.repeat__time();
else field_repeat__time.clean_up();
if (other_value.repeat__count().is_bound()) field_repeat__count = other_value.repeat__count();
else field_repeat__count.clean_up();
if (other_value.bvci().is_bound()) field_bvci = other_value.bvci();
else field_bvci.clean_up();
if (other_value.t3142().is_bound()) field_t3142 = other_value.t3142();
else field_t3142.clean_up();
if (other_value.t3169().is_bound()) field_t3169 = other_value.t3169();
else field_t3169.clean_up();
if (other_value.t3191().is_bound()) field_t3191 = other_value.t3191();
else field_t3191.clean_up();
if (other_value.t3193__10ms().is_bound()) field_t3193__10ms = other_value.t3193__10ms();
else field_t3193__10ms.clean_up();
if (other_value.t3195().is_bound()) field_t3195 = other_value.t3195();
else field_t3195.clean_up();
if (other_value.t3101().is_bound()) field_t3101 = other_value.t3101();
else field_t3101.clean_up();
if (other_value.t3103().is_bound()) field_t3103 = other_value.t3103();
else field_t3103.clean_up();
if (other_value.t3105().is_bound()) field_t3105 = other_value.t3105();
else field_t3105.clean_up();
if (other_value.cv__countdown().is_bound()) field_cv__countdown = other_value.cv__countdown();
else field_cv__countdown.clean_up();
if (other_value.dl__tbf__ext().is_bound()) field_dl__tbf__ext = other_value.dl__tbf__ext();
else field_dl__tbf__ext.clean_up();
if (other_value.ul__tbf__ext().is_bound()) field_ul__tbf__ext = other_value.ul__tbf__ext();
else field_ul__tbf__ext.clean_up();
if (other_value.initial__cs().is_bound()) field_initial__cs = other_value.initial__cs();
else field_initial__cs.clean_up();
if (other_value.initial__mcs().is_bound()) field_initial__mcs = other_value.initial__mcs();
else field_initial__mcs.clean_up();
if (other_value.nsvci().is_bound()) field_nsvci = other_value.nsvci();
else field_nsvci.clean_up();
if (other_value.local__pprt().is_bound()) field_local__pprt = other_value.local__pprt();
else field_local__pprt.clean_up();
if (other_value.remote__port().is_bound()) field_remote__port = other_value.remote__port();
else field_remote__port.clean_up();
if (other_value.remote__ip().is_bound()) field_remote__ip = other_value.remote__ip();
else field_remote__ip.clean_up();
}

void PCUIF__info__ind::clean_up()
{
field_version.clean_up();
field_flags.clean_up();
field_trx.clean_up();
field_bsic.clean_up();
field_mcc.clean_up();
field_mnc.clean_up();
field_mnc__3__digits.clean_up();
field_lac.clean_up();
field_rac.clean_up();
field_nsei.clean_up();
field_nse__timer.clean_up();
field_cell__timer.clean_up();
field_cell__id.clean_up();
field_repeat__time.clean_up();
field_repeat__count.clean_up();
field_bvci.clean_up();
field_t3142.clean_up();
field_t3169.clean_up();
field_t3191.clean_up();
field_t3193__10ms.clean_up();
field_t3195.clean_up();
field_t3101.clean_up();
field_t3103.clean_up();
field_t3105.clean_up();
field_cv__countdown.clean_up();
field_dl__tbf__ext.clean_up();
field_ul__tbf__ext.clean_up();
field_initial__cs.clean_up();
field_initial__mcs.clean_up();
field_nsvci.clean_up();
field_local__pprt.clean_up();
field_remote__port.clean_up();
field_remote__ip.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__info__ind::get_descriptor() const { return &PCUIF__info__ind_descr_; }
PCUIF__info__ind& PCUIF__info__ind::operator=(const PCUIF__info__ind& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_info_ind.");
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.flags().is_bound()) field_flags = other_value.flags();
  else field_flags.clean_up();
  if (other_value.trx().is_bound()) field_trx = other_value.trx();
  else field_trx.clean_up();
  if (other_value.bsic().is_bound()) field_bsic = other_value.bsic();
  else field_bsic.clean_up();
  if (other_value.mcc().is_bound()) field_mcc = other_value.mcc();
  else field_mcc.clean_up();
  if (other_value.mnc().is_bound()) field_mnc = other_value.mnc();
  else field_mnc.clean_up();
  if (other_value.mnc__3__digits().is_bound()) field_mnc__3__digits = other_value.mnc__3__digits();
  else field_mnc__3__digits.clean_up();
  if (other_value.lac().is_bound()) field_lac = other_value.lac();
  else field_lac.clean_up();
  if (other_value.rac().is_bound()) field_rac = other_value.rac();
  else field_rac.clean_up();
  if (other_value.nsei().is_bound()) field_nsei = other_value.nsei();
  else field_nsei.clean_up();
  if (other_value.nse__timer().is_bound()) field_nse__timer = other_value.nse__timer();
  else field_nse__timer.clean_up();
  if (other_value.cell__timer().is_bound()) field_cell__timer = other_value.cell__timer();
  else field_cell__timer.clean_up();
  if (other_value.cell__id().is_bound()) field_cell__id = other_value.cell__id();
  else field_cell__id.clean_up();
  if (other_value.repeat__time().is_bound()) field_repeat__time = other_value.repeat__time();
  else field_repeat__time.clean_up();
  if (other_value.repeat__count().is_bound()) field_repeat__count = other_value.repeat__count();
  else field_repeat__count.clean_up();
  if (other_value.bvci().is_bound()) field_bvci = other_value.bvci();
  else field_bvci.clean_up();
  if (other_value.t3142().is_bound()) field_t3142 = other_value.t3142();
  else field_t3142.clean_up();
  if (other_value.t3169().is_bound()) field_t3169 = other_value.t3169();
  else field_t3169.clean_up();
  if (other_value.t3191().is_bound()) field_t3191 = other_value.t3191();
  else field_t3191.clean_up();
  if (other_value.t3193__10ms().is_bound()) field_t3193__10ms = other_value.t3193__10ms();
  else field_t3193__10ms.clean_up();
  if (other_value.t3195().is_bound()) field_t3195 = other_value.t3195();
  else field_t3195.clean_up();
  if (other_value.t3101().is_bound()) field_t3101 = other_value.t3101();
  else field_t3101.clean_up();
  if (other_value.t3103().is_bound()) field_t3103 = other_value.t3103();
  else field_t3103.clean_up();
  if (other_value.t3105().is_bound()) field_t3105 = other_value.t3105();
  else field_t3105.clean_up();
  if (other_value.cv__countdown().is_bound()) field_cv__countdown = other_value.cv__countdown();
  else field_cv__countdown.clean_up();
  if (other_value.dl__tbf__ext().is_bound()) field_dl__tbf__ext = other_value.dl__tbf__ext();
  else field_dl__tbf__ext.clean_up();
  if (other_value.ul__tbf__ext().is_bound()) field_ul__tbf__ext = other_value.ul__tbf__ext();
  else field_ul__tbf__ext.clean_up();
  if (other_value.initial__cs().is_bound()) field_initial__cs = other_value.initial__cs();
  else field_initial__cs.clean_up();
  if (other_value.initial__mcs().is_bound()) field_initial__mcs = other_value.initial__mcs();
  else field_initial__mcs.clean_up();
  if (other_value.nsvci().is_bound()) field_nsvci = other_value.nsvci();
  else field_nsvci.clean_up();
  if (other_value.local__pprt().is_bound()) field_local__pprt = other_value.local__pprt();
  else field_local__pprt.clean_up();
  if (other_value.remote__port().is_bound()) field_remote__port = other_value.remote__port();
  else field_remote__port.clean_up();
  if (other_value.remote__ip().is_bound()) field_remote__ip = other_value.remote__ip();
  else field_remote__ip.clean_up();
}
return *this;
}

boolean PCUIF__info__ind::operator==(const PCUIF__info__ind& other_value) const
{
return field_version==other_value.field_version
  && field_flags==other_value.field_flags
  && field_trx==other_value.field_trx
  && field_bsic==other_value.field_bsic
  && field_mcc==other_value.field_mcc
  && field_mnc==other_value.field_mnc
  && field_mnc__3__digits==other_value.field_mnc__3__digits
  && field_lac==other_value.field_lac
  && field_rac==other_value.field_rac
  && field_nsei==other_value.field_nsei
  && field_nse__timer==other_value.field_nse__timer
  && field_cell__timer==other_value.field_cell__timer
  && field_cell__id==other_value.field_cell__id
  && field_repeat__time==other_value.field_repeat__time
  && field_repeat__count==other_value.field_repeat__count
  && field_bvci==other_value.field_bvci
  && field_t3142==other_value.field_t3142
  && field_t3169==other_value.field_t3169
  && field_t3191==other_value.field_t3191
  && field_t3193__10ms==other_value.field_t3193__10ms
  && field_t3195==other_value.field_t3195
  && field_t3101==other_value.field_t3101
  && field_t3103==other_value.field_t3103
  && field_t3105==other_value.field_t3105
  && field_cv__countdown==other_value.field_cv__countdown
  && field_dl__tbf__ext==other_value.field_dl__tbf__ext
  && field_ul__tbf__ext==other_value.field_ul__tbf__ext
  && field_initial__cs==other_value.field_initial__cs
  && field_initial__mcs==other_value.field_initial__mcs
  && field_nsvci==other_value.field_nsvci
  && field_local__pprt==other_value.field_local__pprt
  && field_remote__port==other_value.field_remote__port
  && field_remote__ip==other_value.field_remote__ip;
}

boolean PCUIF__info__ind::is_bound() const
{
if(field_version.is_bound()) return TRUE;
if(field_flags.is_bound()) return TRUE;
if(field_trx.is_bound()) return TRUE;
if(field_bsic.is_bound()) return TRUE;
if(field_mcc.is_bound()) return TRUE;
if(field_mnc.is_bound()) return TRUE;
if(field_mnc__3__digits.is_bound()) return TRUE;
if(field_lac.is_bound()) return TRUE;
if(field_rac.is_bound()) return TRUE;
if(field_nsei.is_bound()) return TRUE;
if(field_nse__timer.is_bound()) return TRUE;
if(field_cell__timer.is_bound()) return TRUE;
if(field_cell__id.is_bound()) return TRUE;
if(field_repeat__time.is_bound()) return TRUE;
if(field_repeat__count.is_bound()) return TRUE;
if(field_bvci.is_bound()) return TRUE;
if(field_t3142.is_bound()) return TRUE;
if(field_t3169.is_bound()) return TRUE;
if(field_t3191.is_bound()) return TRUE;
if(field_t3193__10ms.is_bound()) return TRUE;
if(field_t3195.is_bound()) return TRUE;
if(field_t3101.is_bound()) return TRUE;
if(field_t3103.is_bound()) return TRUE;
if(field_t3105.is_bound()) return TRUE;
if(field_cv__countdown.is_bound()) return TRUE;
if(field_dl__tbf__ext.is_bound()) return TRUE;
if(field_ul__tbf__ext.is_bound()) return TRUE;
if(field_initial__cs.is_bound()) return TRUE;
if(field_initial__mcs.is_bound()) return TRUE;
if(field_nsvci.is_bound()) return TRUE;
if(field_local__pprt.is_bound()) return TRUE;
if(field_remote__port.is_bound()) return TRUE;
if(field_remote__ip.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__info__ind::is_value() const
{
if(!field_version.is_value()) return FALSE;
if(!field_flags.is_value()) return FALSE;
if(!field_trx.is_value()) return FALSE;
if(!field_bsic.is_value()) return FALSE;
if(!field_mcc.is_value()) return FALSE;
if(!field_mnc.is_value()) return FALSE;
if(!field_mnc__3__digits.is_value()) return FALSE;
if(!field_lac.is_value()) return FALSE;
if(!field_rac.is_value()) return FALSE;
if(!field_nsei.is_value()) return FALSE;
if(!field_nse__timer.is_value()) return FALSE;
if(!field_cell__timer.is_value()) return FALSE;
if(!field_cell__id.is_value()) return FALSE;
if(!field_repeat__time.is_value()) return FALSE;
if(!field_repeat__count.is_value()) return FALSE;
if(!field_bvci.is_value()) return FALSE;
if(!field_t3142.is_value()) return FALSE;
if(!field_t3169.is_value()) return FALSE;
if(!field_t3191.is_value()) return FALSE;
if(!field_t3193__10ms.is_value()) return FALSE;
if(!field_t3195.is_value()) return FALSE;
if(!field_t3101.is_value()) return FALSE;
if(!field_t3103.is_value()) return FALSE;
if(!field_t3105.is_value()) return FALSE;
if(!field_cv__countdown.is_value()) return FALSE;
if(!field_dl__tbf__ext.is_value()) return FALSE;
if(!field_ul__tbf__ext.is_value()) return FALSE;
if(!field_initial__cs.is_value()) return FALSE;
if(!field_initial__mcs.is_value()) return FALSE;
if(!field_nsvci.is_value()) return FALSE;
if(!field_local__pprt.is_value()) return FALSE;
if(!field_remote__port.is_value()) return FALSE;
if(!field_remote__ip.is_value()) return FALSE;
return TRUE;
}
void PCUIF__info__ind::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", flags := ");
field_flags.log();
TTCN_Logger::log_event_str(", trx := ");
field_trx.log();
TTCN_Logger::log_event_str(", bsic := ");
field_bsic.log();
TTCN_Logger::log_event_str(", mcc := ");
field_mcc.log();
TTCN_Logger::log_event_str(", mnc := ");
field_mnc.log();
TTCN_Logger::log_event_str(", mnc_3_digits := ");
field_mnc__3__digits.log();
TTCN_Logger::log_event_str(", lac := ");
field_lac.log();
TTCN_Logger::log_event_str(", rac := ");
field_rac.log();
TTCN_Logger::log_event_str(", nsei := ");
field_nsei.log();
TTCN_Logger::log_event_str(", nse_timer := ");
field_nse__timer.log();
TTCN_Logger::log_event_str(", cell_timer := ");
field_cell__timer.log();
TTCN_Logger::log_event_str(", cell_id := ");
field_cell__id.log();
TTCN_Logger::log_event_str(", repeat_time := ");
field_repeat__time.log();
TTCN_Logger::log_event_str(", repeat_count := ");
field_repeat__count.log();
TTCN_Logger::log_event_str(", bvci := ");
field_bvci.log();
TTCN_Logger::log_event_str(", t3142 := ");
field_t3142.log();
TTCN_Logger::log_event_str(", t3169 := ");
field_t3169.log();
TTCN_Logger::log_event_str(", t3191 := ");
field_t3191.log();
TTCN_Logger::log_event_str(", t3193_10ms := ");
field_t3193__10ms.log();
TTCN_Logger::log_event_str(", t3195 := ");
field_t3195.log();
TTCN_Logger::log_event_str(", t3101 := ");
field_t3101.log();
TTCN_Logger::log_event_str(", t3103 := ");
field_t3103.log();
TTCN_Logger::log_event_str(", t3105 := ");
field_t3105.log();
TTCN_Logger::log_event_str(", cv_countdown := ");
field_cv__countdown.log();
TTCN_Logger::log_event_str(", dl_tbf_ext := ");
field_dl__tbf__ext.log();
TTCN_Logger::log_event_str(", ul_tbf_ext := ");
field_ul__tbf__ext.log();
TTCN_Logger::log_event_str(", initial_cs := ");
field_initial__cs.log();
TTCN_Logger::log_event_str(", initial_mcs := ");
field_initial__mcs.log();
TTCN_Logger::log_event_str(", nsvci := ");
field_nsvci.log();
TTCN_Logger::log_event_str(", local_pprt := ");
field_local__pprt.log();
TTCN_Logger::log_event_str(", remote_port := ");
field_remote__port.log();
TTCN_Logger::log_event_str(", remote_ip := ");
field_remote__ip.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__info__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (33<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_info_ind has 33 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trx().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) bsic().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) mcc().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) mnc().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) mnc__3__digits().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) lac().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) rac().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) nsei().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) nse__timer().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) cell__timer().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) cell__id().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) repeat__time().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) repeat__count().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) bvci().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) t3142().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) t3169().set_param(*param.get_elem(17));
    if (param.get_size()>18 && param.get_elem(18)->get_type()!=Module_Param::MP_NotUsed) t3191().set_param(*param.get_elem(18));
    if (param.get_size()>19 && param.get_elem(19)->get_type()!=Module_Param::MP_NotUsed) t3193__10ms().set_param(*param.get_elem(19));
    if (param.get_size()>20 && param.get_elem(20)->get_type()!=Module_Param::MP_NotUsed) t3195().set_param(*param.get_elem(20));
    if (param.get_size()>21 && param.get_elem(21)->get_type()!=Module_Param::MP_NotUsed) t3101().set_param(*param.get_elem(21));
    if (param.get_size()>22 && param.get_elem(22)->get_type()!=Module_Param::MP_NotUsed) t3103().set_param(*param.get_elem(22));
    if (param.get_size()>23 && param.get_elem(23)->get_type()!=Module_Param::MP_NotUsed) t3105().set_param(*param.get_elem(23));
    if (param.get_size()>24 && param.get_elem(24)->get_type()!=Module_Param::MP_NotUsed) cv__countdown().set_param(*param.get_elem(24));
    if (param.get_size()>25 && param.get_elem(25)->get_type()!=Module_Param::MP_NotUsed) dl__tbf__ext().set_param(*param.get_elem(25));
    if (param.get_size()>26 && param.get_elem(26)->get_type()!=Module_Param::MP_NotUsed) ul__tbf__ext().set_param(*param.get_elem(26));
    if (param.get_size()>27 && param.get_elem(27)->get_type()!=Module_Param::MP_NotUsed) initial__cs().set_param(*param.get_elem(27));
    if (param.get_size()>28 && param.get_elem(28)->get_type()!=Module_Param::MP_NotUsed) initial__mcs().set_param(*param.get_elem(28));
    if (param.get_size()>29 && param.get_elem(29)->get_type()!=Module_Param::MP_NotUsed) nsvci().set_param(*param.get_elem(29));
    if (param.get_size()>30 && param.get_elem(30)->get_type()!=Module_Param::MP_NotUsed) local__pprt().set_param(*param.get_elem(30));
    if (param.get_size()>31 && param.get_elem(31)->get_type()!=Module_Param::MP_NotUsed) remote__port().set_param(*param.get_elem(31));
    if (param.get_size()>32 && param.get_elem(32)->get_type()!=Module_Param::MP_NotUsed) remote__ip().set_param(*param.get_elem(32));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bsic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bsic().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mnc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mnc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mnc_3_digits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mnc__3__digits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lac")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lac().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rac")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rac().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nsei")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nsei().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nse_timer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nse__timer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cell_timer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cell__timer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cell_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cell__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repeat_time")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repeat__time().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repeat_count")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repeat__count().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bvci")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bvci().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3142")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3142().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3169")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3169().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3191")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3191().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3193_10ms")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3193__10ms().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3195")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3195().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3101")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3101().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3103")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3103().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3105")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3105().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cv_countdown")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cv__countdown().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dl_tbf_ext")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dl__tbf__ext().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ul_tbf_ext")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ul__tbf__ext().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "initial_cs")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          initial__cs().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "initial_mcs")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          initial__mcs().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nsvci")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nsvci().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_pprt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__pprt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remote_port")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remote__port().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remote_ip")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remote__ip().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_info_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_info_ind");
  }
}

void PCUIF__info__ind::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (flags().is_bound()) flags().set_implicit_omit();
if (trx().is_bound()) trx().set_implicit_omit();
if (bsic().is_bound()) bsic().set_implicit_omit();
if (mcc().is_bound()) mcc().set_implicit_omit();
if (mnc().is_bound()) mnc().set_implicit_omit();
if (mnc__3__digits().is_bound()) mnc__3__digits().set_implicit_omit();
if (lac().is_bound()) lac().set_implicit_omit();
if (rac().is_bound()) rac().set_implicit_omit();
if (nsei().is_bound()) nsei().set_implicit_omit();
if (nse__timer().is_bound()) nse__timer().set_implicit_omit();
if (cell__timer().is_bound()) cell__timer().set_implicit_omit();
if (cell__id().is_bound()) cell__id().set_implicit_omit();
if (repeat__time().is_bound()) repeat__time().set_implicit_omit();
if (repeat__count().is_bound()) repeat__count().set_implicit_omit();
if (bvci().is_bound()) bvci().set_implicit_omit();
if (t3142().is_bound()) t3142().set_implicit_omit();
if (t3169().is_bound()) t3169().set_implicit_omit();
if (t3191().is_bound()) t3191().set_implicit_omit();
if (t3193__10ms().is_bound()) t3193__10ms().set_implicit_omit();
if (t3195().is_bound()) t3195().set_implicit_omit();
if (t3101().is_bound()) t3101().set_implicit_omit();
if (t3103().is_bound()) t3103().set_implicit_omit();
if (t3105().is_bound()) t3105().set_implicit_omit();
if (cv__countdown().is_bound()) cv__countdown().set_implicit_omit();
if (dl__tbf__ext().is_bound()) dl__tbf__ext().set_implicit_omit();
if (ul__tbf__ext().is_bound()) ul__tbf__ext().set_implicit_omit();
if (initial__cs().is_bound()) initial__cs().set_implicit_omit();
if (initial__mcs().is_bound()) initial__mcs().set_implicit_omit();
if (nsvci().is_bound()) nsvci().set_implicit_omit();
if (local__pprt().is_bound()) local__pprt().set_implicit_omit();
if (remote__port().is_bound()) remote__port().set_implicit_omit();
if (remote__ip().is_bound()) remote__ip().set_implicit_omit();
}

void PCUIF__info__ind::encode_text(Text_Buf& text_buf) const
{
field_version.encode_text(text_buf);
field_flags.encode_text(text_buf);
field_trx.encode_text(text_buf);
field_bsic.encode_text(text_buf);
field_mcc.encode_text(text_buf);
field_mnc.encode_text(text_buf);
field_mnc__3__digits.encode_text(text_buf);
field_lac.encode_text(text_buf);
field_rac.encode_text(text_buf);
field_nsei.encode_text(text_buf);
field_nse__timer.encode_text(text_buf);
field_cell__timer.encode_text(text_buf);
field_cell__id.encode_text(text_buf);
field_repeat__time.encode_text(text_buf);
field_repeat__count.encode_text(text_buf);
field_bvci.encode_text(text_buf);
field_t3142.encode_text(text_buf);
field_t3169.encode_text(text_buf);
field_t3191.encode_text(text_buf);
field_t3193__10ms.encode_text(text_buf);
field_t3195.encode_text(text_buf);
field_t3101.encode_text(text_buf);
field_t3103.encode_text(text_buf);
field_t3105.encode_text(text_buf);
field_cv__countdown.encode_text(text_buf);
field_dl__tbf__ext.encode_text(text_buf);
field_ul__tbf__ext.encode_text(text_buf);
field_initial__cs.encode_text(text_buf);
field_initial__mcs.encode_text(text_buf);
field_nsvci.encode_text(text_buf);
field_local__pprt.encode_text(text_buf);
field_remote__port.encode_text(text_buf);
field_remote__ip.encode_text(text_buf);
}

void PCUIF__info__ind::decode_text(Text_Buf& text_buf)
{
field_version.decode_text(text_buf);
field_flags.decode_text(text_buf);
field_trx.decode_text(text_buf);
field_bsic.decode_text(text_buf);
field_mcc.decode_text(text_buf);
field_mnc.decode_text(text_buf);
field_mnc__3__digits.decode_text(text_buf);
field_lac.decode_text(text_buf);
field_rac.decode_text(text_buf);
field_nsei.decode_text(text_buf);
field_nse__timer.decode_text(text_buf);
field_cell__timer.decode_text(text_buf);
field_cell__id.decode_text(text_buf);
field_repeat__time.decode_text(text_buf);
field_repeat__count.decode_text(text_buf);
field_bvci.decode_text(text_buf);
field_t3142.decode_text(text_buf);
field_t3169.decode_text(text_buf);
field_t3191.decode_text(text_buf);
field_t3193__10ms.decode_text(text_buf);
field_t3195.decode_text(text_buf);
field_t3101.decode_text(text_buf);
field_t3103.decode_text(text_buf);
field_t3105.decode_text(text_buf);
field_cv__countdown.decode_text(text_buf);
field_dl__tbf__ext.decode_text(text_buf);
field_ul__tbf__ext.decode_text(text_buf);
field_initial__cs.decode_text(text_buf);
field_initial__mcs.decode_text(text_buf);
field_nsvci.decode_text(text_buf);
field_local__pprt.decode_text(text_buf);
field_remote__port.decode_text(text_buf);
field_remote__ip.decode_text(text_buf);
}

void PCUIF__info__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__info__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__info__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__info__ind_version_descr_.raw->forceomit);
  decoded_field_length = field_version.RAW_decode(PCUIF__info__ind_version_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__info__ind_flags_descr_.raw->forceomit);
  decoded_field_length = field_flags.RAW_decode(PCUIF__info__ind_flags_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__info__ind_trx_descr_.raw->forceomit);
  decoded_field_length = field_trx.RAW_decode(PCUIF__info__ind_trx_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__info__ind_bsic_descr_.raw->forceomit);
  decoded_field_length = field_bsic.RAW_decode(PCUIF__info__ind_bsic_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__info__ind_mcc_descr_.raw->forceomit);
  decoded_field_length = field_mcc.RAW_decode(PCUIF__info__ind_mcc_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_4_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__info__ind_mnc_descr_.raw->forceomit);
  decoded_field_length = field_mnc.RAW_decode(PCUIF__info__ind_mnc_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_5_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__info__ind_mnc__3__digits_descr_.raw->forceomit);
  decoded_field_length = field_mnc__3__digits.RAW_decode(PCUIF__info__ind_mnc__3__digits_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_6_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_7_force_omit(7, force_omit, PCUIF__info__ind_lac_descr_.raw->forceomit);
  decoded_field_length = field_lac.RAW_decode(PCUIF__info__ind_lac_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_7_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_8_force_omit(8, force_omit, PCUIF__info__ind_rac_descr_.raw->forceomit);
  decoded_field_length = field_rac.RAW_decode(PCUIF__info__ind_rac_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_8_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_9_force_omit(9, force_omit, PCUIF__info__ind_nsei_descr_.raw->forceomit);
  decoded_field_length = field_nsei.RAW_decode(PCUIF__info__ind_nsei_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_9_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_10_force_omit(10, force_omit, PCUIF__info__ind_nse__timer_descr_.raw->forceomit);
  decoded_field_length = field_nse__timer.RAW_decode(PCUIF__info__ind_nse__timer_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_10_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_11_force_omit(11, force_omit, PCUIF__info__ind_cell__timer_descr_.raw->forceomit);
  decoded_field_length = field_cell__timer.RAW_decode(PCUIF__info__ind_cell__timer_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_11_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_12_force_omit(12, force_omit, PCUIF__info__ind_cell__id_descr_.raw->forceomit);
  decoded_field_length = field_cell__id.RAW_decode(PCUIF__info__ind_cell__id_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_12_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_13_force_omit(13, force_omit, PCUIF__info__ind_repeat__time_descr_.raw->forceomit);
  decoded_field_length = field_repeat__time.RAW_decode(PCUIF__info__ind_repeat__time_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_13_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_14_force_omit(14, force_omit, PCUIF__info__ind_repeat__count_descr_.raw->forceomit);
  decoded_field_length = field_repeat__count.RAW_decode(PCUIF__info__ind_repeat__count_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_14_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_15_force_omit(15, force_omit, PCUIF__info__ind_bvci_descr_.raw->forceomit);
  decoded_field_length = field_bvci.RAW_decode(PCUIF__info__ind_bvci_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_15_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_16_force_omit(16, force_omit, PCUIF__info__ind_t3142_descr_.raw->forceomit);
  decoded_field_length = field_t3142.RAW_decode(PCUIF__info__ind_t3142_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_16_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_17_force_omit(17, force_omit, PCUIF__info__ind_t3169_descr_.raw->forceomit);
  decoded_field_length = field_t3169.RAW_decode(PCUIF__info__ind_t3169_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_17_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_18_force_omit(18, force_omit, PCUIF__info__ind_t3191_descr_.raw->forceomit);
  decoded_field_length = field_t3191.RAW_decode(PCUIF__info__ind_t3191_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_18_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_19_force_omit(19, force_omit, PCUIF__info__ind_t3193__10ms_descr_.raw->forceomit);
  decoded_field_length = field_t3193__10ms.RAW_decode(PCUIF__info__ind_t3193__10ms_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_19_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_20_force_omit(20, force_omit, PCUIF__info__ind_t3195_descr_.raw->forceomit);
  decoded_field_length = field_t3195.RAW_decode(PCUIF__info__ind_t3195_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_20_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_21_force_omit(21, force_omit, PCUIF__info__ind_t3101_descr_.raw->forceomit);
  decoded_field_length = field_t3101.RAW_decode(PCUIF__info__ind_t3101_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_21_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_22_force_omit(22, force_omit, PCUIF__info__ind_t3103_descr_.raw->forceomit);
  decoded_field_length = field_t3103.RAW_decode(PCUIF__info__ind_t3103_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_22_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_23_force_omit(23, force_omit, PCUIF__info__ind_t3105_descr_.raw->forceomit);
  decoded_field_length = field_t3105.RAW_decode(PCUIF__info__ind_t3105_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_23_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_24_force_omit(24, force_omit, PCUIF__info__ind_cv__countdown_descr_.raw->forceomit);
  decoded_field_length = field_cv__countdown.RAW_decode(PCUIF__info__ind_cv__countdown_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_24_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_25_force_omit(25, force_omit, PCUIF__info__ind_dl__tbf__ext_descr_.raw->forceomit);
  decoded_field_length = field_dl__tbf__ext.RAW_decode(PCUIF__info__ind_dl__tbf__ext_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_25_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_26_force_omit(26, force_omit, PCUIF__info__ind_ul__tbf__ext_descr_.raw->forceomit);
  decoded_field_length = field_ul__tbf__ext.RAW_decode(PCUIF__info__ind_ul__tbf__ext_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_26_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_27_force_omit(27, force_omit, PCUIF__info__ind_initial__cs_descr_.raw->forceomit);
  decoded_field_length = field_initial__cs.RAW_decode(PCUIF__info__ind_initial__cs_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_27_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_28_force_omit(28, force_omit, PCUIF__info__ind_initial__mcs_descr_.raw->forceomit);
  decoded_field_length = field_initial__mcs.RAW_decode(PCUIF__info__ind_initial__mcs_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_28_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_29_force_omit(29, force_omit, PCUIF__info__ind_nsvci_descr_.raw->forceomit);
  decoded_field_length = field_nsvci.RAW_decode(PCUIF__info__ind_nsvci_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_29_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_30_force_omit(30, force_omit, PCUIF__info__ind_local__pprt_descr_.raw->forceomit);
  decoded_field_length = field_local__pprt.RAW_decode(PCUIF__info__ind_local__pprt_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_30_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_31_force_omit(31, force_omit, PCUIF__info__ind_remote__port_descr_.raw->forceomit);
  decoded_field_length = field_remote__port.RAW_decode(PCUIF__info__ind_remote__port_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_31_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_32_force_omit(32, force_omit, PCUIF__info__ind_remote__ip_descr_.raw->forceomit);
  decoded_field_length = field_remote__ip.RAW_decode(PCUIF__info__ind_remote__ip_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_32_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__info__ind::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 33;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(33);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__info__ind_version_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__info__ind_flags_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__info__ind_trx_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__info__ind_bsic_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 4, PCUIF__info__ind_mcc_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 5, PCUIF__info__ind_mnc_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 6, PCUIF__info__ind_mnc__3__digits_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 7, PCUIF__info__ind_lac_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 8, PCUIF__info__ind_rac_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 9, PCUIF__info__ind_nsei_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 10, PCUIF__info__ind_nse__timer_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 11, PCUIF__info__ind_cell__timer_descr_.raw);
  myleaf.body.node.nodes[12] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 12, PCUIF__info__ind_cell__id_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 13, PCUIF__info__ind_repeat__time_descr_.raw);
  myleaf.body.node.nodes[14] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 14, PCUIF__info__ind_repeat__count_descr_.raw);
  myleaf.body.node.nodes[15] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 15, PCUIF__info__ind_bvci_descr_.raw);
  myleaf.body.node.nodes[16] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 16, PCUIF__info__ind_t3142_descr_.raw);
  myleaf.body.node.nodes[17] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 17, PCUIF__info__ind_t3169_descr_.raw);
  myleaf.body.node.nodes[18] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 18, PCUIF__info__ind_t3191_descr_.raw);
  myleaf.body.node.nodes[19] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 19, PCUIF__info__ind_t3193__10ms_descr_.raw);
  myleaf.body.node.nodes[20] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 20, PCUIF__info__ind_t3195_descr_.raw);
  myleaf.body.node.nodes[21] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 21, PCUIF__info__ind_t3101_descr_.raw);
  myleaf.body.node.nodes[22] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 22, PCUIF__info__ind_t3103_descr_.raw);
  myleaf.body.node.nodes[23] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 23, PCUIF__info__ind_t3105_descr_.raw);
  myleaf.body.node.nodes[24] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 24, PCUIF__info__ind_cv__countdown_descr_.raw);
  myleaf.body.node.nodes[25] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 25, PCUIF__info__ind_dl__tbf__ext_descr_.raw);
  myleaf.body.node.nodes[26] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 26, PCUIF__info__ind_ul__tbf__ext_descr_.raw);
  myleaf.body.node.nodes[27] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 27, PCUIF__info__ind_initial__cs_descr_.raw);
  myleaf.body.node.nodes[28] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 28, PCUIF__info__ind_initial__mcs_descr_.raw);
  myleaf.body.node.nodes[29] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 29, PCUIF__info__ind_nsvci_descr_.raw);
  myleaf.body.node.nodes[30] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 30, PCUIF__info__ind_local__pprt_descr_.raw);
  myleaf.body.node.nodes[31] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 31, PCUIF__info__ind_remote__port_descr_.raw);
  myleaf.body.node.nodes[32] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 32, PCUIF__info__ind_remote__ip_descr_.raw);
  encoded_length += field_version.RAW_encode(PCUIF__info__ind_version_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_flags.RAW_encode(PCUIF__info__ind_flags_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_trx.RAW_encode(PCUIF__info__ind_trx_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_bsic.RAW_encode(PCUIF__info__ind_bsic_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_mcc.RAW_encode(PCUIF__info__ind_mcc_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_mnc.RAW_encode(PCUIF__info__ind_mnc_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_mnc__3__digits.RAW_encode(PCUIF__info__ind_mnc__3__digits_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_lac.RAW_encode(PCUIF__info__ind_lac_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_rac.RAW_encode(PCUIF__info__ind_rac_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_nsei.RAW_encode(PCUIF__info__ind_nsei_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_nse__timer.RAW_encode(PCUIF__info__ind_nse__timer_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_cell__timer.RAW_encode(PCUIF__info__ind_cell__timer_descr_, *myleaf.body.node.nodes[11]);
  encoded_length += field_cell__id.RAW_encode(PCUIF__info__ind_cell__id_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_repeat__time.RAW_encode(PCUIF__info__ind_repeat__time_descr_, *myleaf.body.node.nodes[13]);
  encoded_length += field_repeat__count.RAW_encode(PCUIF__info__ind_repeat__count_descr_, *myleaf.body.node.nodes[14]);
  encoded_length += field_bvci.RAW_encode(PCUIF__info__ind_bvci_descr_, *myleaf.body.node.nodes[15]);
  encoded_length += field_t3142.RAW_encode(PCUIF__info__ind_t3142_descr_, *myleaf.body.node.nodes[16]);
  encoded_length += field_t3169.RAW_encode(PCUIF__info__ind_t3169_descr_, *myleaf.body.node.nodes[17]);
  encoded_length += field_t3191.RAW_encode(PCUIF__info__ind_t3191_descr_, *myleaf.body.node.nodes[18]);
  encoded_length += field_t3193__10ms.RAW_encode(PCUIF__info__ind_t3193__10ms_descr_, *myleaf.body.node.nodes[19]);
  encoded_length += field_t3195.RAW_encode(PCUIF__info__ind_t3195_descr_, *myleaf.body.node.nodes[20]);
  encoded_length += field_t3101.RAW_encode(PCUIF__info__ind_t3101_descr_, *myleaf.body.node.nodes[21]);
  encoded_length += field_t3103.RAW_encode(PCUIF__info__ind_t3103_descr_, *myleaf.body.node.nodes[22]);
  encoded_length += field_t3105.RAW_encode(PCUIF__info__ind_t3105_descr_, *myleaf.body.node.nodes[23]);
  encoded_length += field_cv__countdown.RAW_encode(PCUIF__info__ind_cv__countdown_descr_, *myleaf.body.node.nodes[24]);
  encoded_length += field_dl__tbf__ext.RAW_encode(PCUIF__info__ind_dl__tbf__ext_descr_, *myleaf.body.node.nodes[25]);
  encoded_length += field_ul__tbf__ext.RAW_encode(PCUIF__info__ind_ul__tbf__ext_descr_, *myleaf.body.node.nodes[26]);
  encoded_length += field_initial__cs.RAW_encode(PCUIF__info__ind_initial__cs_descr_, *myleaf.body.node.nodes[27]);
  encoded_length += field_initial__mcs.RAW_encode(PCUIF__info__ind_initial__mcs_descr_, *myleaf.body.node.nodes[28]);
  encoded_length += field_nsvci.RAW_encode(PCUIF__info__ind_nsvci_descr_, *myleaf.body.node.nodes[29]);
  encoded_length += field_local__pprt.RAW_encode(PCUIF__info__ind_local__pprt_descr_, *myleaf.body.node.nodes[30]);
  encoded_length += field_remote__port.RAW_encode(PCUIF__info__ind_remote__port_descr_, *myleaf.body.node.nodes[31]);
  encoded_length += field_remote__ip.RAW_encode(PCUIF__info__ind_remote__ip_descr_, *myleaf.body.node.nodes[32]);
  return myleaf.length = encoded_length;
}

struct PCUIF__info__ind_template::single_value_struct {
INTEGER_template field_version;
PCUIF__Flags_template field_flags;
PCUIF__InfoTrxs_template field_trx;
INTEGER_template field_bsic;
INTEGER_template field_mcc;
INTEGER_template field_mnc;
INTEGER_template field_mnc__3__digits;
INTEGER_template field_lac;
INTEGER_template field_rac;
INTEGER_template field_nsei;
PCUIF__info__ind_nse__timer_template field_nse__timer;
PCUIF__info__ind_cell__timer_template field_cell__timer;
INTEGER_template field_cell__id;
INTEGER_template field_repeat__time;
INTEGER_template field_repeat__count;
INTEGER_template field_bvci;
INTEGER_template field_t3142;
INTEGER_template field_t3169;
INTEGER_template field_t3191;
INTEGER_template field_t3193__10ms;
INTEGER_template field_t3195;
INTEGER_template field_t3101;
INTEGER_template field_t3103;
INTEGER_template field_t3105;
INTEGER_template field_cv__countdown;
INTEGER_template field_dl__tbf__ext;
INTEGER_template field_ul__tbf__ext;
INTEGER_template field_initial__cs;
INTEGER_template field_initial__mcs;
PCUIF__info__ind_nsvci_template field_nsvci;
PCUIF__info__ind_local__pprt_template field_local__pprt;
PCUIF__info__ind_remote__port_template field_remote__port;
PCUIF__info__ind_remote__ip_template field_remote__ip;
};

void PCUIF__info__ind_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_flags = ANY_VALUE;
single_value->field_trx = ANY_VALUE;
single_value->field_bsic = ANY_VALUE;
single_value->field_mcc = ANY_VALUE;
single_value->field_mnc = ANY_VALUE;
single_value->field_mnc__3__digits = ANY_VALUE;
single_value->field_lac = ANY_VALUE;
single_value->field_rac = ANY_VALUE;
single_value->field_nsei = ANY_VALUE;
single_value->field_nse__timer = ANY_VALUE;
single_value->field_cell__timer = ANY_VALUE;
single_value->field_cell__id = ANY_VALUE;
single_value->field_repeat__time = ANY_VALUE;
single_value->field_repeat__count = ANY_VALUE;
single_value->field_bvci = ANY_VALUE;
single_value->field_t3142 = ANY_VALUE;
single_value->field_t3169 = ANY_VALUE;
single_value->field_t3191 = ANY_VALUE;
single_value->field_t3193__10ms = ANY_VALUE;
single_value->field_t3195 = ANY_VALUE;
single_value->field_t3101 = ANY_VALUE;
single_value->field_t3103 = ANY_VALUE;
single_value->field_t3105 = ANY_VALUE;
single_value->field_cv__countdown = ANY_VALUE;
single_value->field_dl__tbf__ext = ANY_VALUE;
single_value->field_ul__tbf__ext = ANY_VALUE;
single_value->field_initial__cs = ANY_VALUE;
single_value->field_initial__mcs = ANY_VALUE;
single_value->field_nsvci = ANY_VALUE;
single_value->field_local__pprt = ANY_VALUE;
single_value->field_remote__port = ANY_VALUE;
single_value->field_remote__ip = ANY_VALUE;
}
}
}

void PCUIF__info__ind_template::copy_value(const PCUIF__info__ind& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.flags().is_bound()) {
  single_value->field_flags = other_value.flags();
} else {
  single_value->field_flags.clean_up();
}
if (other_value.trx().is_bound()) {
  single_value->field_trx = other_value.trx();
} else {
  single_value->field_trx.clean_up();
}
if (other_value.bsic().is_bound()) {
  single_value->field_bsic = other_value.bsic();
} else {
  single_value->field_bsic.clean_up();
}
if (other_value.mcc().is_bound()) {
  single_value->field_mcc = other_value.mcc();
} else {
  single_value->field_mcc.clean_up();
}
if (other_value.mnc().is_bound()) {
  single_value->field_mnc = other_value.mnc();
} else {
  single_value->field_mnc.clean_up();
}
if (other_value.mnc__3__digits().is_bound()) {
  single_value->field_mnc__3__digits = other_value.mnc__3__digits();
} else {
  single_value->field_mnc__3__digits.clean_up();
}
if (other_value.lac().is_bound()) {
  single_value->field_lac = other_value.lac();
} else {
  single_value->field_lac.clean_up();
}
if (other_value.rac().is_bound()) {
  single_value->field_rac = other_value.rac();
} else {
  single_value->field_rac.clean_up();
}
if (other_value.nsei().is_bound()) {
  single_value->field_nsei = other_value.nsei();
} else {
  single_value->field_nsei.clean_up();
}
if (other_value.nse__timer().is_bound()) {
  single_value->field_nse__timer = other_value.nse__timer();
} else {
  single_value->field_nse__timer.clean_up();
}
if (other_value.cell__timer().is_bound()) {
  single_value->field_cell__timer = other_value.cell__timer();
} else {
  single_value->field_cell__timer.clean_up();
}
if (other_value.cell__id().is_bound()) {
  single_value->field_cell__id = other_value.cell__id();
} else {
  single_value->field_cell__id.clean_up();
}
if (other_value.repeat__time().is_bound()) {
  single_value->field_repeat__time = other_value.repeat__time();
} else {
  single_value->field_repeat__time.clean_up();
}
if (other_value.repeat__count().is_bound()) {
  single_value->field_repeat__count = other_value.repeat__count();
} else {
  single_value->field_repeat__count.clean_up();
}
if (other_value.bvci().is_bound()) {
  single_value->field_bvci = other_value.bvci();
} else {
  single_value->field_bvci.clean_up();
}
if (other_value.t3142().is_bound()) {
  single_value->field_t3142 = other_value.t3142();
} else {
  single_value->field_t3142.clean_up();
}
if (other_value.t3169().is_bound()) {
  single_value->field_t3169 = other_value.t3169();
} else {
  single_value->field_t3169.clean_up();
}
if (other_value.t3191().is_bound()) {
  single_value->field_t3191 = other_value.t3191();
} else {
  single_value->field_t3191.clean_up();
}
if (other_value.t3193__10ms().is_bound()) {
  single_value->field_t3193__10ms = other_value.t3193__10ms();
} else {
  single_value->field_t3193__10ms.clean_up();
}
if (other_value.t3195().is_bound()) {
  single_value->field_t3195 = other_value.t3195();
} else {
  single_value->field_t3195.clean_up();
}
if (other_value.t3101().is_bound()) {
  single_value->field_t3101 = other_value.t3101();
} else {
  single_value->field_t3101.clean_up();
}
if (other_value.t3103().is_bound()) {
  single_value->field_t3103 = other_value.t3103();
} else {
  single_value->field_t3103.clean_up();
}
if (other_value.t3105().is_bound()) {
  single_value->field_t3105 = other_value.t3105();
} else {
  single_value->field_t3105.clean_up();
}
if (other_value.cv__countdown().is_bound()) {
  single_value->field_cv__countdown = other_value.cv__countdown();
} else {
  single_value->field_cv__countdown.clean_up();
}
if (other_value.dl__tbf__ext().is_bound()) {
  single_value->field_dl__tbf__ext = other_value.dl__tbf__ext();
} else {
  single_value->field_dl__tbf__ext.clean_up();
}
if (other_value.ul__tbf__ext().is_bound()) {
  single_value->field_ul__tbf__ext = other_value.ul__tbf__ext();
} else {
  single_value->field_ul__tbf__ext.clean_up();
}
if (other_value.initial__cs().is_bound()) {
  single_value->field_initial__cs = other_value.initial__cs();
} else {
  single_value->field_initial__cs.clean_up();
}
if (other_value.initial__mcs().is_bound()) {
  single_value->field_initial__mcs = other_value.initial__mcs();
} else {
  single_value->field_initial__mcs.clean_up();
}
if (other_value.nsvci().is_bound()) {
  single_value->field_nsvci = other_value.nsvci();
} else {
  single_value->field_nsvci.clean_up();
}
if (other_value.local__pprt().is_bound()) {
  single_value->field_local__pprt = other_value.local__pprt();
} else {
  single_value->field_local__pprt.clean_up();
}
if (other_value.remote__port().is_bound()) {
  single_value->field_remote__port = other_value.remote__port();
} else {
  single_value->field_remote__port.clean_up();
}
if (other_value.remote__ip().is_bound()) {
  single_value->field_remote__ip = other_value.remote__ip();
} else {
  single_value->field_remote__ip.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__info__ind_template::copy_template(const PCUIF__info__ind_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flags().get_selection()) {
single_value->field_flags = other_value.flags();
} else {
single_value->field_flags.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trx().get_selection()) {
single_value->field_trx = other_value.trx();
} else {
single_value->field_trx.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.bsic().get_selection()) {
single_value->field_bsic = other_value.bsic();
} else {
single_value->field_bsic.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mcc().get_selection()) {
single_value->field_mcc = other_value.mcc();
} else {
single_value->field_mcc.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mnc().get_selection()) {
single_value->field_mnc = other_value.mnc();
} else {
single_value->field_mnc.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mnc__3__digits().get_selection()) {
single_value->field_mnc__3__digits = other_value.mnc__3__digits();
} else {
single_value->field_mnc__3__digits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lac().get_selection()) {
single_value->field_lac = other_value.lac();
} else {
single_value->field_lac.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rac().get_selection()) {
single_value->field_rac = other_value.rac();
} else {
single_value->field_rac.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nsei().get_selection()) {
single_value->field_nsei = other_value.nsei();
} else {
single_value->field_nsei.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nse__timer().get_selection()) {
single_value->field_nse__timer = other_value.nse__timer();
} else {
single_value->field_nse__timer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cell__timer().get_selection()) {
single_value->field_cell__timer = other_value.cell__timer();
} else {
single_value->field_cell__timer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cell__id().get_selection()) {
single_value->field_cell__id = other_value.cell__id();
} else {
single_value->field_cell__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.repeat__time().get_selection()) {
single_value->field_repeat__time = other_value.repeat__time();
} else {
single_value->field_repeat__time.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.repeat__count().get_selection()) {
single_value->field_repeat__count = other_value.repeat__count();
} else {
single_value->field_repeat__count.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.bvci().get_selection()) {
single_value->field_bvci = other_value.bvci();
} else {
single_value->field_bvci.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3142().get_selection()) {
single_value->field_t3142 = other_value.t3142();
} else {
single_value->field_t3142.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3169().get_selection()) {
single_value->field_t3169 = other_value.t3169();
} else {
single_value->field_t3169.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3191().get_selection()) {
single_value->field_t3191 = other_value.t3191();
} else {
single_value->field_t3191.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3193__10ms().get_selection()) {
single_value->field_t3193__10ms = other_value.t3193__10ms();
} else {
single_value->field_t3193__10ms.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3195().get_selection()) {
single_value->field_t3195 = other_value.t3195();
} else {
single_value->field_t3195.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3101().get_selection()) {
single_value->field_t3101 = other_value.t3101();
} else {
single_value->field_t3101.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3103().get_selection()) {
single_value->field_t3103 = other_value.t3103();
} else {
single_value->field_t3103.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t3105().get_selection()) {
single_value->field_t3105 = other_value.t3105();
} else {
single_value->field_t3105.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cv__countdown().get_selection()) {
single_value->field_cv__countdown = other_value.cv__countdown();
} else {
single_value->field_cv__countdown.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dl__tbf__ext().get_selection()) {
single_value->field_dl__tbf__ext = other_value.dl__tbf__ext();
} else {
single_value->field_dl__tbf__ext.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ul__tbf__ext().get_selection()) {
single_value->field_ul__tbf__ext = other_value.ul__tbf__ext();
} else {
single_value->field_ul__tbf__ext.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.initial__cs().get_selection()) {
single_value->field_initial__cs = other_value.initial__cs();
} else {
single_value->field_initial__cs.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.initial__mcs().get_selection()) {
single_value->field_initial__mcs = other_value.initial__mcs();
} else {
single_value->field_initial__mcs.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nsvci().get_selection()) {
single_value->field_nsvci = other_value.nsvci();
} else {
single_value->field_nsvci.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.local__pprt().get_selection()) {
single_value->field_local__pprt = other_value.local__pprt();
} else {
single_value->field_local__pprt.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remote__port().get_selection()) {
single_value->field_remote__port = other_value.remote__port();
} else {
single_value->field_remote__port.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remote__ip().get_selection()) {
single_value->field_remote__ip = other_value.remote__ip();
} else {
single_value->field_remote__ip.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__info__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_info_ind.");
break;
}
set_selection(other_value);
}

PCUIF__info__ind_template::PCUIF__info__ind_template()
{
}

PCUIF__info__ind_template::PCUIF__info__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__info__ind_template::PCUIF__info__ind_template(const PCUIF__info__ind& other_value)
{
copy_value(other_value);
}

PCUIF__info__ind_template::PCUIF__info__ind_template(const OPTIONAL<PCUIF__info__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__info__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_info_ind from an unbound optional field.");
}
}

PCUIF__info__ind_template::PCUIF__info__ind_template(const PCUIF__info__ind_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__info__ind_template::~PCUIF__info__ind_template()
{
clean_up();
}

PCUIF__info__ind_template& PCUIF__info__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__info__ind_template& PCUIF__info__ind_template::operator=(const PCUIF__info__ind& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__info__ind_template& PCUIF__info__ind_template::operator=(const OPTIONAL<PCUIF__info__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__info__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_info_ind.");
}
return *this;
}

PCUIF__info__ind_template& PCUIF__info__ind_template::operator=(const PCUIF__info__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__info__ind_template::match(const PCUIF__info__ind& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.flags().is_bound()) return FALSE;
if(!single_value->field_flags.match(other_value.flags(), legacy))return FALSE;
if(!other_value.trx().is_bound()) return FALSE;
if(!single_value->field_trx.match(other_value.trx(), legacy))return FALSE;
if(!other_value.bsic().is_bound()) return FALSE;
if(!single_value->field_bsic.match(other_value.bsic(), legacy))return FALSE;
if(!other_value.mcc().is_bound()) return FALSE;
if(!single_value->field_mcc.match(other_value.mcc(), legacy))return FALSE;
if(!other_value.mnc().is_bound()) return FALSE;
if(!single_value->field_mnc.match(other_value.mnc(), legacy))return FALSE;
if(!other_value.mnc__3__digits().is_bound()) return FALSE;
if(!single_value->field_mnc__3__digits.match(other_value.mnc__3__digits(), legacy))return FALSE;
if(!other_value.lac().is_bound()) return FALSE;
if(!single_value->field_lac.match(other_value.lac(), legacy))return FALSE;
if(!other_value.rac().is_bound()) return FALSE;
if(!single_value->field_rac.match(other_value.rac(), legacy))return FALSE;
if(!other_value.nsei().is_bound()) return FALSE;
if(!single_value->field_nsei.match(other_value.nsei(), legacy))return FALSE;
if(!other_value.nse__timer().is_bound()) return FALSE;
if(!single_value->field_nse__timer.match(other_value.nse__timer(), legacy))return FALSE;
if(!other_value.cell__timer().is_bound()) return FALSE;
if(!single_value->field_cell__timer.match(other_value.cell__timer(), legacy))return FALSE;
if(!other_value.cell__id().is_bound()) return FALSE;
if(!single_value->field_cell__id.match(other_value.cell__id(), legacy))return FALSE;
if(!other_value.repeat__time().is_bound()) return FALSE;
if(!single_value->field_repeat__time.match(other_value.repeat__time(), legacy))return FALSE;
if(!other_value.repeat__count().is_bound()) return FALSE;
if(!single_value->field_repeat__count.match(other_value.repeat__count(), legacy))return FALSE;
if(!other_value.bvci().is_bound()) return FALSE;
if(!single_value->field_bvci.match(other_value.bvci(), legacy))return FALSE;
if(!other_value.t3142().is_bound()) return FALSE;
if(!single_value->field_t3142.match(other_value.t3142(), legacy))return FALSE;
if(!other_value.t3169().is_bound()) return FALSE;
if(!single_value->field_t3169.match(other_value.t3169(), legacy))return FALSE;
if(!other_value.t3191().is_bound()) return FALSE;
if(!single_value->field_t3191.match(other_value.t3191(), legacy))return FALSE;
if(!other_value.t3193__10ms().is_bound()) return FALSE;
if(!single_value->field_t3193__10ms.match(other_value.t3193__10ms(), legacy))return FALSE;
if(!other_value.t3195().is_bound()) return FALSE;
if(!single_value->field_t3195.match(other_value.t3195(), legacy))return FALSE;
if(!other_value.t3101().is_bound()) return FALSE;
if(!single_value->field_t3101.match(other_value.t3101(), legacy))return FALSE;
if(!other_value.t3103().is_bound()) return FALSE;
if(!single_value->field_t3103.match(other_value.t3103(), legacy))return FALSE;
if(!other_value.t3105().is_bound()) return FALSE;
if(!single_value->field_t3105.match(other_value.t3105(), legacy))return FALSE;
if(!other_value.cv__countdown().is_bound()) return FALSE;
if(!single_value->field_cv__countdown.match(other_value.cv__countdown(), legacy))return FALSE;
if(!other_value.dl__tbf__ext().is_bound()) return FALSE;
if(!single_value->field_dl__tbf__ext.match(other_value.dl__tbf__ext(), legacy))return FALSE;
if(!other_value.ul__tbf__ext().is_bound()) return FALSE;
if(!single_value->field_ul__tbf__ext.match(other_value.ul__tbf__ext(), legacy))return FALSE;
if(!other_value.initial__cs().is_bound()) return FALSE;
if(!single_value->field_initial__cs.match(other_value.initial__cs(), legacy))return FALSE;
if(!other_value.initial__mcs().is_bound()) return FALSE;
if(!single_value->field_initial__mcs.match(other_value.initial__mcs(), legacy))return FALSE;
if(!other_value.nsvci().is_bound()) return FALSE;
if(!single_value->field_nsvci.match(other_value.nsvci(), legacy))return FALSE;
if(!other_value.local__pprt().is_bound()) return FALSE;
if(!single_value->field_local__pprt.match(other_value.local__pprt(), legacy))return FALSE;
if(!other_value.remote__port().is_bound()) return FALSE;
if(!single_value->field_remote__port.match(other_value.remote__port(), legacy))return FALSE;
if(!other_value.remote__ip().is_bound()) return FALSE;
if(!single_value->field_remote__ip.match(other_value.remote__ip(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_info_ind.");
}
return FALSE;
}

boolean PCUIF__info__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_flags.is_bound()) return TRUE;
if (single_value->field_trx.is_bound()) return TRUE;
if (single_value->field_bsic.is_bound()) return TRUE;
if (single_value->field_mcc.is_bound()) return TRUE;
if (single_value->field_mnc.is_bound()) return TRUE;
if (single_value->field_mnc__3__digits.is_bound()) return TRUE;
if (single_value->field_lac.is_bound()) return TRUE;
if (single_value->field_rac.is_bound()) return TRUE;
if (single_value->field_nsei.is_bound()) return TRUE;
if (single_value->field_nse__timer.is_bound()) return TRUE;
if (single_value->field_cell__timer.is_bound()) return TRUE;
if (single_value->field_cell__id.is_bound()) return TRUE;
if (single_value->field_repeat__time.is_bound()) return TRUE;
if (single_value->field_repeat__count.is_bound()) return TRUE;
if (single_value->field_bvci.is_bound()) return TRUE;
if (single_value->field_t3142.is_bound()) return TRUE;
if (single_value->field_t3169.is_bound()) return TRUE;
if (single_value->field_t3191.is_bound()) return TRUE;
if (single_value->field_t3193__10ms.is_bound()) return TRUE;
if (single_value->field_t3195.is_bound()) return TRUE;
if (single_value->field_t3101.is_bound()) return TRUE;
if (single_value->field_t3103.is_bound()) return TRUE;
if (single_value->field_t3105.is_bound()) return TRUE;
if (single_value->field_cv__countdown.is_bound()) return TRUE;
if (single_value->field_dl__tbf__ext.is_bound()) return TRUE;
if (single_value->field_ul__tbf__ext.is_bound()) return TRUE;
if (single_value->field_initial__cs.is_bound()) return TRUE;
if (single_value->field_initial__mcs.is_bound()) return TRUE;
if (single_value->field_nsvci.is_bound()) return TRUE;
if (single_value->field_local__pprt.is_bound()) return TRUE;
if (single_value->field_remote__port.is_bound()) return TRUE;
if (single_value->field_remote__ip.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__info__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_flags.is_value()) return FALSE;
if (!single_value->field_trx.is_value()) return FALSE;
if (!single_value->field_bsic.is_value()) return FALSE;
if (!single_value->field_mcc.is_value()) return FALSE;
if (!single_value->field_mnc.is_value()) return FALSE;
if (!single_value->field_mnc__3__digits.is_value()) return FALSE;
if (!single_value->field_lac.is_value()) return FALSE;
if (!single_value->field_rac.is_value()) return FALSE;
if (!single_value->field_nsei.is_value()) return FALSE;
if (!single_value->field_nse__timer.is_value()) return FALSE;
if (!single_value->field_cell__timer.is_value()) return FALSE;
if (!single_value->field_cell__id.is_value()) return FALSE;
if (!single_value->field_repeat__time.is_value()) return FALSE;
if (!single_value->field_repeat__count.is_value()) return FALSE;
if (!single_value->field_bvci.is_value()) return FALSE;
if (!single_value->field_t3142.is_value()) return FALSE;
if (!single_value->field_t3169.is_value()) return FALSE;
if (!single_value->field_t3191.is_value()) return FALSE;
if (!single_value->field_t3193__10ms.is_value()) return FALSE;
if (!single_value->field_t3195.is_value()) return FALSE;
if (!single_value->field_t3101.is_value()) return FALSE;
if (!single_value->field_t3103.is_value()) return FALSE;
if (!single_value->field_t3105.is_value()) return FALSE;
if (!single_value->field_cv__countdown.is_value()) return FALSE;
if (!single_value->field_dl__tbf__ext.is_value()) return FALSE;
if (!single_value->field_ul__tbf__ext.is_value()) return FALSE;
if (!single_value->field_initial__cs.is_value()) return FALSE;
if (!single_value->field_initial__mcs.is_value()) return FALSE;
if (!single_value->field_nsvci.is_value()) return FALSE;
if (!single_value->field_local__pprt.is_value()) return FALSE;
if (!single_value->field_remote__port.is_value()) return FALSE;
if (!single_value->field_remote__ip.is_value()) return FALSE;
return TRUE;
}

void PCUIF__info__ind_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__info__ind PCUIF__info__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
PCUIF__info__ind ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_flags.is_bound()) {
ret_val.flags() = single_value->field_flags.valueof();
}
if (single_value->field_trx.is_bound()) {
ret_val.trx() = single_value->field_trx.valueof();
}
if (single_value->field_bsic.is_bound()) {
ret_val.bsic() = single_value->field_bsic.valueof();
}
if (single_value->field_mcc.is_bound()) {
ret_val.mcc() = single_value->field_mcc.valueof();
}
if (single_value->field_mnc.is_bound()) {
ret_val.mnc() = single_value->field_mnc.valueof();
}
if (single_value->field_mnc__3__digits.is_bound()) {
ret_val.mnc__3__digits() = single_value->field_mnc__3__digits.valueof();
}
if (single_value->field_lac.is_bound()) {
ret_val.lac() = single_value->field_lac.valueof();
}
if (single_value->field_rac.is_bound()) {
ret_val.rac() = single_value->field_rac.valueof();
}
if (single_value->field_nsei.is_bound()) {
ret_val.nsei() = single_value->field_nsei.valueof();
}
if (single_value->field_nse__timer.is_bound()) {
ret_val.nse__timer() = single_value->field_nse__timer.valueof();
}
if (single_value->field_cell__timer.is_bound()) {
ret_val.cell__timer() = single_value->field_cell__timer.valueof();
}
if (single_value->field_cell__id.is_bound()) {
ret_val.cell__id() = single_value->field_cell__id.valueof();
}
if (single_value->field_repeat__time.is_bound()) {
ret_val.repeat__time() = single_value->field_repeat__time.valueof();
}
if (single_value->field_repeat__count.is_bound()) {
ret_val.repeat__count() = single_value->field_repeat__count.valueof();
}
if (single_value->field_bvci.is_bound()) {
ret_val.bvci() = single_value->field_bvci.valueof();
}
if (single_value->field_t3142.is_bound()) {
ret_val.t3142() = single_value->field_t3142.valueof();
}
if (single_value->field_t3169.is_bound()) {
ret_val.t3169() = single_value->field_t3169.valueof();
}
if (single_value->field_t3191.is_bound()) {
ret_val.t3191() = single_value->field_t3191.valueof();
}
if (single_value->field_t3193__10ms.is_bound()) {
ret_val.t3193__10ms() = single_value->field_t3193__10ms.valueof();
}
if (single_value->field_t3195.is_bound()) {
ret_val.t3195() = single_value->field_t3195.valueof();
}
if (single_value->field_t3101.is_bound()) {
ret_val.t3101() = single_value->field_t3101.valueof();
}
if (single_value->field_t3103.is_bound()) {
ret_val.t3103() = single_value->field_t3103.valueof();
}
if (single_value->field_t3105.is_bound()) {
ret_val.t3105() = single_value->field_t3105.valueof();
}
if (single_value->field_cv__countdown.is_bound()) {
ret_val.cv__countdown() = single_value->field_cv__countdown.valueof();
}
if (single_value->field_dl__tbf__ext.is_bound()) {
ret_val.dl__tbf__ext() = single_value->field_dl__tbf__ext.valueof();
}
if (single_value->field_ul__tbf__ext.is_bound()) {
ret_val.ul__tbf__ext() = single_value->field_ul__tbf__ext.valueof();
}
if (single_value->field_initial__cs.is_bound()) {
ret_val.initial__cs() = single_value->field_initial__cs.valueof();
}
if (single_value->field_initial__mcs.is_bound()) {
ret_val.initial__mcs() = single_value->field_initial__mcs.valueof();
}
if (single_value->field_nsvci.is_bound()) {
ret_val.nsvci() = single_value->field_nsvci.valueof();
}
if (single_value->field_local__pprt.is_bound()) {
ret_val.local__pprt() = single_value->field_local__pprt.valueof();
}
if (single_value->field_remote__port.is_bound()) {
ret_val.remote__port() = single_value->field_remote__port.valueof();
}
if (single_value->field_remote__ip.is_bound()) {
ret_val.remote__ip() = single_value->field_remote__ip.valueof();
}
return ret_val;
}

void PCUIF__info__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_info_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__info__ind_template[list_length];
}

PCUIF__info__ind_template& PCUIF__info__ind_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_info_ind.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_info_ind.");
return value_list.list_value[list_index];
}

INTEGER_template& PCUIF__info__ind_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& PCUIF__info__ind_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_version;
}

PCUIF__Flags_template& PCUIF__info__ind_template::flags()
{
set_specific();
return single_value->field_flags;
}

const PCUIF__Flags_template& PCUIF__info__ind_template::flags() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flags of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_flags;
}

PCUIF__InfoTrxs_template& PCUIF__info__ind_template::trx()
{
set_specific();
return single_value->field_trx;
}

const PCUIF__InfoTrxs_template& PCUIF__info__ind_template::trx() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trx of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_trx;
}

INTEGER_template& PCUIF__info__ind_template::bsic()
{
set_specific();
return single_value->field_bsic;
}

const INTEGER_template& PCUIF__info__ind_template::bsic() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bsic of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_bsic;
}

INTEGER_template& PCUIF__info__ind_template::mcc()
{
set_specific();
return single_value->field_mcc;
}

const INTEGER_template& PCUIF__info__ind_template::mcc() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mcc of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_mcc;
}

INTEGER_template& PCUIF__info__ind_template::mnc()
{
set_specific();
return single_value->field_mnc;
}

const INTEGER_template& PCUIF__info__ind_template::mnc() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mnc of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_mnc;
}

INTEGER_template& PCUIF__info__ind_template::mnc__3__digits()
{
set_specific();
return single_value->field_mnc__3__digits;
}

const INTEGER_template& PCUIF__info__ind_template::mnc__3__digits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mnc_3_digits of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_mnc__3__digits;
}

INTEGER_template& PCUIF__info__ind_template::lac()
{
set_specific();
return single_value->field_lac;
}

const INTEGER_template& PCUIF__info__ind_template::lac() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lac of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_lac;
}

INTEGER_template& PCUIF__info__ind_template::rac()
{
set_specific();
return single_value->field_rac;
}

const INTEGER_template& PCUIF__info__ind_template::rac() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rac of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_rac;
}

INTEGER_template& PCUIF__info__ind_template::nsei()
{
set_specific();
return single_value->field_nsei;
}

const INTEGER_template& PCUIF__info__ind_template::nsei() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nsei of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_nsei;
}

PCUIF__info__ind_nse__timer_template& PCUIF__info__ind_template::nse__timer()
{
set_specific();
return single_value->field_nse__timer;
}

const PCUIF__info__ind_nse__timer_template& PCUIF__info__ind_template::nse__timer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nse_timer of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_nse__timer;
}

PCUIF__info__ind_cell__timer_template& PCUIF__info__ind_template::cell__timer()
{
set_specific();
return single_value->field_cell__timer;
}

const PCUIF__info__ind_cell__timer_template& PCUIF__info__ind_template::cell__timer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cell_timer of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_cell__timer;
}

INTEGER_template& PCUIF__info__ind_template::cell__id()
{
set_specific();
return single_value->field_cell__id;
}

const INTEGER_template& PCUIF__info__ind_template::cell__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cell_id of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_cell__id;
}

INTEGER_template& PCUIF__info__ind_template::repeat__time()
{
set_specific();
return single_value->field_repeat__time;
}

const INTEGER_template& PCUIF__info__ind_template::repeat__time() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field repeat_time of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_repeat__time;
}

INTEGER_template& PCUIF__info__ind_template::repeat__count()
{
set_specific();
return single_value->field_repeat__count;
}

const INTEGER_template& PCUIF__info__ind_template::repeat__count() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field repeat_count of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_repeat__count;
}

INTEGER_template& PCUIF__info__ind_template::bvci()
{
set_specific();
return single_value->field_bvci;
}

const INTEGER_template& PCUIF__info__ind_template::bvci() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bvci of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_bvci;
}

INTEGER_template& PCUIF__info__ind_template::t3142()
{
set_specific();
return single_value->field_t3142;
}

const INTEGER_template& PCUIF__info__ind_template::t3142() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3142 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3142;
}

INTEGER_template& PCUIF__info__ind_template::t3169()
{
set_specific();
return single_value->field_t3169;
}

const INTEGER_template& PCUIF__info__ind_template::t3169() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3169 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3169;
}

INTEGER_template& PCUIF__info__ind_template::t3191()
{
set_specific();
return single_value->field_t3191;
}

const INTEGER_template& PCUIF__info__ind_template::t3191() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3191 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3191;
}

INTEGER_template& PCUIF__info__ind_template::t3193__10ms()
{
set_specific();
return single_value->field_t3193__10ms;
}

const INTEGER_template& PCUIF__info__ind_template::t3193__10ms() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3193_10ms of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3193__10ms;
}

INTEGER_template& PCUIF__info__ind_template::t3195()
{
set_specific();
return single_value->field_t3195;
}

const INTEGER_template& PCUIF__info__ind_template::t3195() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3195 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3195;
}

INTEGER_template& PCUIF__info__ind_template::t3101()
{
set_specific();
return single_value->field_t3101;
}

const INTEGER_template& PCUIF__info__ind_template::t3101() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3101 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3101;
}

INTEGER_template& PCUIF__info__ind_template::t3103()
{
set_specific();
return single_value->field_t3103;
}

const INTEGER_template& PCUIF__info__ind_template::t3103() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3103 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3103;
}

INTEGER_template& PCUIF__info__ind_template::t3105()
{
set_specific();
return single_value->field_t3105;
}

const INTEGER_template& PCUIF__info__ind_template::t3105() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t3105 of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_t3105;
}

INTEGER_template& PCUIF__info__ind_template::cv__countdown()
{
set_specific();
return single_value->field_cv__countdown;
}

const INTEGER_template& PCUIF__info__ind_template::cv__countdown() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cv_countdown of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_cv__countdown;
}

INTEGER_template& PCUIF__info__ind_template::dl__tbf__ext()
{
set_specific();
return single_value->field_dl__tbf__ext;
}

const INTEGER_template& PCUIF__info__ind_template::dl__tbf__ext() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dl_tbf_ext of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_dl__tbf__ext;
}

INTEGER_template& PCUIF__info__ind_template::ul__tbf__ext()
{
set_specific();
return single_value->field_ul__tbf__ext;
}

const INTEGER_template& PCUIF__info__ind_template::ul__tbf__ext() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ul_tbf_ext of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_ul__tbf__ext;
}

INTEGER_template& PCUIF__info__ind_template::initial__cs()
{
set_specific();
return single_value->field_initial__cs;
}

const INTEGER_template& PCUIF__info__ind_template::initial__cs() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field initial_cs of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_initial__cs;
}

INTEGER_template& PCUIF__info__ind_template::initial__mcs()
{
set_specific();
return single_value->field_initial__mcs;
}

const INTEGER_template& PCUIF__info__ind_template::initial__mcs() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field initial_mcs of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_initial__mcs;
}

PCUIF__info__ind_nsvci_template& PCUIF__info__ind_template::nsvci()
{
set_specific();
return single_value->field_nsvci;
}

const PCUIF__info__ind_nsvci_template& PCUIF__info__ind_template::nsvci() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nsvci of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_nsvci;
}

PCUIF__info__ind_local__pprt_template& PCUIF__info__ind_template::local__pprt()
{
set_specific();
return single_value->field_local__pprt;
}

const PCUIF__info__ind_local__pprt_template& PCUIF__info__ind_template::local__pprt() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field local_pprt of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_local__pprt;
}

PCUIF__info__ind_remote__port_template& PCUIF__info__ind_template::remote__port()
{
set_specific();
return single_value->field_remote__port;
}

const PCUIF__info__ind_remote__port_template& PCUIF__info__ind_template::remote__port() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remote_port of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_remote__port;
}

PCUIF__info__ind_remote__ip_template& PCUIF__info__ind_template::remote__ip()
{
set_specific();
return single_value->field_remote__ip;
}

const PCUIF__info__ind_remote__ip_template& PCUIF__info__ind_template::remote__ip() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remote_ip of a non-specific template of type @PCUIF_Types.PCUIF_info_ind.");
return single_value->field_remote__ip;
}

int PCUIF__info__ind_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 33;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_info_ind containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_info_ind.");
  }
  return 0;
}

void PCUIF__info__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log();
TTCN_Logger::log_event_str(", trx := ");
single_value->field_trx.log();
TTCN_Logger::log_event_str(", bsic := ");
single_value->field_bsic.log();
TTCN_Logger::log_event_str(", mcc := ");
single_value->field_mcc.log();
TTCN_Logger::log_event_str(", mnc := ");
single_value->field_mnc.log();
TTCN_Logger::log_event_str(", mnc_3_digits := ");
single_value->field_mnc__3__digits.log();
TTCN_Logger::log_event_str(", lac := ");
single_value->field_lac.log();
TTCN_Logger::log_event_str(", rac := ");
single_value->field_rac.log();
TTCN_Logger::log_event_str(", nsei := ");
single_value->field_nsei.log();
TTCN_Logger::log_event_str(", nse_timer := ");
single_value->field_nse__timer.log();
TTCN_Logger::log_event_str(", cell_timer := ");
single_value->field_cell__timer.log();
TTCN_Logger::log_event_str(", cell_id := ");
single_value->field_cell__id.log();
TTCN_Logger::log_event_str(", repeat_time := ");
single_value->field_repeat__time.log();
TTCN_Logger::log_event_str(", repeat_count := ");
single_value->field_repeat__count.log();
TTCN_Logger::log_event_str(", bvci := ");
single_value->field_bvci.log();
TTCN_Logger::log_event_str(", t3142 := ");
single_value->field_t3142.log();
TTCN_Logger::log_event_str(", t3169 := ");
single_value->field_t3169.log();
TTCN_Logger::log_event_str(", t3191 := ");
single_value->field_t3191.log();
TTCN_Logger::log_event_str(", t3193_10ms := ");
single_value->field_t3193__10ms.log();
TTCN_Logger::log_event_str(", t3195 := ");
single_value->field_t3195.log();
TTCN_Logger::log_event_str(", t3101 := ");
single_value->field_t3101.log();
TTCN_Logger::log_event_str(", t3103 := ");
single_value->field_t3103.log();
TTCN_Logger::log_event_str(", t3105 := ");
single_value->field_t3105.log();
TTCN_Logger::log_event_str(", cv_countdown := ");
single_value->field_cv__countdown.log();
TTCN_Logger::log_event_str(", dl_tbf_ext := ");
single_value->field_dl__tbf__ext.log();
TTCN_Logger::log_event_str(", ul_tbf_ext := ");
single_value->field_ul__tbf__ext.log();
TTCN_Logger::log_event_str(", initial_cs := ");
single_value->field_initial__cs.log();
TTCN_Logger::log_event_str(", initial_mcs := ");
single_value->field_initial__mcs.log();
TTCN_Logger::log_event_str(", nsvci := ");
single_value->field_nsvci.log();
TTCN_Logger::log_event_str(", local_pprt := ");
single_value->field_local__pprt.log();
TTCN_Logger::log_event_str(", remote_port := ");
single_value->field_remote__port.log();
TTCN_Logger::log_event_str(", remote_ip := ");
single_value->field_remote__ip.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__info__ind_template::log_match(const PCUIF__info__ind& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flags.match(match_value.flags(), legacy)){
TTCN_Logger::log_logmatch_info(".flags");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trx.match(match_value.trx(), legacy)){
TTCN_Logger::log_logmatch_info(".trx");
single_value->field_trx.log_match(match_value.trx(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_bsic.match(match_value.bsic(), legacy)){
TTCN_Logger::log_logmatch_info(".bsic");
single_value->field_bsic.log_match(match_value.bsic(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mcc.match(match_value.mcc(), legacy)){
TTCN_Logger::log_logmatch_info(".mcc");
single_value->field_mcc.log_match(match_value.mcc(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mnc.match(match_value.mnc(), legacy)){
TTCN_Logger::log_logmatch_info(".mnc");
single_value->field_mnc.log_match(match_value.mnc(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mnc__3__digits.match(match_value.mnc__3__digits(), legacy)){
TTCN_Logger::log_logmatch_info(".mnc_3_digits");
single_value->field_mnc__3__digits.log_match(match_value.mnc__3__digits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lac.match(match_value.lac(), legacy)){
TTCN_Logger::log_logmatch_info(".lac");
single_value->field_lac.log_match(match_value.lac(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rac.match(match_value.rac(), legacy)){
TTCN_Logger::log_logmatch_info(".rac");
single_value->field_rac.log_match(match_value.rac(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nsei.match(match_value.nsei(), legacy)){
TTCN_Logger::log_logmatch_info(".nsei");
single_value->field_nsei.log_match(match_value.nsei(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nse__timer.match(match_value.nse__timer(), legacy)){
TTCN_Logger::log_logmatch_info(".nse_timer");
single_value->field_nse__timer.log_match(match_value.nse__timer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cell__timer.match(match_value.cell__timer(), legacy)){
TTCN_Logger::log_logmatch_info(".cell_timer");
single_value->field_cell__timer.log_match(match_value.cell__timer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cell__id.match(match_value.cell__id(), legacy)){
TTCN_Logger::log_logmatch_info(".cell_id");
single_value->field_cell__id.log_match(match_value.cell__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_repeat__time.match(match_value.repeat__time(), legacy)){
TTCN_Logger::log_logmatch_info(".repeat_time");
single_value->field_repeat__time.log_match(match_value.repeat__time(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_repeat__count.match(match_value.repeat__count(), legacy)){
TTCN_Logger::log_logmatch_info(".repeat_count");
single_value->field_repeat__count.log_match(match_value.repeat__count(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_bvci.match(match_value.bvci(), legacy)){
TTCN_Logger::log_logmatch_info(".bvci");
single_value->field_bvci.log_match(match_value.bvci(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3142.match(match_value.t3142(), legacy)){
TTCN_Logger::log_logmatch_info(".t3142");
single_value->field_t3142.log_match(match_value.t3142(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3169.match(match_value.t3169(), legacy)){
TTCN_Logger::log_logmatch_info(".t3169");
single_value->field_t3169.log_match(match_value.t3169(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3191.match(match_value.t3191(), legacy)){
TTCN_Logger::log_logmatch_info(".t3191");
single_value->field_t3191.log_match(match_value.t3191(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3193__10ms.match(match_value.t3193__10ms(), legacy)){
TTCN_Logger::log_logmatch_info(".t3193_10ms");
single_value->field_t3193__10ms.log_match(match_value.t3193__10ms(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3195.match(match_value.t3195(), legacy)){
TTCN_Logger::log_logmatch_info(".t3195");
single_value->field_t3195.log_match(match_value.t3195(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3101.match(match_value.t3101(), legacy)){
TTCN_Logger::log_logmatch_info(".t3101");
single_value->field_t3101.log_match(match_value.t3101(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3103.match(match_value.t3103(), legacy)){
TTCN_Logger::log_logmatch_info(".t3103");
single_value->field_t3103.log_match(match_value.t3103(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t3105.match(match_value.t3105(), legacy)){
TTCN_Logger::log_logmatch_info(".t3105");
single_value->field_t3105.log_match(match_value.t3105(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cv__countdown.match(match_value.cv__countdown(), legacy)){
TTCN_Logger::log_logmatch_info(".cv_countdown");
single_value->field_cv__countdown.log_match(match_value.cv__countdown(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dl__tbf__ext.match(match_value.dl__tbf__ext(), legacy)){
TTCN_Logger::log_logmatch_info(".dl_tbf_ext");
single_value->field_dl__tbf__ext.log_match(match_value.dl__tbf__ext(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ul__tbf__ext.match(match_value.ul__tbf__ext(), legacy)){
TTCN_Logger::log_logmatch_info(".ul_tbf_ext");
single_value->field_ul__tbf__ext.log_match(match_value.ul__tbf__ext(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_initial__cs.match(match_value.initial__cs(), legacy)){
TTCN_Logger::log_logmatch_info(".initial_cs");
single_value->field_initial__cs.log_match(match_value.initial__cs(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_initial__mcs.match(match_value.initial__mcs(), legacy)){
TTCN_Logger::log_logmatch_info(".initial_mcs");
single_value->field_initial__mcs.log_match(match_value.initial__mcs(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nsvci.match(match_value.nsvci(), legacy)){
TTCN_Logger::log_logmatch_info(".nsvci");
single_value->field_nsvci.log_match(match_value.nsvci(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_local__pprt.match(match_value.local__pprt(), legacy)){
TTCN_Logger::log_logmatch_info(".local_pprt");
single_value->field_local__pprt.log_match(match_value.local__pprt(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remote__port.match(match_value.remote__port(), legacy)){
TTCN_Logger::log_logmatch_info(".remote_port");
single_value->field_remote__port.log_match(match_value.remote__port(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remote__ip.match(match_value.remote__ip(), legacy)){
TTCN_Logger::log_logmatch_info(".remote_ip");
single_value->field_remote__ip.log_match(match_value.remote__ip(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::log_event_str(", trx := ");
single_value->field_trx.log_match(match_value.trx(), legacy);
TTCN_Logger::log_event_str(", bsic := ");
single_value->field_bsic.log_match(match_value.bsic(), legacy);
TTCN_Logger::log_event_str(", mcc := ");
single_value->field_mcc.log_match(match_value.mcc(), legacy);
TTCN_Logger::log_event_str(", mnc := ");
single_value->field_mnc.log_match(match_value.mnc(), legacy);
TTCN_Logger::log_event_str(", mnc_3_digits := ");
single_value->field_mnc__3__digits.log_match(match_value.mnc__3__digits(), legacy);
TTCN_Logger::log_event_str(", lac := ");
single_value->field_lac.log_match(match_value.lac(), legacy);
TTCN_Logger::log_event_str(", rac := ");
single_value->field_rac.log_match(match_value.rac(), legacy);
TTCN_Logger::log_event_str(", nsei := ");
single_value->field_nsei.log_match(match_value.nsei(), legacy);
TTCN_Logger::log_event_str(", nse_timer := ");
single_value->field_nse__timer.log_match(match_value.nse__timer(), legacy);
TTCN_Logger::log_event_str(", cell_timer := ");
single_value->field_cell__timer.log_match(match_value.cell__timer(), legacy);
TTCN_Logger::log_event_str(", cell_id := ");
single_value->field_cell__id.log_match(match_value.cell__id(), legacy);
TTCN_Logger::log_event_str(", repeat_time := ");
single_value->field_repeat__time.log_match(match_value.repeat__time(), legacy);
TTCN_Logger::log_event_str(", repeat_count := ");
single_value->field_repeat__count.log_match(match_value.repeat__count(), legacy);
TTCN_Logger::log_event_str(", bvci := ");
single_value->field_bvci.log_match(match_value.bvci(), legacy);
TTCN_Logger::log_event_str(", t3142 := ");
single_value->field_t3142.log_match(match_value.t3142(), legacy);
TTCN_Logger::log_event_str(", t3169 := ");
single_value->field_t3169.log_match(match_value.t3169(), legacy);
TTCN_Logger::log_event_str(", t3191 := ");
single_value->field_t3191.log_match(match_value.t3191(), legacy);
TTCN_Logger::log_event_str(", t3193_10ms := ");
single_value->field_t3193__10ms.log_match(match_value.t3193__10ms(), legacy);
TTCN_Logger::log_event_str(", t3195 := ");
single_value->field_t3195.log_match(match_value.t3195(), legacy);
TTCN_Logger::log_event_str(", t3101 := ");
single_value->field_t3101.log_match(match_value.t3101(), legacy);
TTCN_Logger::log_event_str(", t3103 := ");
single_value->field_t3103.log_match(match_value.t3103(), legacy);
TTCN_Logger::log_event_str(", t3105 := ");
single_value->field_t3105.log_match(match_value.t3105(), legacy);
TTCN_Logger::log_event_str(", cv_countdown := ");
single_value->field_cv__countdown.log_match(match_value.cv__countdown(), legacy);
TTCN_Logger::log_event_str(", dl_tbf_ext := ");
single_value->field_dl__tbf__ext.log_match(match_value.dl__tbf__ext(), legacy);
TTCN_Logger::log_event_str(", ul_tbf_ext := ");
single_value->field_ul__tbf__ext.log_match(match_value.ul__tbf__ext(), legacy);
TTCN_Logger::log_event_str(", initial_cs := ");
single_value->field_initial__cs.log_match(match_value.initial__cs(), legacy);
TTCN_Logger::log_event_str(", initial_mcs := ");
single_value->field_initial__mcs.log_match(match_value.initial__mcs(), legacy);
TTCN_Logger::log_event_str(", nsvci := ");
single_value->field_nsvci.log_match(match_value.nsvci(), legacy);
TTCN_Logger::log_event_str(", local_pprt := ");
single_value->field_local__pprt.log_match(match_value.local__pprt(), legacy);
TTCN_Logger::log_event_str(", remote_port := ");
single_value->field_remote__port.log_match(match_value.remote__port(), legacy);
TTCN_Logger::log_event_str(", remote_ip := ");
single_value->field_remote__ip.log_match(match_value.remote__ip(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__info__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_flags.encode_text(text_buf);
single_value->field_trx.encode_text(text_buf);
single_value->field_bsic.encode_text(text_buf);
single_value->field_mcc.encode_text(text_buf);
single_value->field_mnc.encode_text(text_buf);
single_value->field_mnc__3__digits.encode_text(text_buf);
single_value->field_lac.encode_text(text_buf);
single_value->field_rac.encode_text(text_buf);
single_value->field_nsei.encode_text(text_buf);
single_value->field_nse__timer.encode_text(text_buf);
single_value->field_cell__timer.encode_text(text_buf);
single_value->field_cell__id.encode_text(text_buf);
single_value->field_repeat__time.encode_text(text_buf);
single_value->field_repeat__count.encode_text(text_buf);
single_value->field_bvci.encode_text(text_buf);
single_value->field_t3142.encode_text(text_buf);
single_value->field_t3169.encode_text(text_buf);
single_value->field_t3191.encode_text(text_buf);
single_value->field_t3193__10ms.encode_text(text_buf);
single_value->field_t3195.encode_text(text_buf);
single_value->field_t3101.encode_text(text_buf);
single_value->field_t3103.encode_text(text_buf);
single_value->field_t3105.encode_text(text_buf);
single_value->field_cv__countdown.encode_text(text_buf);
single_value->field_dl__tbf__ext.encode_text(text_buf);
single_value->field_ul__tbf__ext.encode_text(text_buf);
single_value->field_initial__cs.encode_text(text_buf);
single_value->field_initial__mcs.encode_text(text_buf);
single_value->field_nsvci.encode_text(text_buf);
single_value->field_local__pprt.encode_text(text_buf);
single_value->field_remote__port.encode_text(text_buf);
single_value->field_remote__ip.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_info_ind.");
}
}

void PCUIF__info__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_flags.decode_text(text_buf);
single_value->field_trx.decode_text(text_buf);
single_value->field_bsic.decode_text(text_buf);
single_value->field_mcc.decode_text(text_buf);
single_value->field_mnc.decode_text(text_buf);
single_value->field_mnc__3__digits.decode_text(text_buf);
single_value->field_lac.decode_text(text_buf);
single_value->field_rac.decode_text(text_buf);
single_value->field_nsei.decode_text(text_buf);
single_value->field_nse__timer.decode_text(text_buf);
single_value->field_cell__timer.decode_text(text_buf);
single_value->field_cell__id.decode_text(text_buf);
single_value->field_repeat__time.decode_text(text_buf);
single_value->field_repeat__count.decode_text(text_buf);
single_value->field_bvci.decode_text(text_buf);
single_value->field_t3142.decode_text(text_buf);
single_value->field_t3169.decode_text(text_buf);
single_value->field_t3191.decode_text(text_buf);
single_value->field_t3193__10ms.decode_text(text_buf);
single_value->field_t3195.decode_text(text_buf);
single_value->field_t3101.decode_text(text_buf);
single_value->field_t3103.decode_text(text_buf);
single_value->field_t3105.decode_text(text_buf);
single_value->field_cv__countdown.decode_text(text_buf);
single_value->field_dl__tbf__ext.decode_text(text_buf);
single_value->field_ul__tbf__ext.decode_text(text_buf);
single_value->field_initial__cs.decode_text(text_buf);
single_value->field_initial__mcs.decode_text(text_buf);
single_value->field_nsvci.decode_text(text_buf);
single_value->field_local__pprt.decode_text(text_buf);
single_value->field_remote__port.decode_text(text_buf);
single_value->field_remote__ip.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__info__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_info_ind.");
}
}

void PCUIF__info__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__info__ind_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (33<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_info_ind has 33 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trx().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) bsic().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) mcc().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) mnc().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) mnc__3__digits().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) lac().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) rac().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) nsei().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) nse__timer().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) cell__timer().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) cell__id().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) repeat__time().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) repeat__count().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) bvci().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) t3142().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) t3169().set_param(*param.get_elem(17));
    if (param.get_size()>18 && param.get_elem(18)->get_type()!=Module_Param::MP_NotUsed) t3191().set_param(*param.get_elem(18));
    if (param.get_size()>19 && param.get_elem(19)->get_type()!=Module_Param::MP_NotUsed) t3193__10ms().set_param(*param.get_elem(19));
    if (param.get_size()>20 && param.get_elem(20)->get_type()!=Module_Param::MP_NotUsed) t3195().set_param(*param.get_elem(20));
    if (param.get_size()>21 && param.get_elem(21)->get_type()!=Module_Param::MP_NotUsed) t3101().set_param(*param.get_elem(21));
    if (param.get_size()>22 && param.get_elem(22)->get_type()!=Module_Param::MP_NotUsed) t3103().set_param(*param.get_elem(22));
    if (param.get_size()>23 && param.get_elem(23)->get_type()!=Module_Param::MP_NotUsed) t3105().set_param(*param.get_elem(23));
    if (param.get_size()>24 && param.get_elem(24)->get_type()!=Module_Param::MP_NotUsed) cv__countdown().set_param(*param.get_elem(24));
    if (param.get_size()>25 && param.get_elem(25)->get_type()!=Module_Param::MP_NotUsed) dl__tbf__ext().set_param(*param.get_elem(25));
    if (param.get_size()>26 && param.get_elem(26)->get_type()!=Module_Param::MP_NotUsed) ul__tbf__ext().set_param(*param.get_elem(26));
    if (param.get_size()>27 && param.get_elem(27)->get_type()!=Module_Param::MP_NotUsed) initial__cs().set_param(*param.get_elem(27));
    if (param.get_size()>28 && param.get_elem(28)->get_type()!=Module_Param::MP_NotUsed) initial__mcs().set_param(*param.get_elem(28));
    if (param.get_size()>29 && param.get_elem(29)->get_type()!=Module_Param::MP_NotUsed) nsvci().set_param(*param.get_elem(29));
    if (param.get_size()>30 && param.get_elem(30)->get_type()!=Module_Param::MP_NotUsed) local__pprt().set_param(*param.get_elem(30));
    if (param.get_size()>31 && param.get_elem(31)->get_type()!=Module_Param::MP_NotUsed) remote__port().set_param(*param.get_elem(31));
    if (param.get_size()>32 && param.get_elem(32)->get_type()!=Module_Param::MP_NotUsed) remote__ip().set_param(*param.get_elem(32));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bsic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bsic().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mcc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mcc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mnc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mnc().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mnc_3_digits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mnc__3__digits().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lac")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lac().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rac")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rac().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nsei")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nsei().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nse_timer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nse__timer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cell_timer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cell__timer().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cell_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cell__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repeat_time")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repeat__time().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repeat_count")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repeat__count().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bvci")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bvci().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3142")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3142().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3169")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3169().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3191")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3191().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3193_10ms")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3193__10ms().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3195")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3195().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3101")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3101().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3103")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3103().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t3105")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t3105().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cv_countdown")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cv__countdown().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dl_tbf_ext")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dl__tbf__ext().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ul_tbf_ext")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ul__tbf__ext().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "initial_cs")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          initial__cs().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "initial_mcs")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          initial__mcs().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nsvci")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nsvci().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_pprt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__pprt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remote_port")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remote__port().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remote_ip")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remote__ip().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_info_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_info_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__info__ind_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_flags.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_trx.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_bsic.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_mcc.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_mnc.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_mnc__3__digits.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_lac.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_rac.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_nsei.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_nse__timer.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_cell__timer.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_cell__id.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_repeat__time.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_repeat__count.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_bvci.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3142.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3169.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3191.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3193__10ms.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3195.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3101.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3103.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_t3105.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_cv__countdown.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_dl__tbf__ext.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_ul__tbf__ext.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_initial__cs.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_initial__mcs.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_nsvci.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_local__pprt.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_remote__port.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
single_value->field_remote__ip.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_info_ind");
}

boolean PCUIF__info__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__info__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__act__req::PCUIF__act__req()
{
}

PCUIF__act__req::PCUIF__act__req(const INTEGER& par_is__activate,
    const INTEGER& par_trx__nr,
    const INTEGER& par_ts__nr,
    const OCTETSTRING& par_spare)
  :   field_is__activate(par_is__activate),
  field_trx__nr(par_trx__nr),
  field_ts__nr(par_ts__nr),
  field_spare(par_spare)
{
}

PCUIF__act__req::PCUIF__act__req(const PCUIF__act__req& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_act_req.");
if (other_value.is__activate().is_bound()) field_is__activate = other_value.is__activate();
else field_is__activate.clean_up();
if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
else field_trx__nr.clean_up();
if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
else field_ts__nr.clean_up();
if (other_value.spare().is_bound()) field_spare = other_value.spare();
else field_spare.clean_up();
}

void PCUIF__act__req::clean_up()
{
field_is__activate.clean_up();
field_trx__nr.clean_up();
field_ts__nr.clean_up();
field_spare.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__act__req::get_descriptor() const { return &PCUIF__act__req_descr_; }
PCUIF__act__req& PCUIF__act__req::operator=(const PCUIF__act__req& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_act_req.");
  if (other_value.is__activate().is_bound()) field_is__activate = other_value.is__activate();
  else field_is__activate.clean_up();
  if (other_value.trx__nr().is_bound()) field_trx__nr = other_value.trx__nr();
  else field_trx__nr.clean_up();
  if (other_value.ts__nr().is_bound()) field_ts__nr = other_value.ts__nr();
  else field_ts__nr.clean_up();
  if (other_value.spare().is_bound()) field_spare = other_value.spare();
  else field_spare.clean_up();
}
return *this;
}

boolean PCUIF__act__req::operator==(const PCUIF__act__req& other_value) const
{
return field_is__activate==other_value.field_is__activate
  && field_trx__nr==other_value.field_trx__nr
  && field_ts__nr==other_value.field_ts__nr
  && field_spare==other_value.field_spare;
}

boolean PCUIF__act__req::is_bound() const
{
if(field_is__activate.is_bound()) return TRUE;
if(field_trx__nr.is_bound()) return TRUE;
if(field_ts__nr.is_bound()) return TRUE;
if(field_spare.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__act__req::is_value() const
{
if(!field_is__activate.is_value()) return FALSE;
if(!field_trx__nr.is_value()) return FALSE;
if(!field_ts__nr.is_value()) return FALSE;
if(!field_spare.is_value()) return FALSE;
return TRUE;
}
void PCUIF__act__req::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ is_activate := ");
field_is__activate.log();
TTCN_Logger::log_event_str(", trx_nr := ");
field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
field_ts__nr.log();
TTCN_Logger::log_event_str(", spare := ");
field_spare.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__act__req::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_act_req has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) is__activate().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "is_activate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          is__activate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_act_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_act_req");
  }
}

void PCUIF__act__req::set_implicit_omit()
{
if (is__activate().is_bound()) is__activate().set_implicit_omit();
if (trx__nr().is_bound()) trx__nr().set_implicit_omit();
if (ts__nr().is_bound()) ts__nr().set_implicit_omit();
if (spare().is_bound()) spare().set_implicit_omit();
}

void PCUIF__act__req::encode_text(Text_Buf& text_buf) const
{
field_is__activate.encode_text(text_buf);
field_trx__nr.encode_text(text_buf);
field_ts__nr.encode_text(text_buf);
field_spare.encode_text(text_buf);
}

void PCUIF__act__req::decode_text(Text_Buf& text_buf)
{
field_is__activate.decode_text(text_buf);
field_trx__nr.decode_text(text_buf);
field_ts__nr.decode_text(text_buf);
field_spare.decode_text(text_buf);
}

void PCUIF__act__req::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__act__req::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__act__req::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__act__req_is__activate_descr_.raw->forceomit);
  decoded_field_length = field_is__activate.RAW_decode(PCUIF__act__req_is__activate_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__act__req_trx__nr_descr_.raw->forceomit);
  decoded_field_length = field_trx__nr.RAW_decode(PCUIF__act__req_trx__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__act__req_ts__nr_descr_.raw->forceomit);
  decoded_field_length = field_ts__nr.RAW_decode(PCUIF__act__req_ts__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__act__req_spare_descr_.raw->forceomit);
  decoded_field_length = field_spare.RAW_decode(PCUIF__act__req_spare_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__act__req::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__act__req_is__activate_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__act__req_trx__nr_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__act__req_ts__nr_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__act__req_spare_descr_.raw);
  encoded_length += field_is__activate.RAW_encode(PCUIF__act__req_is__activate_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_trx__nr.RAW_encode(PCUIF__act__req_trx__nr_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_ts__nr.RAW_encode(PCUIF__act__req_ts__nr_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_spare.RAW_encode(PCUIF__act__req_spare_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

struct PCUIF__act__req_template::single_value_struct {
INTEGER_template field_is__activate;
INTEGER_template field_trx__nr;
INTEGER_template field_ts__nr;
OCTETSTRING_template field_spare;
};

void PCUIF__act__req_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_is__activate = ANY_VALUE;
single_value->field_trx__nr = ANY_VALUE;
single_value->field_ts__nr = ANY_VALUE;
single_value->field_spare = ANY_VALUE;
}
}
}

void PCUIF__act__req_template::copy_value(const PCUIF__act__req& other_value)
{
single_value = new single_value_struct;
if (other_value.is__activate().is_bound()) {
  single_value->field_is__activate = other_value.is__activate();
} else {
  single_value->field_is__activate.clean_up();
}
if (other_value.trx__nr().is_bound()) {
  single_value->field_trx__nr = other_value.trx__nr();
} else {
  single_value->field_trx__nr.clean_up();
}
if (other_value.ts__nr().is_bound()) {
  single_value->field_ts__nr = other_value.ts__nr();
} else {
  single_value->field_ts__nr.clean_up();
}
if (other_value.spare().is_bound()) {
  single_value->field_spare = other_value.spare();
} else {
  single_value->field_spare.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__act__req_template::copy_template(const PCUIF__act__req_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.is__activate().get_selection()) {
single_value->field_is__activate = other_value.is__activate();
} else {
single_value->field_is__activate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trx__nr().get_selection()) {
single_value->field_trx__nr = other_value.trx__nr();
} else {
single_value->field_trx__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ts__nr().get_selection()) {
single_value->field_ts__nr = other_value.ts__nr();
} else {
single_value->field_ts__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare().get_selection()) {
single_value->field_spare = other_value.spare();
} else {
single_value->field_spare.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__act__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_act_req.");
break;
}
set_selection(other_value);
}

PCUIF__act__req_template::PCUIF__act__req_template()
{
}

PCUIF__act__req_template::PCUIF__act__req_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__act__req_template::PCUIF__act__req_template(const PCUIF__act__req& other_value)
{
copy_value(other_value);
}

PCUIF__act__req_template::PCUIF__act__req_template(const OPTIONAL<PCUIF__act__req>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__act__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_act_req from an unbound optional field.");
}
}

PCUIF__act__req_template::PCUIF__act__req_template(const PCUIF__act__req_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__act__req_template::~PCUIF__act__req_template()
{
clean_up();
}

PCUIF__act__req_template& PCUIF__act__req_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__act__req_template& PCUIF__act__req_template::operator=(const PCUIF__act__req& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__act__req_template& PCUIF__act__req_template::operator=(const OPTIONAL<PCUIF__act__req>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__act__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_act_req.");
}
return *this;
}

PCUIF__act__req_template& PCUIF__act__req_template::operator=(const PCUIF__act__req_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__act__req_template::match(const PCUIF__act__req& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.is__activate().is_bound()) return FALSE;
if(!single_value->field_is__activate.match(other_value.is__activate(), legacy))return FALSE;
if(!other_value.trx__nr().is_bound()) return FALSE;
if(!single_value->field_trx__nr.match(other_value.trx__nr(), legacy))return FALSE;
if(!other_value.ts__nr().is_bound()) return FALSE;
if(!single_value->field_ts__nr.match(other_value.ts__nr(), legacy))return FALSE;
if(!other_value.spare().is_bound()) return FALSE;
if(!single_value->field_spare.match(other_value.spare(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_act_req.");
}
return FALSE;
}

boolean PCUIF__act__req_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_is__activate.is_bound()) return TRUE;
if (single_value->field_trx__nr.is_bound()) return TRUE;
if (single_value->field_ts__nr.is_bound()) return TRUE;
if (single_value->field_spare.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__act__req_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_is__activate.is_value()) return FALSE;
if (!single_value->field_trx__nr.is_value()) return FALSE;
if (!single_value->field_ts__nr.is_value()) return FALSE;
if (!single_value->field_spare.is_value()) return FALSE;
return TRUE;
}

void PCUIF__act__req_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__act__req PCUIF__act__req_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_act_req.");
PCUIF__act__req ret_val;
if (single_value->field_is__activate.is_bound()) {
ret_val.is__activate() = single_value->field_is__activate.valueof();
}
if (single_value->field_trx__nr.is_bound()) {
ret_val.trx__nr() = single_value->field_trx__nr.valueof();
}
if (single_value->field_ts__nr.is_bound()) {
ret_val.ts__nr() = single_value->field_ts__nr.valueof();
}
if (single_value->field_spare.is_bound()) {
ret_val.spare() = single_value->field_spare.valueof();
}
return ret_val;
}

void PCUIF__act__req_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_act_req.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__act__req_template[list_length];
}

PCUIF__act__req_template& PCUIF__act__req_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_act_req.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_act_req.");
return value_list.list_value[list_index];
}

INTEGER_template& PCUIF__act__req_template::is__activate()
{
set_specific();
return single_value->field_is__activate;
}

const INTEGER_template& PCUIF__act__req_template::is__activate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field is_activate of a non-specific template of type @PCUIF_Types.PCUIF_act_req.");
return single_value->field_is__activate;
}

INTEGER_template& PCUIF__act__req_template::trx__nr()
{
set_specific();
return single_value->field_trx__nr;
}

const INTEGER_template& PCUIF__act__req_template::trx__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trx_nr of a non-specific template of type @PCUIF_Types.PCUIF_act_req.");
return single_value->field_trx__nr;
}

INTEGER_template& PCUIF__act__req_template::ts__nr()
{
set_specific();
return single_value->field_ts__nr;
}

const INTEGER_template& PCUIF__act__req_template::ts__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ts_nr of a non-specific template of type @PCUIF_Types.PCUIF_act_req.");
return single_value->field_ts__nr;
}

OCTETSTRING_template& PCUIF__act__req_template::spare()
{
set_specific();
return single_value->field_spare;
}

const OCTETSTRING_template& PCUIF__act__req_template::spare() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare of a non-specific template of type @PCUIF_Types.PCUIF_act_req.");
return single_value->field_spare;
}

int PCUIF__act__req_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_act_req containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_act_req.");
  }
  return 0;
}

void PCUIF__act__req_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ is_activate := ");
single_value->field_is__activate.log();
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log();
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log();
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__act__req_template::log_match(const PCUIF__act__req& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_is__activate.match(match_value.is__activate(), legacy)){
TTCN_Logger::log_logmatch_info(".is_activate");
single_value->field_is__activate.log_match(match_value.is__activate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trx__nr.match(match_value.trx__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".trx_nr");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ts__nr.match(match_value.ts__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".ts_nr");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare.match(match_value.spare(), legacy)){
TTCN_Logger::log_logmatch_info(".spare");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ is_activate := ");
single_value->field_is__activate.log_match(match_value.is__activate(), legacy);
TTCN_Logger::log_event_str(", trx_nr := ");
single_value->field_trx__nr.log_match(match_value.trx__nr(), legacy);
TTCN_Logger::log_event_str(", ts_nr := ");
single_value->field_ts__nr.log_match(match_value.ts__nr(), legacy);
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__act__req_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_is__activate.encode_text(text_buf);
single_value->field_trx__nr.encode_text(text_buf);
single_value->field_ts__nr.encode_text(text_buf);
single_value->field_spare.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_act_req.");
}
}

void PCUIF__act__req_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_is__activate.decode_text(text_buf);
single_value->field_trx__nr.decode_text(text_buf);
single_value->field_ts__nr.decode_text(text_buf);
single_value->field_spare.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__act__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_act_req.");
}
}

void PCUIF__act__req_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__act__req_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_act_req has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) is__activate().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trx__nr().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ts__nr().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "is_activate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          is__activate().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trx_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trx__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_act_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_act_req");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__act__req_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_is__activate.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_act_req");
single_value->field_trx__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_act_req");
single_value->field_ts__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_act_req");
single_value->field_spare.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_act_req");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_act_req");
}

boolean PCUIF__act__req_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__act__req_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__time__ind::PCUIF__time__ind()
{
}

PCUIF__time__ind::PCUIF__time__ind(const INTEGER& par_fn)
  :   field_fn(par_fn)
{
}

PCUIF__time__ind::PCUIF__time__ind(const PCUIF__time__ind& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_time_ind.");
if (other_value.fn().is_bound()) field_fn = other_value.fn();
else field_fn.clean_up();
}

void PCUIF__time__ind::clean_up()
{
field_fn.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__time__ind::get_descriptor() const { return &PCUIF__time__ind_descr_; }
PCUIF__time__ind& PCUIF__time__ind::operator=(const PCUIF__time__ind& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_time_ind.");
  if (other_value.fn().is_bound()) field_fn = other_value.fn();
  else field_fn.clean_up();
}
return *this;
}

boolean PCUIF__time__ind::operator==(const PCUIF__time__ind& other_value) const
{
return field_fn==other_value.field_fn;
}

boolean PCUIF__time__ind::is_bound() const
{
if(field_fn.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__time__ind::is_value() const
{
if(!field_fn.is_value()) return FALSE;
return TRUE;
}
void PCUIF__time__ind::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ fn := ");
field_fn.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__time__ind::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_time_ind has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_time_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_time_ind");
  }
}

void PCUIF__time__ind::set_implicit_omit()
{
if (fn().is_bound()) fn().set_implicit_omit();
}

void PCUIF__time__ind::encode_text(Text_Buf& text_buf) const
{
field_fn.encode_text(text_buf);
}

void PCUIF__time__ind::decode_text(Text_Buf& text_buf)
{
field_fn.decode_text(text_buf);
}

void PCUIF__time__ind::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__time__ind::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__time__ind::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__time__ind_fn_descr_.raw->forceomit);
  decoded_field_length = field_fn.RAW_decode(PCUIF__time__ind_fn_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__time__ind::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__time__ind_fn_descr_.raw);
  encoded_length += field_fn.RAW_encode(PCUIF__time__ind_fn_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

struct PCUIF__time__ind_template::single_value_struct {
INTEGER_template field_fn;
};

void PCUIF__time__ind_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_fn = ANY_VALUE;
}
}
}

void PCUIF__time__ind_template::copy_value(const PCUIF__time__ind& other_value)
{
single_value = new single_value_struct;
if (other_value.fn().is_bound()) {
  single_value->field_fn = other_value.fn();
} else {
  single_value->field_fn.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__time__ind_template::copy_template(const PCUIF__time__ind_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.fn().get_selection()) {
single_value->field_fn = other_value.fn();
} else {
single_value->field_fn.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__time__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_time_ind.");
break;
}
set_selection(other_value);
}

PCUIF__time__ind_template::PCUIF__time__ind_template()
{
}

PCUIF__time__ind_template::PCUIF__time__ind_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__time__ind_template::PCUIF__time__ind_template(const PCUIF__time__ind& other_value)
{
copy_value(other_value);
}

PCUIF__time__ind_template::PCUIF__time__ind_template(const OPTIONAL<PCUIF__time__ind>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__time__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_time_ind from an unbound optional field.");
}
}

PCUIF__time__ind_template::PCUIF__time__ind_template(const PCUIF__time__ind_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__time__ind_template::~PCUIF__time__ind_template()
{
clean_up();
}

PCUIF__time__ind_template& PCUIF__time__ind_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__time__ind_template& PCUIF__time__ind_template::operator=(const PCUIF__time__ind& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__time__ind_template& PCUIF__time__ind_template::operator=(const OPTIONAL<PCUIF__time__ind>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__time__ind&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_time_ind.");
}
return *this;
}

PCUIF__time__ind_template& PCUIF__time__ind_template::operator=(const PCUIF__time__ind_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__time__ind_template::match(const PCUIF__time__ind& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.fn().is_bound()) return FALSE;
if(!single_value->field_fn.match(other_value.fn(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_time_ind.");
}
return FALSE;
}

boolean PCUIF__time__ind_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_fn.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__time__ind_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_fn.is_value()) return FALSE;
return TRUE;
}

void PCUIF__time__ind_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__time__ind PCUIF__time__ind_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_time_ind.");
PCUIF__time__ind ret_val;
if (single_value->field_fn.is_bound()) {
ret_val.fn() = single_value->field_fn.valueof();
}
return ret_val;
}

void PCUIF__time__ind_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_time_ind.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__time__ind_template[list_length];
}

PCUIF__time__ind_template& PCUIF__time__ind_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_time_ind.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_time_ind.");
return value_list.list_value[list_index];
}

INTEGER_template& PCUIF__time__ind_template::fn()
{
set_specific();
return single_value->field_fn;
}

const INTEGER_template& PCUIF__time__ind_template::fn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field fn of a non-specific template of type @PCUIF_Types.PCUIF_time_ind.");
return single_value->field_fn;
}

int PCUIF__time__ind_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_time_ind containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_time_ind.");
  }
  return 0;
}

void PCUIF__time__ind_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ fn := ");
single_value->field_fn.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__time__ind_template::log_match(const PCUIF__time__ind& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_fn.match(match_value.fn(), legacy)){
TTCN_Logger::log_logmatch_info(".fn");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ fn := ");
single_value->field_fn.log_match(match_value.fn(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__time__ind_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_fn.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_time_ind.");
}
}

void PCUIF__time__ind_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_fn.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__time__ind_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_time_ind.");
}
}

void PCUIF__time__ind_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__time__ind_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_time_ind has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) fn().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "fn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          fn().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_time_ind: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_time_ind");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__time__ind_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_fn.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_time_ind");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_time_ind");
}

boolean PCUIF__time__ind_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__time__ind_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__pag__req::PCUIF__pag__req()
{
}

PCUIF__pag__req::PCUIF__pag__req(const PCUIF__Sapi& par_sapi,
    const INTEGER& par_chan__needed,
    const OCTETSTRING& par_identity__lv)
  :   field_sapi(par_sapi),
  field_chan__needed(par_chan__needed),
  field_identity__lv(par_identity__lv)
{
}

PCUIF__pag__req::PCUIF__pag__req(const PCUIF__pag__req& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_pag_req.");
if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
else field_sapi.clean_up();
if (other_value.chan__needed().is_bound()) field_chan__needed = other_value.chan__needed();
else field_chan__needed.clean_up();
if (other_value.identity__lv().is_bound()) field_identity__lv = other_value.identity__lv();
else field_identity__lv.clean_up();
}

void PCUIF__pag__req::clean_up()
{
field_sapi.clean_up();
field_chan__needed.clean_up();
field_identity__lv.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__pag__req::get_descriptor() const { return &PCUIF__pag__req_descr_; }
PCUIF__pag__req& PCUIF__pag__req::operator=(const PCUIF__pag__req& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_pag_req.");
  if (other_value.sapi().is_bound()) field_sapi = other_value.sapi();
  else field_sapi.clean_up();
  if (other_value.chan__needed().is_bound()) field_chan__needed = other_value.chan__needed();
  else field_chan__needed.clean_up();
  if (other_value.identity__lv().is_bound()) field_identity__lv = other_value.identity__lv();
  else field_identity__lv.clean_up();
}
return *this;
}

boolean PCUIF__pag__req::operator==(const PCUIF__pag__req& other_value) const
{
return field_sapi==other_value.field_sapi
  && field_chan__needed==other_value.field_chan__needed
  && field_identity__lv==other_value.field_identity__lv;
}

boolean PCUIF__pag__req::is_bound() const
{
if(field_sapi.is_bound()) return TRUE;
if(field_chan__needed.is_bound()) return TRUE;
if(field_identity__lv.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__pag__req::is_value() const
{
if(!field_sapi.is_value()) return FALSE;
if(!field_chan__needed.is_value()) return FALSE;
if(!field_identity__lv.is_value()) return FALSE;
return TRUE;
}
void PCUIF__pag__req::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sapi := ");
field_sapi.log();
TTCN_Logger::log_event_str(", chan_needed := ");
field_chan__needed.log();
TTCN_Logger::log_event_str(", identity_lv := ");
field_identity__lv.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__pag__req::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_pag_req has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) chan__needed().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) identity__lv().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "chan_needed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          chan__needed().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "identity_lv")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          identity__lv().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_pag_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_pag_req");
  }
}

void PCUIF__pag__req::set_implicit_omit()
{
if (sapi().is_bound()) sapi().set_implicit_omit();
if (chan__needed().is_bound()) chan__needed().set_implicit_omit();
if (identity__lv().is_bound()) identity__lv().set_implicit_omit();
}

void PCUIF__pag__req::encode_text(Text_Buf& text_buf) const
{
field_sapi.encode_text(text_buf);
field_chan__needed.encode_text(text_buf);
field_identity__lv.encode_text(text_buf);
}

void PCUIF__pag__req::decode_text(Text_Buf& text_buf)
{
field_sapi.decode_text(text_buf);
field_chan__needed.decode_text(text_buf);
field_identity__lv.decode_text(text_buf);
}

void PCUIF__pag__req::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__pag__req::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__pag__req::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__pag__req_sapi_descr_.raw->forceomit);
  decoded_field_length = field_sapi.RAW_decode(PCUIF__pag__req_sapi_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__pag__req_chan__needed_descr_.raw->forceomit);
  decoded_field_length = field_chan__needed.RAW_decode(PCUIF__pag__req_chan__needed_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__pag__req_identity__lv_descr_.raw->forceomit);
  decoded_field_length = field_identity__lv.RAW_decode(PCUIF__pag__req_identity__lv_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__pag__req::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__pag__req_sapi_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__pag__req_chan__needed_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__pag__req_identity__lv_descr_.raw);
  encoded_length += field_sapi.RAW_encode(PCUIF__pag__req_sapi_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_chan__needed.RAW_encode(PCUIF__pag__req_chan__needed_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_identity__lv.RAW_encode(PCUIF__pag__req_identity__lv_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

struct PCUIF__pag__req_template::single_value_struct {
PCUIF__Sapi_template field_sapi;
INTEGER_template field_chan__needed;
OCTETSTRING_template field_identity__lv;
};

void PCUIF__pag__req_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sapi = ANY_VALUE;
single_value->field_chan__needed = ANY_VALUE;
single_value->field_identity__lv = ANY_VALUE;
}
}
}

void PCUIF__pag__req_template::copy_value(const PCUIF__pag__req& other_value)
{
single_value = new single_value_struct;
if (other_value.sapi().is_bound()) {
  single_value->field_sapi = other_value.sapi();
} else {
  single_value->field_sapi.clean_up();
}
if (other_value.chan__needed().is_bound()) {
  single_value->field_chan__needed = other_value.chan__needed();
} else {
  single_value->field_chan__needed.clean_up();
}
if (other_value.identity__lv().is_bound()) {
  single_value->field_identity__lv = other_value.identity__lv();
} else {
  single_value->field_identity__lv.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__pag__req_template::copy_template(const PCUIF__pag__req_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sapi().get_selection()) {
single_value->field_sapi = other_value.sapi();
} else {
single_value->field_sapi.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.chan__needed().get_selection()) {
single_value->field_chan__needed = other_value.chan__needed();
} else {
single_value->field_chan__needed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.identity__lv().get_selection()) {
single_value->field_identity__lv = other_value.identity__lv();
} else {
single_value->field_identity__lv.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__pag__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_pag_req.");
break;
}
set_selection(other_value);
}

PCUIF__pag__req_template::PCUIF__pag__req_template()
{
}

PCUIF__pag__req_template::PCUIF__pag__req_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__pag__req_template::PCUIF__pag__req_template(const PCUIF__pag__req& other_value)
{
copy_value(other_value);
}

PCUIF__pag__req_template::PCUIF__pag__req_template(const OPTIONAL<PCUIF__pag__req>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__pag__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_pag_req from an unbound optional field.");
}
}

PCUIF__pag__req_template::PCUIF__pag__req_template(const PCUIF__pag__req_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__pag__req_template::~PCUIF__pag__req_template()
{
clean_up();
}

PCUIF__pag__req_template& PCUIF__pag__req_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__pag__req_template& PCUIF__pag__req_template::operator=(const PCUIF__pag__req& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__pag__req_template& PCUIF__pag__req_template::operator=(const OPTIONAL<PCUIF__pag__req>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__pag__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_pag_req.");
}
return *this;
}

PCUIF__pag__req_template& PCUIF__pag__req_template::operator=(const PCUIF__pag__req_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__pag__req_template::match(const PCUIF__pag__req& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sapi().is_bound()) return FALSE;
if(!single_value->field_sapi.match(other_value.sapi(), legacy))return FALSE;
if(!other_value.chan__needed().is_bound()) return FALSE;
if(!single_value->field_chan__needed.match(other_value.chan__needed(), legacy))return FALSE;
if(!other_value.identity__lv().is_bound()) return FALSE;
if(!single_value->field_identity__lv.match(other_value.identity__lv(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_pag_req.");
}
return FALSE;
}

boolean PCUIF__pag__req_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sapi.is_bound()) return TRUE;
if (single_value->field_chan__needed.is_bound()) return TRUE;
if (single_value->field_identity__lv.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__pag__req_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sapi.is_value()) return FALSE;
if (!single_value->field_chan__needed.is_value()) return FALSE;
if (!single_value->field_identity__lv.is_value()) return FALSE;
return TRUE;
}

void PCUIF__pag__req_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__pag__req PCUIF__pag__req_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_pag_req.");
PCUIF__pag__req ret_val;
if (single_value->field_sapi.is_bound()) {
ret_val.sapi() = single_value->field_sapi.valueof();
}
if (single_value->field_chan__needed.is_bound()) {
ret_val.chan__needed() = single_value->field_chan__needed.valueof();
}
if (single_value->field_identity__lv.is_bound()) {
ret_val.identity__lv() = single_value->field_identity__lv.valueof();
}
return ret_val;
}

void PCUIF__pag__req_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_pag_req.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__pag__req_template[list_length];
}

PCUIF__pag__req_template& PCUIF__pag__req_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_pag_req.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_pag_req.");
return value_list.list_value[list_index];
}

PCUIF__Sapi_template& PCUIF__pag__req_template::sapi()
{
set_specific();
return single_value->field_sapi;
}

const PCUIF__Sapi_template& PCUIF__pag__req_template::sapi() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sapi of a non-specific template of type @PCUIF_Types.PCUIF_pag_req.");
return single_value->field_sapi;
}

INTEGER_template& PCUIF__pag__req_template::chan__needed()
{
set_specific();
return single_value->field_chan__needed;
}

const INTEGER_template& PCUIF__pag__req_template::chan__needed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field chan_needed of a non-specific template of type @PCUIF_Types.PCUIF_pag_req.");
return single_value->field_chan__needed;
}

OCTETSTRING_template& PCUIF__pag__req_template::identity__lv()
{
set_specific();
return single_value->field_identity__lv;
}

const OCTETSTRING_template& PCUIF__pag__req_template::identity__lv() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field identity_lv of a non-specific template of type @PCUIF_Types.PCUIF_pag_req.");
return single_value->field_identity__lv;
}

int PCUIF__pag__req_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_pag_req containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_pag_req.");
  }
  return 0;
}

void PCUIF__pag__req_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log();
TTCN_Logger::log_event_str(", chan_needed := ");
single_value->field_chan__needed.log();
TTCN_Logger::log_event_str(", identity_lv := ");
single_value->field_identity__lv.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__pag__req_template::log_match(const PCUIF__pag__req& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_sapi.match(match_value.sapi(), legacy)){
TTCN_Logger::log_logmatch_info(".sapi");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_chan__needed.match(match_value.chan__needed(), legacy)){
TTCN_Logger::log_logmatch_info(".chan_needed");
single_value->field_chan__needed.log_match(match_value.chan__needed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_identity__lv.match(match_value.identity__lv(), legacy)){
TTCN_Logger::log_logmatch_info(".identity_lv");
single_value->field_identity__lv.log_match(match_value.identity__lv(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sapi := ");
single_value->field_sapi.log_match(match_value.sapi(), legacy);
TTCN_Logger::log_event_str(", chan_needed := ");
single_value->field_chan__needed.log_match(match_value.chan__needed(), legacy);
TTCN_Logger::log_event_str(", identity_lv := ");
single_value->field_identity__lv.log_match(match_value.identity__lv(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__pag__req_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sapi.encode_text(text_buf);
single_value->field_chan__needed.encode_text(text_buf);
single_value->field_identity__lv.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_pag_req.");
}
}

void PCUIF__pag__req_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sapi.decode_text(text_buf);
single_value->field_chan__needed.decode_text(text_buf);
single_value->field_identity__lv.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__pag__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_pag_req.");
}
}

void PCUIF__pag__req_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__pag__req_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_pag_req has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sapi().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) chan__needed().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) identity__lv().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sapi")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sapi().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "chan_needed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          chan__needed().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "identity_lv")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          identity__lv().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_pag_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_pag_req");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__pag__req_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sapi.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_pag_req");
single_value->field_chan__needed.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_pag_req");
single_value->field_identity__lv.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_pag_req");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_pag_req");
}

boolean PCUIF__pag__req_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__pag__req_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PCUIF__susp__req::PCUIF__susp__req()
{
}

PCUIF__susp__req::PCUIF__susp__req(const OCTETSTRING& par_tlli,
    const OCTETSTRING& par_ra__id,
    const INTEGER& par_cause)
  :   field_tlli(par_tlli),
  field_ra__id(par_ra__id),
  field_cause(par_cause)
{
}

PCUIF__susp__req::PCUIF__susp__req(const PCUIF__susp__req& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_susp_req.");
if (other_value.tlli().is_bound()) field_tlli = other_value.tlli();
else field_tlli.clean_up();
if (other_value.ra__id().is_bound()) field_ra__id = other_value.ra__id();
else field_ra__id.clean_up();
if (other_value.cause().is_bound()) field_cause = other_value.cause();
else field_cause.clean_up();
}

void PCUIF__susp__req::clean_up()
{
field_tlli.clean_up();
field_ra__id.clean_up();
field_cause.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__susp__req::get_descriptor() const { return &PCUIF__susp__req_descr_; }
PCUIF__susp__req& PCUIF__susp__req::operator=(const PCUIF__susp__req& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_susp_req.");
  if (other_value.tlli().is_bound()) field_tlli = other_value.tlli();
  else field_tlli.clean_up();
  if (other_value.ra__id().is_bound()) field_ra__id = other_value.ra__id();
  else field_ra__id.clean_up();
  if (other_value.cause().is_bound()) field_cause = other_value.cause();
  else field_cause.clean_up();
}
return *this;
}

boolean PCUIF__susp__req::operator==(const PCUIF__susp__req& other_value) const
{
return field_tlli==other_value.field_tlli
  && field_ra__id==other_value.field_ra__id
  && field_cause==other_value.field_cause;
}

boolean PCUIF__susp__req::is_bound() const
{
if(field_tlli.is_bound()) return TRUE;
if(field_ra__id.is_bound()) return TRUE;
if(field_cause.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__susp__req::is_value() const
{
if(!field_tlli.is_value()) return FALSE;
if(!field_ra__id.is_value()) return FALSE;
if(!field_cause.is_value()) return FALSE;
return TRUE;
}
void PCUIF__susp__req::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ tlli := ");
field_tlli.log();
TTCN_Logger::log_event_str(", ra_id := ");
field_ra__id.log();
TTCN_Logger::log_event_str(", cause := ");
field_cause.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__susp__req::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_susp_req has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) tlli().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ra__id().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) cause().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlli")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlli().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ra_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ra__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cause().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_susp_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_susp_req");
  }
}

void PCUIF__susp__req::set_implicit_omit()
{
if (tlli().is_bound()) tlli().set_implicit_omit();
if (ra__id().is_bound()) ra__id().set_implicit_omit();
if (cause().is_bound()) cause().set_implicit_omit();
}

void PCUIF__susp__req::encode_text(Text_Buf& text_buf) const
{
field_tlli.encode_text(text_buf);
field_ra__id.encode_text(text_buf);
field_cause.encode_text(text_buf);
}

void PCUIF__susp__req::decode_text(Text_Buf& text_buf)
{
field_tlli.decode_text(text_buf);
field_ra__id.decode_text(text_buf);
field_cause.decode_text(text_buf);
}

void PCUIF__susp__req::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__susp__req::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__susp__req::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__susp__req_tlli_descr_.raw->forceomit);
  decoded_field_length = field_tlli.RAW_decode(PCUIF__susp__req_tlli_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__susp__req_ra__id_descr_.raw->forceomit);
  decoded_field_length = field_ra__id.RAW_decode(PCUIF__susp__req_ra__id_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__susp__req_cause_descr_.raw->forceomit);
  decoded_field_length = field_cause.RAW_decode(PCUIF__susp__req_cause_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__susp__req::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__susp__req_tlli_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__susp__req_ra__id_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__susp__req_cause_descr_.raw);
  encoded_length += field_tlli.RAW_encode(PCUIF__susp__req_tlli_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_ra__id.RAW_encode(PCUIF__susp__req_ra__id_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_cause.RAW_encode(PCUIF__susp__req_cause_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

struct PCUIF__susp__req_template::single_value_struct {
OCTETSTRING_template field_tlli;
OCTETSTRING_template field_ra__id;
INTEGER_template field_cause;
};

void PCUIF__susp__req_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_tlli = ANY_VALUE;
single_value->field_ra__id = ANY_VALUE;
single_value->field_cause = ANY_VALUE;
}
}
}

void PCUIF__susp__req_template::copy_value(const PCUIF__susp__req& other_value)
{
single_value = new single_value_struct;
if (other_value.tlli().is_bound()) {
  single_value->field_tlli = other_value.tlli();
} else {
  single_value->field_tlli.clean_up();
}
if (other_value.ra__id().is_bound()) {
  single_value->field_ra__id = other_value.ra__id();
} else {
  single_value->field_ra__id.clean_up();
}
if (other_value.cause().is_bound()) {
  single_value->field_cause = other_value.cause();
} else {
  single_value->field_cause.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__susp__req_template::copy_template(const PCUIF__susp__req_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.tlli().get_selection()) {
single_value->field_tlli = other_value.tlli();
} else {
single_value->field_tlli.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ra__id().get_selection()) {
single_value->field_ra__id = other_value.ra__id();
} else {
single_value->field_ra__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cause().get_selection()) {
single_value->field_cause = other_value.cause();
} else {
single_value->field_cause.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__susp__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_susp_req.");
break;
}
set_selection(other_value);
}

PCUIF__susp__req_template::PCUIF__susp__req_template()
{
}

PCUIF__susp__req_template::PCUIF__susp__req_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__susp__req_template::PCUIF__susp__req_template(const PCUIF__susp__req& other_value)
{
copy_value(other_value);
}

PCUIF__susp__req_template::PCUIF__susp__req_template(const OPTIONAL<PCUIF__susp__req>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__susp__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_susp_req from an unbound optional field.");
}
}

PCUIF__susp__req_template::PCUIF__susp__req_template(const PCUIF__susp__req_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__susp__req_template::~PCUIF__susp__req_template()
{
clean_up();
}

PCUIF__susp__req_template& PCUIF__susp__req_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__susp__req_template& PCUIF__susp__req_template::operator=(const PCUIF__susp__req& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__susp__req_template& PCUIF__susp__req_template::operator=(const OPTIONAL<PCUIF__susp__req>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__susp__req&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_susp_req.");
}
return *this;
}

PCUIF__susp__req_template& PCUIF__susp__req_template::operator=(const PCUIF__susp__req_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__susp__req_template::match(const PCUIF__susp__req& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.tlli().is_bound()) return FALSE;
if(!single_value->field_tlli.match(other_value.tlli(), legacy))return FALSE;
if(!other_value.ra__id().is_bound()) return FALSE;
if(!single_value->field_ra__id.match(other_value.ra__id(), legacy))return FALSE;
if(!other_value.cause().is_bound()) return FALSE;
if(!single_value->field_cause.match(other_value.cause(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_susp_req.");
}
return FALSE;
}

boolean PCUIF__susp__req_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_tlli.is_bound()) return TRUE;
if (single_value->field_ra__id.is_bound()) return TRUE;
if (single_value->field_cause.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__susp__req_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_tlli.is_value()) return FALSE;
if (!single_value->field_ra__id.is_value()) return FALSE;
if (!single_value->field_cause.is_value()) return FALSE;
return TRUE;
}

void PCUIF__susp__req_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__susp__req PCUIF__susp__req_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_susp_req.");
PCUIF__susp__req ret_val;
if (single_value->field_tlli.is_bound()) {
ret_val.tlli() = single_value->field_tlli.valueof();
}
if (single_value->field_ra__id.is_bound()) {
ret_val.ra__id() = single_value->field_ra__id.valueof();
}
if (single_value->field_cause.is_bound()) {
ret_val.cause() = single_value->field_cause.valueof();
}
return ret_val;
}

void PCUIF__susp__req_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_susp_req.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__susp__req_template[list_length];
}

PCUIF__susp__req_template& PCUIF__susp__req_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_susp_req.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_susp_req.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& PCUIF__susp__req_template::tlli()
{
set_specific();
return single_value->field_tlli;
}

const OCTETSTRING_template& PCUIF__susp__req_template::tlli() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tlli of a non-specific template of type @PCUIF_Types.PCUIF_susp_req.");
return single_value->field_tlli;
}

OCTETSTRING_template& PCUIF__susp__req_template::ra__id()
{
set_specific();
return single_value->field_ra__id;
}

const OCTETSTRING_template& PCUIF__susp__req_template::ra__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ra_id of a non-specific template of type @PCUIF_Types.PCUIF_susp_req.");
return single_value->field_ra__id;
}

INTEGER_template& PCUIF__susp__req_template::cause()
{
set_specific();
return single_value->field_cause;
}

const INTEGER_template& PCUIF__susp__req_template::cause() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cause of a non-specific template of type @PCUIF_Types.PCUIF_susp_req.");
return single_value->field_cause;
}

int PCUIF__susp__req_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_susp_req containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_susp_req.");
  }
  return 0;
}

void PCUIF__susp__req_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ tlli := ");
single_value->field_tlli.log();
TTCN_Logger::log_event_str(", ra_id := ");
single_value->field_ra__id.log();
TTCN_Logger::log_event_str(", cause := ");
single_value->field_cause.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__susp__req_template::log_match(const PCUIF__susp__req& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_tlli.match(match_value.tlli(), legacy)){
TTCN_Logger::log_logmatch_info(".tlli");
single_value->field_tlli.log_match(match_value.tlli(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ra__id.match(match_value.ra__id(), legacy)){
TTCN_Logger::log_logmatch_info(".ra_id");
single_value->field_ra__id.log_match(match_value.ra__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cause.match(match_value.cause(), legacy)){
TTCN_Logger::log_logmatch_info(".cause");
single_value->field_cause.log_match(match_value.cause(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ tlli := ");
single_value->field_tlli.log_match(match_value.tlli(), legacy);
TTCN_Logger::log_event_str(", ra_id := ");
single_value->field_ra__id.log_match(match_value.ra__id(), legacy);
TTCN_Logger::log_event_str(", cause := ");
single_value->field_cause.log_match(match_value.cause(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__susp__req_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_tlli.encode_text(text_buf);
single_value->field_ra__id.encode_text(text_buf);
single_value->field_cause.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_susp_req.");
}
}

void PCUIF__susp__req_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_tlli.decode_text(text_buf);
single_value->field_ra__id.decode_text(text_buf);
single_value->field_cause.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__susp__req_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_susp_req.");
}
}

void PCUIF__susp__req_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__susp__req_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_susp_req has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) tlli().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ra__id().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) cause().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tlli")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tlli().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ra_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ra__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cause().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_susp_req: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_susp_req");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__susp__req_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_tlli.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_susp_req");
single_value->field_ra__id.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_susp_req");
single_value->field_cause.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_susp_req");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_susp_req");
}

boolean PCUIF__susp__req_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__susp__req_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__MsgUnion::copy_value(const PCUIF__MsgUnion& other_value)
{
switch (other_value.union_selection) {
case ALT_data__req:
field_data__req = new PCUIF__data(*other_value.field_data__req);
break;
case ALT_data__cnf:
field_data__cnf = new PCUIF__data(*other_value.field_data__cnf);
break;
case ALT_data__cnf__dt:
field_data__cnf__dt = new PCUIF__data__cnf__dt(*other_value.field_data__cnf__dt);
break;
case ALT_data__ind:
field_data__ind = new PCUIF__data(*other_value.field_data__ind);
break;
case ALT_susp__req:
field_susp__req = new PCUIF__susp__req(*other_value.field_susp__req);
break;
case ALT_rts__req:
field_rts__req = new PCUIF__rts__req(*other_value.field_rts__req);
break;
case ALT_rach__ind:
field_rach__ind = new PCUIF__rach__ind(*other_value.field_rach__ind);
break;
case ALT_txt__ind:
field_txt__ind = new PCUIF__txt__ind(*other_value.field_txt__ind);
break;
case ALT_info__ind:
field_info__ind = new PCUIF__info__ind(*other_value.field_info__ind);
break;
case ALT_act__req:
field_act__req = new PCUIF__act__req(*other_value.field_act__req);
break;
case ALT_time__ind:
field_time__ind = new PCUIF__time__ind(*other_value.field_time__ind);
break;
case ALT_pag__req:
field_pag__req = new PCUIF__pag__req(*other_value.field_pag__req);
break;
default:
TTCN_error("Assignment of an unbound union value of type @PCUIF_Types.PCUIF_MsgUnion.");
}
union_selection = other_value.union_selection;
}

PCUIF__MsgUnion::PCUIF__MsgUnion()
{
union_selection = UNBOUND_VALUE;
}

PCUIF__MsgUnion::PCUIF__MsgUnion(const PCUIF__MsgUnion& other_value)
: Base_Type(){
copy_value(other_value);
}

PCUIF__MsgUnion::~PCUIF__MsgUnion()
{
clean_up();
}

PCUIF__MsgUnion& PCUIF__MsgUnion::operator=(const PCUIF__MsgUnion& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean PCUIF__MsgUnion::operator==(const PCUIF__MsgUnion& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_data__req:
return *field_data__req == *other_value.field_data__req;
case ALT_data__cnf:
return *field_data__cnf == *other_value.field_data__cnf;
case ALT_data__cnf__dt:
return *field_data__cnf__dt == *other_value.field_data__cnf__dt;
case ALT_data__ind:
return *field_data__ind == *other_value.field_data__ind;
case ALT_susp__req:
return *field_susp__req == *other_value.field_susp__req;
case ALT_rts__req:
return *field_rts__req == *other_value.field_rts__req;
case ALT_rach__ind:
return *field_rach__ind == *other_value.field_rach__ind;
case ALT_txt__ind:
return *field_txt__ind == *other_value.field_txt__ind;
case ALT_info__ind:
return *field_info__ind == *other_value.field_info__ind;
case ALT_act__req:
return *field_act__req == *other_value.field_act__req;
case ALT_time__ind:
return *field_time__ind == *other_value.field_time__ind;
case ALT_pag__req:
return *field_pag__req == *other_value.field_pag__req;
default:
return FALSE;
}
}

PCUIF__data& PCUIF__MsgUnion::data__req()
{
if (union_selection != ALT_data__req) {
clean_up();
field_data__req = new PCUIF__data;
union_selection = ALT_data__req;
}
return *field_data__req;
}

const PCUIF__data& PCUIF__MsgUnion::data__req() const
{
if (union_selection != ALT_data__req) TTCN_error("Using non-selected field data_req in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_data__req;
}

PCUIF__data& PCUIF__MsgUnion::data__cnf()
{
if (union_selection != ALT_data__cnf) {
clean_up();
field_data__cnf = new PCUIF__data;
union_selection = ALT_data__cnf;
}
return *field_data__cnf;
}

const PCUIF__data& PCUIF__MsgUnion::data__cnf() const
{
if (union_selection != ALT_data__cnf) TTCN_error("Using non-selected field data_cnf in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_data__cnf;
}

PCUIF__data__cnf__dt& PCUIF__MsgUnion::data__cnf__dt()
{
if (union_selection != ALT_data__cnf__dt) {
clean_up();
field_data__cnf__dt = new PCUIF__data__cnf__dt;
union_selection = ALT_data__cnf__dt;
}
return *field_data__cnf__dt;
}

const PCUIF__data__cnf__dt& PCUIF__MsgUnion::data__cnf__dt() const
{
if (union_selection != ALT_data__cnf__dt) TTCN_error("Using non-selected field data_cnf_dt in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_data__cnf__dt;
}

PCUIF__data& PCUIF__MsgUnion::data__ind()
{
if (union_selection != ALT_data__ind) {
clean_up();
field_data__ind = new PCUIF__data;
union_selection = ALT_data__ind;
}
return *field_data__ind;
}

const PCUIF__data& PCUIF__MsgUnion::data__ind() const
{
if (union_selection != ALT_data__ind) TTCN_error("Using non-selected field data_ind in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_data__ind;
}

PCUIF__susp__req& PCUIF__MsgUnion::susp__req()
{
if (union_selection != ALT_susp__req) {
clean_up();
field_susp__req = new PCUIF__susp__req;
union_selection = ALT_susp__req;
}
return *field_susp__req;
}

const PCUIF__susp__req& PCUIF__MsgUnion::susp__req() const
{
if (union_selection != ALT_susp__req) TTCN_error("Using non-selected field susp_req in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_susp__req;
}

PCUIF__rts__req& PCUIF__MsgUnion::rts__req()
{
if (union_selection != ALT_rts__req) {
clean_up();
field_rts__req = new PCUIF__rts__req;
union_selection = ALT_rts__req;
}
return *field_rts__req;
}

const PCUIF__rts__req& PCUIF__MsgUnion::rts__req() const
{
if (union_selection != ALT_rts__req) TTCN_error("Using non-selected field rts_req in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_rts__req;
}

PCUIF__rach__ind& PCUIF__MsgUnion::rach__ind()
{
if (union_selection != ALT_rach__ind) {
clean_up();
field_rach__ind = new PCUIF__rach__ind;
union_selection = ALT_rach__ind;
}
return *field_rach__ind;
}

const PCUIF__rach__ind& PCUIF__MsgUnion::rach__ind() const
{
if (union_selection != ALT_rach__ind) TTCN_error("Using non-selected field rach_ind in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_rach__ind;
}

PCUIF__txt__ind& PCUIF__MsgUnion::txt__ind()
{
if (union_selection != ALT_txt__ind) {
clean_up();
field_txt__ind = new PCUIF__txt__ind;
union_selection = ALT_txt__ind;
}
return *field_txt__ind;
}

const PCUIF__txt__ind& PCUIF__MsgUnion::txt__ind() const
{
if (union_selection != ALT_txt__ind) TTCN_error("Using non-selected field txt_ind in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_txt__ind;
}

PCUIF__info__ind& PCUIF__MsgUnion::info__ind()
{
if (union_selection != ALT_info__ind) {
clean_up();
field_info__ind = new PCUIF__info__ind;
union_selection = ALT_info__ind;
}
return *field_info__ind;
}

const PCUIF__info__ind& PCUIF__MsgUnion::info__ind() const
{
if (union_selection != ALT_info__ind) TTCN_error("Using non-selected field info_ind in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_info__ind;
}

PCUIF__act__req& PCUIF__MsgUnion::act__req()
{
if (union_selection != ALT_act__req) {
clean_up();
field_act__req = new PCUIF__act__req;
union_selection = ALT_act__req;
}
return *field_act__req;
}

const PCUIF__act__req& PCUIF__MsgUnion::act__req() const
{
if (union_selection != ALT_act__req) TTCN_error("Using non-selected field act_req in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_act__req;
}

PCUIF__time__ind& PCUIF__MsgUnion::time__ind()
{
if (union_selection != ALT_time__ind) {
clean_up();
field_time__ind = new PCUIF__time__ind;
union_selection = ALT_time__ind;
}
return *field_time__ind;
}

const PCUIF__time__ind& PCUIF__MsgUnion::time__ind() const
{
if (union_selection != ALT_time__ind) TTCN_error("Using non-selected field time_ind in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_time__ind;
}

PCUIF__pag__req& PCUIF__MsgUnion::pag__req()
{
if (union_selection != ALT_pag__req) {
clean_up();
field_pag__req = new PCUIF__pag__req;
union_selection = ALT_pag__req;
}
return *field_pag__req;
}

const PCUIF__pag__req& PCUIF__MsgUnion::pag__req() const
{
if (union_selection != ALT_pag__req) TTCN_error("Using non-selected field pag_req in a value of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *field_pag__req;
}

boolean PCUIF__MsgUnion::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PCUIF_Types.PCUIF_MsgUnion.");
return union_selection == checked_selection;
}

boolean PCUIF__MsgUnion::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean PCUIF__MsgUnion::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_data__req: return field_data__req->is_value();
case ALT_data__cnf: return field_data__cnf->is_value();
case ALT_data__cnf__dt: return field_data__cnf__dt->is_value();
case ALT_data__ind: return field_data__ind->is_value();
case ALT_susp__req: return field_susp__req->is_value();
case ALT_rts__req: return field_rts__req->is_value();
case ALT_rach__ind: return field_rach__ind->is_value();
case ALT_txt__ind: return field_txt__ind->is_value();
case ALT_info__ind: return field_info__ind->is_value();
case ALT_act__req: return field_act__req->is_value();
case ALT_time__ind: return field_time__ind->is_value();
case ALT_pag__req: return field_pag__req->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void PCUIF__MsgUnion::clean_up()
{
switch (union_selection) {
case ALT_data__req:
  delete field_data__req;
  break;
case ALT_data__cnf:
  delete field_data__cnf;
  break;
case ALT_data__cnf__dt:
  delete field_data__cnf__dt;
  break;
case ALT_data__ind:
  delete field_data__ind;
  break;
case ALT_susp__req:
  delete field_susp__req;
  break;
case ALT_rts__req:
  delete field_rts__req;
  break;
case ALT_rach__ind:
  delete field_rach__ind;
  break;
case ALT_txt__ind:
  delete field_txt__ind;
  break;
case ALT_info__ind:
  delete field_info__ind;
  break;
case ALT_act__req:
  delete field_act__req;
  break;
case ALT_time__ind:
  delete field_time__ind;
  break;
case ALT_pag__req:
  delete field_pag__req;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void PCUIF__MsgUnion::log() const
{
switch (union_selection) {
case ALT_data__req:
TTCN_Logger::log_event_str("{ data_req := ");
field_data__req->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data__cnf:
TTCN_Logger::log_event_str("{ data_cnf := ");
field_data__cnf->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data__cnf__dt:
TTCN_Logger::log_event_str("{ data_cnf_dt := ");
field_data__cnf__dt->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data__ind:
TTCN_Logger::log_event_str("{ data_ind := ");
field_data__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_susp__req:
TTCN_Logger::log_event_str("{ susp_req := ");
field_susp__req->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rts__req:
TTCN_Logger::log_event_str("{ rts_req := ");
field_rts__req->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rach__ind:
TTCN_Logger::log_event_str("{ rach_ind := ");
field_rach__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_txt__ind:
TTCN_Logger::log_event_str("{ txt_ind := ");
field_txt__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_info__ind:
TTCN_Logger::log_event_str("{ info_ind := ");
field_info__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_act__req:
TTCN_Logger::log_event_str("{ act_req := ");
field_act__req->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_time__ind:
TTCN_Logger::log_event_str("{ time_ind := ");
field_time__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pag__req:
TTCN_Logger::log_event_str("{ pag_req := ");
field_pag__req->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void PCUIF__MsgUnion::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  char* last_name = mp_last->get_id()->get_name();
  if (!strcmp(last_name, "data_req")) {
    data__req().set_param(*mp_last);
    if (!data__req().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "data_cnf")) {
    data__cnf().set_param(*mp_last);
    if (!data__cnf().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "data_cnf_dt")) {
    data__cnf__dt().set_param(*mp_last);
    if (!data__cnf__dt().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "data_ind")) {
    data__ind().set_param(*mp_last);
    if (!data__ind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "susp_req")) {
    susp__req().set_param(*mp_last);
    if (!susp__req().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "rts_req")) {
    rts__req().set_param(*mp_last);
    if (!rts__req().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "rach_ind")) {
    rach__ind().set_param(*mp_last);
    if (!rach__ind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "txt_ind")) {
    txt__ind().set_param(*mp_last);
    if (!txt__ind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "info_ind")) {
    info__ind().set_param(*mp_last);
    if (!info__ind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "act_req")) {
    act__req().set_param(*mp_last);
    if (!act__req().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "time_ind")) {
    time__ind().set_param(*mp_last);
    if (!time__ind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pag_req")) {
    pag__req().set_param(*mp_last);
    if (!pag__req().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @PCUIF_Types.PCUIF_MsgUnion.", last_name);
}

void PCUIF__MsgUnion::set_implicit_omit()
{
switch (union_selection) {
case ALT_data__req:
field_data__req->set_implicit_omit(); break;
case ALT_data__cnf:
field_data__cnf->set_implicit_omit(); break;
case ALT_data__cnf__dt:
field_data__cnf__dt->set_implicit_omit(); break;
case ALT_data__ind:
field_data__ind->set_implicit_omit(); break;
case ALT_susp__req:
field_susp__req->set_implicit_omit(); break;
case ALT_rts__req:
field_rts__req->set_implicit_omit(); break;
case ALT_rach__ind:
field_rach__ind->set_implicit_omit(); break;
case ALT_txt__ind:
field_txt__ind->set_implicit_omit(); break;
case ALT_info__ind:
field_info__ind->set_implicit_omit(); break;
case ALT_act__req:
field_act__req->set_implicit_omit(); break;
case ALT_time__ind:
field_time__ind->set_implicit_omit(); break;
case ALT_pag__req:
field_pag__req->set_implicit_omit(); break;
default: break;
}
}

void PCUIF__MsgUnion::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_data__req:
field_data__req->encode_text(text_buf);
break;
case ALT_data__cnf:
field_data__cnf->encode_text(text_buf);
break;
case ALT_data__cnf__dt:
field_data__cnf__dt->encode_text(text_buf);
break;
case ALT_data__ind:
field_data__ind->encode_text(text_buf);
break;
case ALT_susp__req:
field_susp__req->encode_text(text_buf);
break;
case ALT_rts__req:
field_rts__req->encode_text(text_buf);
break;
case ALT_rach__ind:
field_rach__ind->encode_text(text_buf);
break;
case ALT_txt__ind:
field_txt__ind->encode_text(text_buf);
break;
case ALT_info__ind:
field_info__ind->encode_text(text_buf);
break;
case ALT_act__req:
field_act__req->encode_text(text_buf);
break;
case ALT_time__ind:
field_time__ind->encode_text(text_buf);
break;
case ALT_pag__req:
field_pag__req->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
}

void PCUIF__MsgUnion::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_data__req:
data__req().decode_text(text_buf);
break;
case ALT_data__cnf:
data__cnf().decode_text(text_buf);
break;
case ALT_data__cnf__dt:
data__cnf__dt().decode_text(text_buf);
break;
case ALT_data__ind:
data__ind().decode_text(text_buf);
break;
case ALT_susp__req:
susp__req().decode_text(text_buf);
break;
case ALT_rts__req:
rts__req().decode_text(text_buf);
break;
case ALT_rach__ind:
rach__ind().decode_text(text_buf);
break;
case ALT_txt__ind:
txt__ind().decode_text(text_buf);
break;
case ALT_info__ind:
info__ind().decode_text(text_buf);
break;
case ALT_act__req:
act__req().decode_text(text_buf);
break;
case ALT_time__ind:
time__ind().decode_text(text_buf);
break;
case ALT_pag__req:
pag__req().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @PCUIF_Types.PCUIF_MsgUnion.");
}
}

void PCUIF__MsgUnion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__MsgUnion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__MsgUnion::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean, const RAW_Force_Omit* force_omit)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0: {
      RAW_Force_Omit field_force_omit(0, force_omit, PCUIF__MsgUnion_data__req_descr_.raw->forceomit);
      decoded_length = data__req().RAW_decode(PCUIF__MsgUnion_data__req_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 1: {
      RAW_Force_Omit field_force_omit(1, force_omit, PCUIF__MsgUnion_data__cnf_descr_.raw->forceomit);
      decoded_length = data__cnf().RAW_decode(PCUIF__MsgUnion_data__cnf_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 2: {
      RAW_Force_Omit field_force_omit(2, force_omit, PCUIF__MsgUnion_data__cnf__dt_descr_.raw->forceomit);
      decoded_length = data__cnf__dt().RAW_decode(PCUIF__MsgUnion_data__cnf__dt_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 3: {
      RAW_Force_Omit field_force_omit(3, force_omit, PCUIF__MsgUnion_data__ind_descr_.raw->forceomit);
      decoded_length = data__ind().RAW_decode(PCUIF__MsgUnion_data__ind_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 4: {
      RAW_Force_Omit field_force_omit(4, force_omit, PCUIF__MsgUnion_susp__req_descr_.raw->forceomit);
      decoded_length = susp__req().RAW_decode(PCUIF__MsgUnion_susp__req_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 5: {
      RAW_Force_Omit field_force_omit(5, force_omit, PCUIF__MsgUnion_rts__req_descr_.raw->forceomit);
      decoded_length = rts__req().RAW_decode(PCUIF__MsgUnion_rts__req_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 6: {
      RAW_Force_Omit field_force_omit(6, force_omit, PCUIF__MsgUnion_rach__ind_descr_.raw->forceomit);
      decoded_length = rach__ind().RAW_decode(PCUIF__MsgUnion_rach__ind_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 7: {
      RAW_Force_Omit field_force_omit(7, force_omit, PCUIF__MsgUnion_txt__ind_descr_.raw->forceomit);
      decoded_length = txt__ind().RAW_decode(PCUIF__MsgUnion_txt__ind_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 8: {
      RAW_Force_Omit field_force_omit(8, force_omit, PCUIF__MsgUnion_info__ind_descr_.raw->forceomit);
      decoded_length = info__ind().RAW_decode(PCUIF__MsgUnion_info__ind_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 9: {
      RAW_Force_Omit field_force_omit(9, force_omit, PCUIF__MsgUnion_act__req_descr_.raw->forceomit);
      decoded_length = act__req().RAW_decode(PCUIF__MsgUnion_act__req_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 10: {
      RAW_Force_Omit field_force_omit(10, force_omit, PCUIF__MsgUnion_time__ind_descr_.raw->forceomit);
      decoded_length = time__ind().RAW_decode(PCUIF__MsgUnion_time__ind_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    case 11: {
      RAW_Force_Omit field_force_omit(11, force_omit, PCUIF__MsgUnion_pag__req_descr_.raw->forceomit);
      decoded_length = pag__req().RAW_decode(PCUIF__MsgUnion_pag__req_descr_, p_buf, limit, top_bit_ord, no_err, -1, TRUE, &field_force_omit);
      break; }
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__MsgUnion_data__req_descr_.raw->forceomit);
      decoded_length = data__req().RAW_decode(PCUIF__MsgUnion_data__req_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_0_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__MsgUnion_data__cnf_descr_.raw->forceomit);
      decoded_length = data__cnf().RAW_decode(PCUIF__MsgUnion_data__cnf_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_1_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__MsgUnion_data__cnf__dt_descr_.raw->forceomit);
      decoded_length = data__cnf__dt().RAW_decode(PCUIF__MsgUnion_data__cnf__dt_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_2_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__MsgUnion_data__ind_descr_.raw->forceomit);
      decoded_length = data__ind().RAW_decode(PCUIF__MsgUnion_data__ind_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_3_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_4_force_omit(4, force_omit, PCUIF__MsgUnion_susp__req_descr_.raw->forceomit);
      decoded_length = susp__req().RAW_decode(PCUIF__MsgUnion_susp__req_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_4_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_5_force_omit(5, force_omit, PCUIF__MsgUnion_rts__req_descr_.raw->forceomit);
      decoded_length = rts__req().RAW_decode(PCUIF__MsgUnion_rts__req_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_5_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_6_force_omit(6, force_omit, PCUIF__MsgUnion_rach__ind_descr_.raw->forceomit);
      decoded_length = rach__ind().RAW_decode(PCUIF__MsgUnion_rach__ind_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_6_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_7_force_omit(7, force_omit, PCUIF__MsgUnion_txt__ind_descr_.raw->forceomit);
      decoded_length = txt__ind().RAW_decode(PCUIF__MsgUnion_txt__ind_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_7_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_8_force_omit(8, force_omit, PCUIF__MsgUnion_info__ind_descr_.raw->forceomit);
      decoded_length = info__ind().RAW_decode(PCUIF__MsgUnion_info__ind_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_8_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_9_force_omit(9, force_omit, PCUIF__MsgUnion_act__req_descr_.raw->forceomit);
      decoded_length = act__req().RAW_decode(PCUIF__MsgUnion_act__req_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_9_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_10_force_omit(10, force_omit, PCUIF__MsgUnion_time__ind_descr_.raw->forceomit);
      decoded_length = time__ind().RAW_decode(PCUIF__MsgUnion_time__ind_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_10_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      RAW_Force_Omit field_11_force_omit(11, force_omit, PCUIF__MsgUnion_pag__req_descr_.raw->forceomit);
      decoded_length = pag__req().RAW_decode(PCUIF__MsgUnion_pag__req_descr_, p_buf, limit, top_bit_ord, TRUE, -1, TRUE, &field_11_force_omit);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int PCUIF__MsgUnion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 12;  myleaf.body.node.nodes = init_nodes_of_enc_tree(12);
  memset(myleaf.body.node.nodes, 0, 12 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_data__req:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, PCUIF__MsgUnion_data__req_descr_.raw);
    encoded_length = field_data__req->RAW_encode(PCUIF__MsgUnion_data__req_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &PCUIF__MsgUnion_data__req_descr_;
    break;
  case ALT_data__cnf:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, PCUIF__MsgUnion_data__cnf_descr_.raw);
    encoded_length = field_data__cnf->RAW_encode(PCUIF__MsgUnion_data__cnf_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &PCUIF__MsgUnion_data__cnf_descr_;
    break;
  case ALT_data__cnf__dt:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, PCUIF__MsgUnion_data__cnf__dt_descr_.raw);
    encoded_length = field_data__cnf__dt->RAW_encode(PCUIF__MsgUnion_data__cnf__dt_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &PCUIF__MsgUnion_data__cnf__dt_descr_;
    break;
  case ALT_data__ind:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, PCUIF__MsgUnion_data__ind_descr_.raw);
    encoded_length = field_data__ind->RAW_encode(PCUIF__MsgUnion_data__ind_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &PCUIF__MsgUnion_data__ind_descr_;
    break;
  case ALT_susp__req:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, PCUIF__MsgUnion_susp__req_descr_.raw);
    encoded_length = field_susp__req->RAW_encode(PCUIF__MsgUnion_susp__req_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &PCUIF__MsgUnion_susp__req_descr_;
    break;
  case ALT_rts__req:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, PCUIF__MsgUnion_rts__req_descr_.raw);
    encoded_length = field_rts__req->RAW_encode(PCUIF__MsgUnion_rts__req_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &PCUIF__MsgUnion_rts__req_descr_;
    break;
  case ALT_rach__ind:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, PCUIF__MsgUnion_rach__ind_descr_.raw);
    encoded_length = field_rach__ind->RAW_encode(PCUIF__MsgUnion_rach__ind_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &PCUIF__MsgUnion_rach__ind_descr_;
    break;
  case ALT_txt__ind:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, PCUIF__MsgUnion_txt__ind_descr_.raw);
    encoded_length = field_txt__ind->RAW_encode(PCUIF__MsgUnion_txt__ind_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &PCUIF__MsgUnion_txt__ind_descr_;
    break;
  case ALT_info__ind:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, PCUIF__MsgUnion_info__ind_descr_.raw);
    encoded_length = field_info__ind->RAW_encode(PCUIF__MsgUnion_info__ind_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &PCUIF__MsgUnion_info__ind_descr_;
    break;
  case ALT_act__req:
    myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 9, PCUIF__MsgUnion_act__req_descr_.raw);
    encoded_length = field_act__req->RAW_encode(PCUIF__MsgUnion_act__req_descr_, *myleaf.body.node.nodes[9]);
    myleaf.body.node.nodes[9]->coding_descr = &PCUIF__MsgUnion_act__req_descr_;
    break;
  case ALT_time__ind:
    myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 10, PCUIF__MsgUnion_time__ind_descr_.raw);
    encoded_length = field_time__ind->RAW_encode(PCUIF__MsgUnion_time__ind_descr_, *myleaf.body.node.nodes[10]);
    myleaf.body.node.nodes[10]->coding_descr = &PCUIF__MsgUnion_time__ind_descr_;
    break;
  case ALT_pag__req:
    myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 11, PCUIF__MsgUnion_pag__req_descr_.raw);
    encoded_length = field_pag__req->RAW_encode(PCUIF__MsgUnion_pag__req_descr_, *myleaf.body.node.nodes[11]);
    myleaf.body.node.nodes[11]->coding_descr = &PCUIF__MsgUnion_pag__req_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

void PCUIF__MsgUnion_template::copy_value(const PCUIF__MsgUnion& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
single_value.field_data__req = new PCUIF__data_template(other_value.data__req());
break;
case PCUIF__MsgUnion::ALT_data__cnf:
single_value.field_data__cnf = new PCUIF__data_template(other_value.data__cnf());
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
single_value.field_data__cnf__dt = new PCUIF__data__cnf__dt_template(other_value.data__cnf__dt());
break;
case PCUIF__MsgUnion::ALT_data__ind:
single_value.field_data__ind = new PCUIF__data_template(other_value.data__ind());
break;
case PCUIF__MsgUnion::ALT_susp__req:
single_value.field_susp__req = new PCUIF__susp__req_template(other_value.susp__req());
break;
case PCUIF__MsgUnion::ALT_rts__req:
single_value.field_rts__req = new PCUIF__rts__req_template(other_value.rts__req());
break;
case PCUIF__MsgUnion::ALT_rach__ind:
single_value.field_rach__ind = new PCUIF__rach__ind_template(other_value.rach__ind());
break;
case PCUIF__MsgUnion::ALT_txt__ind:
single_value.field_txt__ind = new PCUIF__txt__ind_template(other_value.txt__ind());
break;
case PCUIF__MsgUnion::ALT_info__ind:
single_value.field_info__ind = new PCUIF__info__ind_template(other_value.info__ind());
break;
case PCUIF__MsgUnion::ALT_act__req:
single_value.field_act__req = new PCUIF__act__req_template(other_value.act__req());
break;
case PCUIF__MsgUnion::ALT_time__ind:
single_value.field_time__ind = new PCUIF__time__ind_template(other_value.time__ind());
break;
case PCUIF__MsgUnion::ALT_pag__req:
single_value.field_pag__req = new PCUIF__pag__req_template(other_value.pag__req());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @PCUIF_Types.PCUIF_MsgUnion.");
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__MsgUnion_template::copy_template(const PCUIF__MsgUnion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
single_value.field_data__req = new PCUIF__data_template(*other_value.single_value.field_data__req);
break;
case PCUIF__MsgUnion::ALT_data__cnf:
single_value.field_data__cnf = new PCUIF__data_template(*other_value.single_value.field_data__cnf);
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
single_value.field_data__cnf__dt = new PCUIF__data__cnf__dt_template(*other_value.single_value.field_data__cnf__dt);
break;
case PCUIF__MsgUnion::ALT_data__ind:
single_value.field_data__ind = new PCUIF__data_template(*other_value.single_value.field_data__ind);
break;
case PCUIF__MsgUnion::ALT_susp__req:
single_value.field_susp__req = new PCUIF__susp__req_template(*other_value.single_value.field_susp__req);
break;
case PCUIF__MsgUnion::ALT_rts__req:
single_value.field_rts__req = new PCUIF__rts__req_template(*other_value.single_value.field_rts__req);
break;
case PCUIF__MsgUnion::ALT_rach__ind:
single_value.field_rach__ind = new PCUIF__rach__ind_template(*other_value.single_value.field_rach__ind);
break;
case PCUIF__MsgUnion::ALT_txt__ind:
single_value.field_txt__ind = new PCUIF__txt__ind_template(*other_value.single_value.field_txt__ind);
break;
case PCUIF__MsgUnion::ALT_info__ind:
single_value.field_info__ind = new PCUIF__info__ind_template(*other_value.single_value.field_info__ind);
break;
case PCUIF__MsgUnion::ALT_act__req:
single_value.field_act__req = new PCUIF__act__req_template(*other_value.single_value.field_act__req);
break;
case PCUIF__MsgUnion::ALT_time__ind:
single_value.field_time__ind = new PCUIF__time__ind_template(*other_value.single_value.field_time__ind);
break;
case PCUIF__MsgUnion::ALT_pag__req:
single_value.field_pag__req = new PCUIF__pag__req_template(*other_value.single_value.field_pag__req);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @PCUIF_Types.PCUIF_MsgUnion.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__MsgUnion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
set_selection(other_value);
}

PCUIF__MsgUnion_template::PCUIF__MsgUnion_template()
{
}

PCUIF__MsgUnion_template::PCUIF__MsgUnion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__MsgUnion_template::PCUIF__MsgUnion_template(const PCUIF__MsgUnion& other_value)
{
copy_value(other_value);
}

PCUIF__MsgUnion_template::PCUIF__MsgUnion_template(const OPTIONAL<PCUIF__MsgUnion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__MsgUnion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @PCUIF_Types.PCUIF_MsgUnion from an unbound optional field.");
}
}

PCUIF__MsgUnion_template::PCUIF__MsgUnion_template(const PCUIF__MsgUnion_template& other_value)
: Base_Template(){
copy_template(other_value);
}

PCUIF__MsgUnion_template::~PCUIF__MsgUnion_template()
{
clean_up();
}

void PCUIF__MsgUnion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
delete single_value.field_data__req;
break;
case PCUIF__MsgUnion::ALT_data__cnf:
delete single_value.field_data__cnf;
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
delete single_value.field_data__cnf__dt;
break;
case PCUIF__MsgUnion::ALT_data__ind:
delete single_value.field_data__ind;
break;
case PCUIF__MsgUnion::ALT_susp__req:
delete single_value.field_susp__req;
break;
case PCUIF__MsgUnion::ALT_rts__req:
delete single_value.field_rts__req;
break;
case PCUIF__MsgUnion::ALT_rach__ind:
delete single_value.field_rach__ind;
break;
case PCUIF__MsgUnion::ALT_txt__ind:
delete single_value.field_txt__ind;
break;
case PCUIF__MsgUnion::ALT_info__ind:
delete single_value.field_info__ind;
break;
case PCUIF__MsgUnion::ALT_act__req:
delete single_value.field_act__req;
break;
case PCUIF__MsgUnion::ALT_time__ind:
delete single_value.field_time__ind;
break;
case PCUIF__MsgUnion::ALT_pag__req:
delete single_value.field_pag__req;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__MsgUnion_template& PCUIF__MsgUnion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__MsgUnion_template& PCUIF__MsgUnion_template::operator=(const PCUIF__MsgUnion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__MsgUnion_template& PCUIF__MsgUnion_template::operator=(const OPTIONAL<PCUIF__MsgUnion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__MsgUnion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
return *this;
}

PCUIF__MsgUnion_template& PCUIF__MsgUnion_template::operator=(const PCUIF__MsgUnion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__MsgUnion_template::match(const PCUIF__MsgUnion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
PCUIF__MsgUnion::union_selection_type value_selection = other_value.get_selection();
if (value_selection == PCUIF__MsgUnion::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case PCUIF__MsgUnion::ALT_data__req:
return single_value.field_data__req->match(other_value.data__req(), legacy);
case PCUIF__MsgUnion::ALT_data__cnf:
return single_value.field_data__cnf->match(other_value.data__cnf(), legacy);
case PCUIF__MsgUnion::ALT_data__cnf__dt:
return single_value.field_data__cnf__dt->match(other_value.data__cnf__dt(), legacy);
case PCUIF__MsgUnion::ALT_data__ind:
return single_value.field_data__ind->match(other_value.data__ind(), legacy);
case PCUIF__MsgUnion::ALT_susp__req:
return single_value.field_susp__req->match(other_value.susp__req(), legacy);
case PCUIF__MsgUnion::ALT_rts__req:
return single_value.field_rts__req->match(other_value.rts__req(), legacy);
case PCUIF__MsgUnion::ALT_rach__ind:
return single_value.field_rach__ind->match(other_value.rach__ind(), legacy);
case PCUIF__MsgUnion::ALT_txt__ind:
return single_value.field_txt__ind->match(other_value.txt__ind(), legacy);
case PCUIF__MsgUnion::ALT_info__ind:
return single_value.field_info__ind->match(other_value.info__ind(), legacy);
case PCUIF__MsgUnion::ALT_act__req:
return single_value.field_act__req->match(other_value.act__req(), legacy);
case PCUIF__MsgUnion::ALT_time__ind:
return single_value.field_time__ind->match(other_value.time__ind(), legacy);
case PCUIF__MsgUnion::ALT_pag__req:
return single_value.field_pag__req->match(other_value.pag__req(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
return FALSE;
}

boolean PCUIF__MsgUnion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
return single_value.field_data__req->is_value();
case PCUIF__MsgUnion::ALT_data__cnf:
return single_value.field_data__cnf->is_value();
case PCUIF__MsgUnion::ALT_data__cnf__dt:
return single_value.field_data__cnf__dt->is_value();
case PCUIF__MsgUnion::ALT_data__ind:
return single_value.field_data__ind->is_value();
case PCUIF__MsgUnion::ALT_susp__req:
return single_value.field_susp__req->is_value();
case PCUIF__MsgUnion::ALT_rts__req:
return single_value.field_rts__req->is_value();
case PCUIF__MsgUnion::ALT_rach__ind:
return single_value.field_rach__ind->is_value();
case PCUIF__MsgUnion::ALT_txt__ind:
return single_value.field_txt__ind->is_value();
case PCUIF__MsgUnion::ALT_info__ind:
return single_value.field_info__ind->is_value();
case PCUIF__MsgUnion::ALT_act__req:
return single_value.field_act__req->is_value();
case PCUIF__MsgUnion::ALT_time__ind:
return single_value.field_time__ind->is_value();
case PCUIF__MsgUnion::ALT_pag__req:
return single_value.field_pag__req->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
}

PCUIF__MsgUnion PCUIF__MsgUnion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
PCUIF__MsgUnion ret_val;
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
ret_val.data__req() = single_value.field_data__req->valueof();
break;
case PCUIF__MsgUnion::ALT_data__cnf:
ret_val.data__cnf() = single_value.field_data__cnf->valueof();
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
ret_val.data__cnf__dt() = single_value.field_data__cnf__dt->valueof();
break;
case PCUIF__MsgUnion::ALT_data__ind:
ret_val.data__ind() = single_value.field_data__ind->valueof();
break;
case PCUIF__MsgUnion::ALT_susp__req:
ret_val.susp__req() = single_value.field_susp__req->valueof();
break;
case PCUIF__MsgUnion::ALT_rts__req:
ret_val.rts__req() = single_value.field_rts__req->valueof();
break;
case PCUIF__MsgUnion::ALT_rach__ind:
ret_val.rach__ind() = single_value.field_rach__ind->valueof();
break;
case PCUIF__MsgUnion::ALT_txt__ind:
ret_val.txt__ind() = single_value.field_txt__ind->valueof();
break;
case PCUIF__MsgUnion::ALT_info__ind:
ret_val.info__ind() = single_value.field_info__ind->valueof();
break;
case PCUIF__MsgUnion::ALT_act__req:
ret_val.act__req() = single_value.field_act__req->valueof();
break;
case PCUIF__MsgUnion::ALT_time__ind:
ret_val.time__ind() = single_value.field_time__ind->valueof();
break;
case PCUIF__MsgUnion::ALT_pag__req:
ret_val.pag__req() = single_value.field_pag__req->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
return ret_val;
}

PCUIF__MsgUnion_template& PCUIF__MsgUnion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return value_list.list_value[list_index];
}
void PCUIF__MsgUnion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__MsgUnion_template[list_length];
}

PCUIF__data_template& PCUIF__MsgUnion_template::data__req()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_data__req) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data__req = new PCUIF__data_template(ANY_VALUE);
else single_value.field_data__req = new PCUIF__data_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_data__req;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data__req;
}

const PCUIF__data_template& PCUIF__MsgUnion_template::data__req() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data_req in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_data__req) TTCN_error("Accessing non-selected field data_req in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_data__req;
}

PCUIF__data_template& PCUIF__MsgUnion_template::data__cnf()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_data__cnf) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data__cnf = new PCUIF__data_template(ANY_VALUE);
else single_value.field_data__cnf = new PCUIF__data_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_data__cnf;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data__cnf;
}

const PCUIF__data_template& PCUIF__MsgUnion_template::data__cnf() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data_cnf in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_data__cnf) TTCN_error("Accessing non-selected field data_cnf in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_data__cnf;
}

PCUIF__data__cnf__dt_template& PCUIF__MsgUnion_template::data__cnf__dt()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_data__cnf__dt) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data__cnf__dt = new PCUIF__data__cnf__dt_template(ANY_VALUE);
else single_value.field_data__cnf__dt = new PCUIF__data__cnf__dt_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_data__cnf__dt;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data__cnf__dt;
}

const PCUIF__data__cnf__dt_template& PCUIF__MsgUnion_template::data__cnf__dt() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data_cnf_dt in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_data__cnf__dt) TTCN_error("Accessing non-selected field data_cnf_dt in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_data__cnf__dt;
}

PCUIF__data_template& PCUIF__MsgUnion_template::data__ind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_data__ind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data__ind = new PCUIF__data_template(ANY_VALUE);
else single_value.field_data__ind = new PCUIF__data_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_data__ind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data__ind;
}

const PCUIF__data_template& PCUIF__MsgUnion_template::data__ind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data_ind in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_data__ind) TTCN_error("Accessing non-selected field data_ind in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_data__ind;
}

PCUIF__susp__req_template& PCUIF__MsgUnion_template::susp__req()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_susp__req) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_susp__req = new PCUIF__susp__req_template(ANY_VALUE);
else single_value.field_susp__req = new PCUIF__susp__req_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_susp__req;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_susp__req;
}

const PCUIF__susp__req_template& PCUIF__MsgUnion_template::susp__req() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field susp_req in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_susp__req) TTCN_error("Accessing non-selected field susp_req in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_susp__req;
}

PCUIF__rts__req_template& PCUIF__MsgUnion_template::rts__req()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_rts__req) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rts__req = new PCUIF__rts__req_template(ANY_VALUE);
else single_value.field_rts__req = new PCUIF__rts__req_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_rts__req;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rts__req;
}

const PCUIF__rts__req_template& PCUIF__MsgUnion_template::rts__req() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rts_req in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_rts__req) TTCN_error("Accessing non-selected field rts_req in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_rts__req;
}

PCUIF__rach__ind_template& PCUIF__MsgUnion_template::rach__ind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_rach__ind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rach__ind = new PCUIF__rach__ind_template(ANY_VALUE);
else single_value.field_rach__ind = new PCUIF__rach__ind_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_rach__ind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rach__ind;
}

const PCUIF__rach__ind_template& PCUIF__MsgUnion_template::rach__ind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rach_ind in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_rach__ind) TTCN_error("Accessing non-selected field rach_ind in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_rach__ind;
}

PCUIF__txt__ind_template& PCUIF__MsgUnion_template::txt__ind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_txt__ind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_txt__ind = new PCUIF__txt__ind_template(ANY_VALUE);
else single_value.field_txt__ind = new PCUIF__txt__ind_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_txt__ind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_txt__ind;
}

const PCUIF__txt__ind_template& PCUIF__MsgUnion_template::txt__ind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field txt_ind in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_txt__ind) TTCN_error("Accessing non-selected field txt_ind in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_txt__ind;
}

PCUIF__info__ind_template& PCUIF__MsgUnion_template::info__ind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_info__ind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_info__ind = new PCUIF__info__ind_template(ANY_VALUE);
else single_value.field_info__ind = new PCUIF__info__ind_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_info__ind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_info__ind;
}

const PCUIF__info__ind_template& PCUIF__MsgUnion_template::info__ind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field info_ind in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_info__ind) TTCN_error("Accessing non-selected field info_ind in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_info__ind;
}

PCUIF__act__req_template& PCUIF__MsgUnion_template::act__req()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_act__req) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_act__req = new PCUIF__act__req_template(ANY_VALUE);
else single_value.field_act__req = new PCUIF__act__req_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_act__req;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_act__req;
}

const PCUIF__act__req_template& PCUIF__MsgUnion_template::act__req() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field act_req in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_act__req) TTCN_error("Accessing non-selected field act_req in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_act__req;
}

PCUIF__time__ind_template& PCUIF__MsgUnion_template::time__ind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_time__ind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_time__ind = new PCUIF__time__ind_template(ANY_VALUE);
else single_value.field_time__ind = new PCUIF__time__ind_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_time__ind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_time__ind;
}

const PCUIF__time__ind_template& PCUIF__MsgUnion_template::time__ind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field time_ind in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_time__ind) TTCN_error("Accessing non-selected field time_ind in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_time__ind;
}

PCUIF__pag__req_template& PCUIF__MsgUnion_template::pag__req()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PCUIF__MsgUnion::ALT_pag__req) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pag__req = new PCUIF__pag__req_template(ANY_VALUE);
else single_value.field_pag__req = new PCUIF__pag__req_template;
single_value.union_selection = PCUIF__MsgUnion::ALT_pag__req;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pag__req;
}

const PCUIF__pag__req_template& PCUIF__MsgUnion_template::pag__req() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pag_req in a non-specific template of union type @PCUIF_Types.PCUIF_MsgUnion.");
if (single_value.union_selection != PCUIF__MsgUnion::ALT_pag__req) TTCN_error("Accessing non-selected field pag_req in a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return *single_value.field_pag__req;
}

boolean PCUIF__MsgUnion_template::ischosen(PCUIF__MsgUnion::union_selection_type checked_selection) const
{
if (checked_selection == PCUIF__MsgUnion::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PCUIF_Types.PCUIF_MsgUnion.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == PCUIF__MsgUnion::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @PCUIF_Types.PCUIF_MsgUnion containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
for (unsigned int list_count = 1; ret_val == TRUE && list_count < value_list.n_values; list_count++) {
ret_val = value_list.list_value[list_count].ischosen(checked_selection);
}
return ret_val;
}
default:
return FALSE;
}
return FALSE;
}

void PCUIF__MsgUnion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
TTCN_Logger::log_event_str("{ data_req := ");
single_value.field_data__req->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_data__cnf:
TTCN_Logger::log_event_str("{ data_cnf := ");
single_value.field_data__cnf->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
TTCN_Logger::log_event_str("{ data_cnf_dt := ");
single_value.field_data__cnf__dt->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_data__ind:
TTCN_Logger::log_event_str("{ data_ind := ");
single_value.field_data__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_susp__req:
TTCN_Logger::log_event_str("{ susp_req := ");
single_value.field_susp__req->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_rts__req:
TTCN_Logger::log_event_str("{ rts_req := ");
single_value.field_rts__req->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_rach__ind:
TTCN_Logger::log_event_str("{ rach_ind := ");
single_value.field_rach__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_txt__ind:
TTCN_Logger::log_event_str("{ txt_ind := ");
single_value.field_txt__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_info__ind:
TTCN_Logger::log_event_str("{ info_ind := ");
single_value.field_info__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_act__req:
TTCN_Logger::log_event_str("{ act_req := ");
single_value.field_act__req->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_time__ind:
TTCN_Logger::log_event_str("{ time_ind := ");
single_value.field_time__ind->log();
TTCN_Logger::log_event_str(" }");
break;
case PCUIF__MsgUnion::ALT_pag__req:
TTCN_Logger::log_event_str("{ pag_req := ");
single_value.field_pag__req->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__MsgUnion_template::log_match(const PCUIF__MsgUnion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data_req");
single_value.field_data__req->log_match(match_value.data__req(), legacy);
} else {
TTCN_Logger::log_event_str("{ data_req := ");
single_value.field_data__req->log_match(match_value.data__req(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_data__cnf:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data_cnf");
single_value.field_data__cnf->log_match(match_value.data__cnf(), legacy);
} else {
TTCN_Logger::log_event_str("{ data_cnf := ");
single_value.field_data__cnf->log_match(match_value.data__cnf(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data_cnf_dt");
single_value.field_data__cnf__dt->log_match(match_value.data__cnf__dt(), legacy);
} else {
TTCN_Logger::log_event_str("{ data_cnf_dt := ");
single_value.field_data__cnf__dt->log_match(match_value.data__cnf__dt(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_data__ind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data_ind");
single_value.field_data__ind->log_match(match_value.data__ind(), legacy);
} else {
TTCN_Logger::log_event_str("{ data_ind := ");
single_value.field_data__ind->log_match(match_value.data__ind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_susp__req:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".susp_req");
single_value.field_susp__req->log_match(match_value.susp__req(), legacy);
} else {
TTCN_Logger::log_event_str("{ susp_req := ");
single_value.field_susp__req->log_match(match_value.susp__req(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_rts__req:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rts_req");
single_value.field_rts__req->log_match(match_value.rts__req(), legacy);
} else {
TTCN_Logger::log_event_str("{ rts_req := ");
single_value.field_rts__req->log_match(match_value.rts__req(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_rach__ind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rach_ind");
single_value.field_rach__ind->log_match(match_value.rach__ind(), legacy);
} else {
TTCN_Logger::log_event_str("{ rach_ind := ");
single_value.field_rach__ind->log_match(match_value.rach__ind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_txt__ind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".txt_ind");
single_value.field_txt__ind->log_match(match_value.txt__ind(), legacy);
} else {
TTCN_Logger::log_event_str("{ txt_ind := ");
single_value.field_txt__ind->log_match(match_value.txt__ind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_info__ind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".info_ind");
single_value.field_info__ind->log_match(match_value.info__ind(), legacy);
} else {
TTCN_Logger::log_event_str("{ info_ind := ");
single_value.field_info__ind->log_match(match_value.info__ind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_act__req:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".act_req");
single_value.field_act__req->log_match(match_value.act__req(), legacy);
} else {
TTCN_Logger::log_event_str("{ act_req := ");
single_value.field_act__req->log_match(match_value.act__req(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_time__ind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".time_ind");
single_value.field_time__ind->log_match(match_value.time__ind(), legacy);
} else {
TTCN_Logger::log_event_str("{ time_ind := ");
single_value.field_time__ind->log_match(match_value.time__ind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PCUIF__MsgUnion::ALT_pag__req:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pag_req");
single_value.field_pag__req->log_match(match_value.pag__req(), legacy);
} else {
TTCN_Logger::log_event_str("{ pag_req := ");
single_value.field_pag__req->log_match(match_value.pag__req(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__MsgUnion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
single_value.field_data__req->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__cnf:
single_value.field_data__cnf->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
single_value.field_data__cnf__dt->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__ind:
single_value.field_data__ind->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_susp__req:
single_value.field_susp__req->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_rts__req:
single_value.field_rts__req->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_rach__ind:
single_value.field_rach__ind->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_txt__ind:
single_value.field_txt__ind->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_info__ind:
single_value.field_info__ind->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_act__req:
single_value.field_act__req->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_time__ind:
single_value.field_time__ind->encode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_pag__req:
single_value.field_pag__req->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @PCUIF_Types.PCUIF_MsgUnion.");
}
}

void PCUIF__MsgUnion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = PCUIF__MsgUnion::UNBOUND_VALUE;
PCUIF__MsgUnion::union_selection_type new_selection = (PCUIF__MsgUnion::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case PCUIF__MsgUnion::ALT_data__req:
single_value.field_data__req = new PCUIF__data_template;
single_value.field_data__req->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__cnf:
single_value.field_data__cnf = new PCUIF__data_template;
single_value.field_data__cnf->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
single_value.field_data__cnf__dt = new PCUIF__data__cnf__dt_template;
single_value.field_data__cnf__dt->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_data__ind:
single_value.field_data__ind = new PCUIF__data_template;
single_value.field_data__ind->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_susp__req:
single_value.field_susp__req = new PCUIF__susp__req_template;
single_value.field_susp__req->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_rts__req:
single_value.field_rts__req = new PCUIF__rts__req_template;
single_value.field_rts__req->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_rach__ind:
single_value.field_rach__ind = new PCUIF__rach__ind_template;
single_value.field_rach__ind->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_txt__ind:
single_value.field_txt__ind = new PCUIF__txt__ind_template;
single_value.field_txt__ind->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_info__ind:
single_value.field_info__ind = new PCUIF__info__ind_template;
single_value.field_info__ind->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_act__req:
single_value.field_act__req = new PCUIF__act__req_template;
single_value.field_act__req->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_time__ind:
single_value.field_time__ind = new PCUIF__time__ind_template;
single_value.field_time__ind->decode_text(text_buf);
break;
case PCUIF__MsgUnion::ALT_pag__req:
single_value.field_pag__req = new PCUIF__pag__req_template;
single_value.field_pag__req->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @PCUIF_Types.PCUIF_MsgUnion.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__MsgUnion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @PCUIF_Types.PCUIF_MsgUnion.");
}
}

boolean PCUIF__MsgUnion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__MsgUnion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PCUIF__MsgUnion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@PCUIF_Types.PCUIF_MsgUnion'");
    }
    if (strcmp("data_req", param_field) == 0) {
      data__req().set_param(param);
      return;
    } else if (strcmp("data_cnf", param_field) == 0) {
      data__cnf().set_param(param);
      return;
    } else if (strcmp("data_cnf_dt", param_field) == 0) {
      data__cnf__dt().set_param(param);
      return;
    } else if (strcmp("data_ind", param_field) == 0) {
      data__ind().set_param(param);
      return;
    } else if (strcmp("susp_req", param_field) == 0) {
      susp__req().set_param(param);
      return;
    } else if (strcmp("rts_req", param_field) == 0) {
      rts__req().set_param(param);
      return;
    } else if (strcmp("rach_ind", param_field) == 0) {
      rach__ind().set_param(param);
      return;
    } else if (strcmp("txt_ind", param_field) == 0) {
      txt__ind().set_param(param);
      return;
    } else if (strcmp("info_ind", param_field) == 0) {
      info__ind().set_param(param);
      return;
    } else if (strcmp("act_req", param_field) == 0) {
      act__req().set_param(param);
      return;
    } else if (strcmp("time_ind", param_field) == 0) {
      time__ind().set_param(param);
      return;
    } else if (strcmp("pag_req", param_field) == 0) {
      pag__req().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@PCUIF_Types.PCUIF_MsgUnion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__MsgUnion_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@PCUIF_Types.PCUIF_MsgUnion");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    char* last_name = mp_last->get_id()->get_name();
    if (!strcmp(last_name, "data_req")) {
      data__req().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "data_cnf")) {
      data__cnf().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "data_cnf_dt")) {
      data__cnf__dt().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "data_ind")) {
      data__ind().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "susp_req")) {
      susp__req().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "rts_req")) {
      rts__req().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "rach_ind")) {
      rach__ind().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "txt_ind")) {
      txt__ind().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "info_ind")) {
      info__ind().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "act_req")) {
      act__req().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "time_ind")) {
      time__ind().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pag_req")) {
      pag__req().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @PCUIF_Types.PCUIF_MsgUnion.", last_name);
  } break;
  default:
    param.type_error("union template", "@PCUIF_Types.PCUIF_MsgUnion");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__MsgUnion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case PCUIF__MsgUnion::ALT_data__req:
single_value.field_data__req->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_data__cnf:
single_value.field_data__cnf->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_data__cnf__dt:
single_value.field_data__cnf__dt->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_data__ind:
single_value.field_data__ind->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_susp__req:
single_value.field_susp__req->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_rts__req:
single_value.field_rts__req->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_rach__ind:
single_value.field_rach__ind->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_txt__ind:
single_value.field_txt__ind->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_info__ind:
single_value.field_info__ind->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_act__req:
single_value.field_act__req->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_time__ind:
single_value.field_time__ind->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
case PCUIF__MsgUnion::ALT_pag__req:
single_value.field_pag__req->check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @PCUIF_Types.PCUIF_MsgUnion.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_MsgUnion");
}

PCUIF__Message::PCUIF__Message()
{
}

PCUIF__Message::PCUIF__Message(const PCUIF__MsgType& par_msg__type,
    const INTEGER& par_bts__nr,
    const OCTETSTRING& par_spare,
    const PCUIF__MsgUnion& par_u)
  :   field_msg__type(par_msg__type),
  field_bts__nr(par_bts__nr),
  field_spare(par_spare),
  field_u(par_u)
{
}

PCUIF__Message::PCUIF__Message(const PCUIF__Message& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PCUIF_Types.PCUIF_Message.");
if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
else field_msg__type.clean_up();
if (other_value.bts__nr().is_bound()) field_bts__nr = other_value.bts__nr();
else field_bts__nr.clean_up();
if (other_value.spare().is_bound()) field_spare = other_value.spare();
else field_spare.clean_up();
if (other_value.u().is_bound()) field_u = other_value.u();
else field_u.clean_up();
}

void PCUIF__Message::clean_up()
{
field_msg__type.clean_up();
field_bts__nr.clean_up();
field_spare.clean_up();
field_u.clean_up();
}

const TTCN_Typedescriptor_t* PCUIF__Message::get_descriptor() const { return &PCUIF__Message_descr_; }
PCUIF__Message& PCUIF__Message::operator=(const PCUIF__Message& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PCUIF_Types.PCUIF_Message.");
  if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
  else field_msg__type.clean_up();
  if (other_value.bts__nr().is_bound()) field_bts__nr = other_value.bts__nr();
  else field_bts__nr.clean_up();
  if (other_value.spare().is_bound()) field_spare = other_value.spare();
  else field_spare.clean_up();
  if (other_value.u().is_bound()) field_u = other_value.u();
  else field_u.clean_up();
}
return *this;
}

boolean PCUIF__Message::operator==(const PCUIF__Message& other_value) const
{
return field_msg__type==other_value.field_msg__type
  && field_bts__nr==other_value.field_bts__nr
  && field_spare==other_value.field_spare
  && field_u==other_value.field_u;
}

boolean PCUIF__Message::is_bound() const
{
if(field_msg__type.is_bound()) return TRUE;
if(field_bts__nr.is_bound()) return TRUE;
if(field_spare.is_bound()) return TRUE;
if(field_u.is_bound()) return TRUE;
return FALSE;
}
boolean PCUIF__Message::is_value() const
{
if(!field_msg__type.is_value()) return FALSE;
if(!field_bts__nr.is_value()) return FALSE;
if(!field_spare.is_value()) return FALSE;
if(!field_u.is_value()) return FALSE;
return TRUE;
}
void PCUIF__Message::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msg_type := ");
field_msg__type.log();
TTCN_Logger::log_event_str(", bts_nr := ");
field_bts__nr.log();
TTCN_Logger::log_event_str(", spare := ");
field_spare.log();
TTCN_Logger::log_event_str(", u := ");
field_u.log();
TTCN_Logger::log_event_str(" }");
}

void PCUIF__Message::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @PCUIF_Types.PCUIF_Message has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) bts__nr().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) u().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "u")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          u().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_Message: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PCUIF_Types.PCUIF_Message");
  }
}

void PCUIF__Message::set_implicit_omit()
{
if (msg__type().is_bound()) msg__type().set_implicit_omit();
if (bts__nr().is_bound()) bts__nr().set_implicit_omit();
if (spare().is_bound()) spare().set_implicit_omit();
if (u().is_bound()) u().set_implicit_omit();
}

void PCUIF__Message::encode_text(Text_Buf& text_buf) const
{
field_msg__type.encode_text(text_buf);
field_bts__nr.encode_text(text_buf);
field_spare.encode_text(text_buf);
field_u.encode_text(text_buf);
}

void PCUIF__Message::decode_text(Text_Buf& text_buf)
{
field_msg__type.decode_text(text_buf);
field_bts__nr.decode_text(text_buf);
field_spare.decode_text(text_buf);
field_u.decode_text(text_buf);
}

void PCUIF__Message::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PCUIF__Message::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PCUIF__Message::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean, const RAW_Force_Omit* force_omit)
{ (void)no_err;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  int selected_field = -1;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  RAW_Force_Omit field_0_force_omit(0, force_omit, PCUIF__Message_msg__type_descr_.raw->forceomit);
  decoded_field_length = field_msg__type.RAW_decode(PCUIF__Message_msg__type_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_0_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_1_force_omit(1, force_omit, PCUIF__Message_bts__nr_descr_.raw->forceomit);
  decoded_field_length = field_bts__nr.RAW_decode(PCUIF__Message_bts__nr_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_1_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  RAW_Force_Omit field_2_force_omit(2, force_omit, PCUIF__Message_spare_descr_.raw->forceomit);
  decoded_field_length = field_spare.RAW_decode(PCUIF__Message_spare_descr_, p_buf, limit, local_top_order, no_err, -1, TRUE, &field_2_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__DATA__REQ) selected_field = 0;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__DATA__CNF) selected_field = 1;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__DATA__CNF__DT) selected_field = 2;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__DATA__IND) selected_field = 3;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__SUSP__REQ) selected_field = 4;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__RTS__REQ) selected_field = 5;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__RACH__IND) selected_field = 6;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__TXT__IND) selected_field = 7;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__INFO__IND) selected_field = 8;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__ACT__REQ) selected_field = 9;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__TIME__IND) selected_field = 10;
  else if (field_msg__type == PCUIF__MsgType::PCU__IF__MSG__PAG__REQ) selected_field = 11;
  else selected_field = -1;
  RAW_Force_Omit field_3_force_omit(3, force_omit, PCUIF__Message_u_descr_.raw->forceomit);
  decoded_field_length = field_u.RAW_decode(PCUIF__Message_u_descr_, p_buf, limit, local_top_order, no_err, selected_field, TRUE, &field_3_force_omit);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PCUIF__Message::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 0, PCUIF__Message_msg__type_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 1, PCUIF__Message_bts__nr_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 2, PCUIF__Message_spare_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &(myleaf.curr_pos), 3, PCUIF__Message_u_descr_.raw);
  encoded_length += field_msg__type.RAW_encode(PCUIF__Message_msg__type_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_bts__nr.RAW_encode(PCUIF__Message_bts__nr_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_spare.RAW_encode(PCUIF__Message_spare_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_u.RAW_encode(PCUIF__Message_u_descr_, *myleaf.body.node.nodes[3]);
  switch (field_u.get_selection()) {
  case PCUIF__MsgUnion::ALT_data__req:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__DATA__REQ) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__DATA__REQ);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_data__cnf:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__DATA__CNF) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__DATA__CNF);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_data__cnf__dt:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__DATA__CNF__DT) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__DATA__CNF__DT);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_data__ind:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__DATA__IND) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__DATA__IND);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_susp__req:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__SUSP__REQ) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__SUSP__REQ);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_rts__req:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__RTS__REQ) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__RTS__REQ);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_rach__ind:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__RACH__IND) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__RACH__IND);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_txt__ind:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__TXT__IND) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__TXT__IND);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_info__ind:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__INFO__IND) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__INFO__IND);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_act__req:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__ACT__REQ) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__ACT__REQ);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_time__ind:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__TIME__IND) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__TIME__IND);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case PCUIF__MsgUnion::ALT_pag__req:
  if (field_msg__type != PCUIF__MsgType::PCU__IF__MSG__PAG__REQ) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  PCUIF__MsgType new_val(PCUIF__MsgType::PCU__IF__MSG__PAG__REQ);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(PCUIF__Message_msg__type_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  return myleaf.length = encoded_length;
}

struct PCUIF__Message_template::single_value_struct {
PCUIF__MsgType_template field_msg__type;
INTEGER_template field_bts__nr;
OCTETSTRING_template field_spare;
PCUIF__MsgUnion_template field_u;
};

void PCUIF__Message_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msg__type = ANY_VALUE;
single_value->field_bts__nr = ANY_VALUE;
single_value->field_spare = ANY_VALUE;
single_value->field_u = ANY_VALUE;
}
}
}

void PCUIF__Message_template::copy_value(const PCUIF__Message& other_value)
{
single_value = new single_value_struct;
if (other_value.msg__type().is_bound()) {
  single_value->field_msg__type = other_value.msg__type();
} else {
  single_value->field_msg__type.clean_up();
}
if (other_value.bts__nr().is_bound()) {
  single_value->field_bts__nr = other_value.bts__nr();
} else {
  single_value->field_bts__nr.clean_up();
}
if (other_value.spare().is_bound()) {
  single_value->field_spare = other_value.spare();
} else {
  single_value->field_spare.clean_up();
}
if (other_value.u().is_bound()) {
  single_value->field_u = other_value.u();
} else {
  single_value->field_u.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PCUIF__Message_template::copy_template(const PCUIF__Message_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msg__type().get_selection()) {
single_value->field_msg__type = other_value.msg__type();
} else {
single_value->field_msg__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.bts__nr().get_selection()) {
single_value->field_bts__nr = other_value.bts__nr();
} else {
single_value->field_bts__nr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spare().get_selection()) {
single_value->field_spare = other_value.spare();
} else {
single_value->field_spare.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.u().get_selection()) {
single_value->field_u = other_value.u();
} else {
single_value->field_u.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PCUIF__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Message.");
break;
}
set_selection(other_value);
}

PCUIF__Message_template::PCUIF__Message_template()
{
}

PCUIF__Message_template::PCUIF__Message_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PCUIF__Message_template::PCUIF__Message_template(const PCUIF__Message& other_value)
{
copy_value(other_value);
}

PCUIF__Message_template::PCUIF__Message_template(const OPTIONAL<PCUIF__Message>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PCUIF_Types.PCUIF_Message from an unbound optional field.");
}
}

PCUIF__Message_template::PCUIF__Message_template(const PCUIF__Message_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PCUIF__Message_template::~PCUIF__Message_template()
{
clean_up();
}

PCUIF__Message_template& PCUIF__Message_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PCUIF__Message_template& PCUIF__Message_template::operator=(const PCUIF__Message& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PCUIF__Message_template& PCUIF__Message_template::operator=(const OPTIONAL<PCUIF__Message>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PCUIF__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PCUIF_Types.PCUIF_Message.");
}
return *this;
}

PCUIF__Message_template& PCUIF__Message_template::operator=(const PCUIF__Message_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PCUIF__Message_template::match(const PCUIF__Message& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msg__type().is_bound()) return FALSE;
if(!single_value->field_msg__type.match(other_value.msg__type(), legacy))return FALSE;
if(!other_value.bts__nr().is_bound()) return FALSE;
if(!single_value->field_bts__nr.match(other_value.bts__nr(), legacy))return FALSE;
if(!other_value.spare().is_bound()) return FALSE;
if(!single_value->field_spare.match(other_value.spare(), legacy))return FALSE;
if(!other_value.u().is_bound()) return FALSE;
if(!single_value->field_u.match(other_value.u(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Message.");
}
return FALSE;
}

boolean PCUIF__Message_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msg__type.is_bound()) return TRUE;
if (single_value->field_bts__nr.is_bound()) return TRUE;
if (single_value->field_spare.is_bound()) return TRUE;
if (single_value->field_u.is_bound()) return TRUE;
return FALSE;
}

boolean PCUIF__Message_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msg__type.is_value()) return FALSE;
if (!single_value->field_bts__nr.is_value()) return FALSE;
if (!single_value->field_spare.is_value()) return FALSE;
if (!single_value->field_u.is_value()) return FALSE;
return TRUE;
}

void PCUIF__Message_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PCUIF__Message PCUIF__Message_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PCUIF_Types.PCUIF_Message.");
PCUIF__Message ret_val;
if (single_value->field_msg__type.is_bound()) {
ret_val.msg__type() = single_value->field_msg__type.valueof();
}
if (single_value->field_bts__nr.is_bound()) {
ret_val.bts__nr() = single_value->field_bts__nr.valueof();
}
if (single_value->field_spare.is_bound()) {
ret_val.spare() = single_value->field_spare.valueof();
}
if (single_value->field_u.is_bound()) {
ret_val.u() = single_value->field_u.valueof();
}
return ret_val;
}

void PCUIF__Message_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @PCUIF_Types.PCUIF_Message.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PCUIF__Message_template[list_length];
}

PCUIF__Message_template& PCUIF__Message_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @PCUIF_Types.PCUIF_Message.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PCUIF_Types.PCUIF_Message.");
return value_list.list_value[list_index];
}

PCUIF__MsgType_template& PCUIF__Message_template::msg__type()
{
set_specific();
return single_value->field_msg__type;
}

const PCUIF__MsgType_template& PCUIF__Message_template::msg__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg_type of a non-specific template of type @PCUIF_Types.PCUIF_Message.");
return single_value->field_msg__type;
}

INTEGER_template& PCUIF__Message_template::bts__nr()
{
set_specific();
return single_value->field_bts__nr;
}

const INTEGER_template& PCUIF__Message_template::bts__nr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bts_nr of a non-specific template of type @PCUIF_Types.PCUIF_Message.");
return single_value->field_bts__nr;
}

OCTETSTRING_template& PCUIF__Message_template::spare()
{
set_specific();
return single_value->field_spare;
}

const OCTETSTRING_template& PCUIF__Message_template::spare() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spare of a non-specific template of type @PCUIF_Types.PCUIF_Message.");
return single_value->field_spare;
}

PCUIF__MsgUnion_template& PCUIF__Message_template::u()
{
set_specific();
return single_value->field_u;
}

const PCUIF__MsgUnion_template& PCUIF__Message_template::u() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field u of a non-specific template of type @PCUIF_Types.PCUIF_Message.");
return single_value->field_u;
}

int PCUIF__Message_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PCUIF_Types.PCUIF_Message containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Message.");
  }
  return 0;
}

void PCUIF__Message_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msg_type := ");
single_value->field_msg__type.log();
TTCN_Logger::log_event_str(", bts_nr := ");
single_value->field_bts__nr.log();
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log();
TTCN_Logger::log_event_str(", u := ");
single_value->field_u.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PCUIF__Message_template::log_match(const PCUIF__Message& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msg__type.match(match_value.msg__type(), legacy)){
TTCN_Logger::log_logmatch_info(".msg_type");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_bts__nr.match(match_value.bts__nr(), legacy)){
TTCN_Logger::log_logmatch_info(".bts_nr");
single_value->field_bts__nr.log_match(match_value.bts__nr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spare.match(match_value.spare(), legacy)){
TTCN_Logger::log_logmatch_info(".spare");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_u.match(match_value.u(), legacy)){
TTCN_Logger::log_logmatch_info(".u");
single_value->field_u.log_match(match_value.u(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msg_type := ");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::log_event_str(", bts_nr := ");
single_value->field_bts__nr.log_match(match_value.bts__nr(), legacy);
TTCN_Logger::log_event_str(", spare := ");
single_value->field_spare.log_match(match_value.spare(), legacy);
TTCN_Logger::log_event_str(", u := ");
single_value->field_u.log_match(match_value.u(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PCUIF__Message_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msg__type.encode_text(text_buf);
single_value->field_bts__nr.encode_text(text_buf);
single_value->field_spare.encode_text(text_buf);
single_value->field_u.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PCUIF_Types.PCUIF_Message.");
}
}

void PCUIF__Message_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msg__type.decode_text(text_buf);
single_value->field_bts__nr.decode_text(text_buf);
single_value->field_spare.decode_text(text_buf);
single_value->field_u.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PCUIF__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PCUIF_Types.PCUIF_Message.");
}
}

void PCUIF__Message_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PCUIF__Message_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @PCUIF_Types.PCUIF_Message has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) bts__nr().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) spare().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) u().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bts_nr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bts__nr().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spare")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spare().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "u")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          u().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PCUIF_Types.PCUIF_Message: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@PCUIF_Types.PCUIF_Message");
  }
  is_ifpresent = param.get_ifpresent();
}

void PCUIF__Message_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msg__type.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Message");
single_value->field_bts__nr.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Message");
single_value->field_spare.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Message");
single_value->field_u.check_restriction(t_res, t_name ? t_name : "@PCUIF_Types.PCUIF_Message");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PCUIF_Types.PCUIF_Message");
}

boolean PCUIF__Message_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PCUIF__Message_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

void PCUIF__MsgType_encoder(const PCUIF__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgType_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgType_decoder(OCTETSTRING& input_stream, PCUIF__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgType_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_bts__active_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_bts__active_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_bts__active_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_bts__active_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_sysmo__direct__dsp_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_sysmo__direct__dsp_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_sysmo__direct__dsp_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_sysmo__direct__dsp_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_spare_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_spare_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_spare_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_spare_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_cs1_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_cs1_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_cs1_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_cs1_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_cs2_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_cs2_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_cs2_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_cs2_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_cs3_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_cs3_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_cs3_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_cs3_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_cs4_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_cs4_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_cs4_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_cs4_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs1_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs1_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs1_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs1_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs2_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs2_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs2_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs2_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs3_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs3_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs3_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs3_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs4_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs4_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs4_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs4_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs5_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs5_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs5_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs5_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs6_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs6_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs6_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs6_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs7_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs7_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs7_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs7_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs8_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs8_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs8_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs8_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_mcs9_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_mcs9_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_mcs9_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `boolean' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_mcs9_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_spare2_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_spare2_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_spare2_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_spare2_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Flags_encoder(const PCUIF__Flags& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Flags' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Flags_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Flags_decoder(OCTETSTRING& input_stream, PCUIF__Flags& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Flags' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Flags_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__TextType_encoder(const PCUIF__TextType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_TextType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__TextType_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__TextType_decoder(OCTETSTRING& input_stream, PCUIF__TextType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_TextType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__TextType_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Text_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Text_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Text_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Text_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__txt__ind_txt__type_encoder(const PCUIF__TextType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_TextType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__txt__ind_txt__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__txt__ind_txt__type_decoder(OCTETSTRING& input_stream, PCUIF__TextType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_TextType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__txt__ind_txt__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__txt__ind_text_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__txt__ind_text_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__txt__ind_text_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__txt__ind_text_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__txt__ind_encoder(const PCUIF__txt__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_txt_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__txt__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__txt__ind_decoder(OCTETSTRING& input_stream, PCUIF__txt__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_txt_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__txt__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void OCT162_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(OCT162_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER OCT162_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(OCT162_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_len_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_len_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_len_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_len_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_data_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_data_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_fn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_fn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_fn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_fn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_arfcn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_arfcn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_arfcn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_arfcn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_trx__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_trx__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_ts__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_ts__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_block__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_block__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_block__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_block__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_rssi_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_rssi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_rssi_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_rssi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_ber10k_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_ber10k_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_ber10k_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_ber10k_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_ta__offs__qbits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_ta__offs__qbits_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_ta__offs__qbits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_ta__offs__qbits_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_lqual__cb_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_lqual__cb_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_lqual__cb_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_lqual__cb_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data_encoder(const PCUIF__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data_decoder(OCTETSTRING& input_stream, PCUIF__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_tlli_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_tlli_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_tlli_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_tlli_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_fn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_fn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_fn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_fn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_arfcn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_arfcn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_arfcn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_arfcn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_trx__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_trx__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_ts__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_ts__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_block__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_block__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_block__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_block__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_rssi_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_rssi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_rssi_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_rssi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_ber10k_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_ber10k_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_ber10k_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_ber10k_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_ta__offs__qbits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_ta__offs__qbits_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_ta__offs__qbits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_ta__offs__qbits_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_lqual__cb_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_lqual__cb_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_lqual__cb_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_lqual__cb_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__data__cnf__dt_encoder(const PCUIF__data__cnf__dt& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data_cnf_dt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__data__cnf__dt_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__data__cnf__dt_decoder(OCTETSTRING& input_stream, PCUIF__data__cnf__dt& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data_cnf_dt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__data__cnf__dt_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_spare_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_spare_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_spare_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_spare_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_fn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_fn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_fn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_fn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_arfcn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_arfcn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_arfcn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_arfcn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_trx__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_trx__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_ts__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_ts__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_block__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_block__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_block__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_block__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rts__req_encoder(const PCUIF__rts__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rts_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rts__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rts__req_decoder(OCTETSTRING& input_stream, PCUIF__rts__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rts_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rts__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__BurstType_encoder(const PCUIF__BurstType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_BurstType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__BurstType_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__BurstType_decoder(OCTETSTRING& input_stream, PCUIF__BurstType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_BurstType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__BurstType_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_ra_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_ra_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_ra_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_ra_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_qta_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_qta_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_qta_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_qta_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_fn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_fn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_fn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_fn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_arfcn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_arfcn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_arfcn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_arfcn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_is__11bit_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_is__11bit_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_is__11bit_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_is__11bit_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_burst__type_encoder(const PCUIF__BurstType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_BurstType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_burst__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_burst__type_decoder(OCTETSTRING& input_stream, PCUIF__BurstType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_BurstType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_burst__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__rach__ind_encoder(const PCUIF__rach__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rach_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__rach__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__rach__ind_decoder(OCTETSTRING& input_stream, PCUIF__rach__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rach_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__rach__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_arfcn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_arfcn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_arfcn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_arfcn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_pdch__mask_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_pdch__mask_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_pdch__mask_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `bitstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_pdch__mask_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_spare_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_spare_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_spare_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_spare_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_tsc_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_tsc_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_tsc_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_tsc_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_hLayer1_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_hLayer1_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_hLayer1_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_hLayer1_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrx_encoder(const PCUIF__InfoTrx& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrx' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrx_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrx_decoder(OCTETSTRING& input_stream, PCUIF__InfoTrx& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrx' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrx_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

boolean operator==(null_type, const PCUIF__InfoTrxs& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @PCUIF_Types.PCUIF_InfoTrxs.");
return other_value.val_ptr->n_elements == 0;
}

void PCUIF__InfoTrxs_0_encoder(const PCUIF__InfoTrx& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrx' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrxs_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrxs_0_decoder(OCTETSTRING& input_stream, PCUIF__InfoTrx& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrx' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrxs_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__InfoTrxs_encoder(const PCUIF__InfoTrxs& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrxs' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__InfoTrxs_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__InfoTrxs_decoder(OCTETSTRING& input_stream, PCUIF__InfoTrxs& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrxs' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__InfoTrxs_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_version_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_version_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_version_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_version_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_flags_encoder(const PCUIF__Flags& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Flags' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_flags_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_flags_decoder(OCTETSTRING& input_stream, PCUIF__Flags& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Flags' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_flags_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_trx_encoder(const PCUIF__InfoTrxs& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrxs' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_trx_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_trx_decoder(OCTETSTRING& input_stream, PCUIF__InfoTrxs& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_InfoTrxs' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_trx_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_bsic_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_bsic_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_bsic_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_bsic_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_mcc_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_mcc_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_mcc_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_mcc_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_mnc_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_mnc_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_mnc_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_mnc_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_mnc__3__digits_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_mnc__3__digits_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_mnc__3__digits_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_mnc__3__digits_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_lac_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_lac_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_lac_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_lac_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_rac_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_rac_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_rac_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_rac_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_nsei_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_nsei_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_nsei_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_nsei_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_nse__timer_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_nse__timer_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_nse__timer_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_nse__timer_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_nse__timer_encoder(const PCUIF__info__ind_nse__timer& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.nse_timer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_nse__timer_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_nse__timer_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_nse__timer& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.nse_timer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_nse__timer_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_cell__timer_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_cell__timer_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_cell__timer_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_cell__timer_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_cell__timer_encoder(const PCUIF__info__ind_cell__timer& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.cell_timer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_cell__timer_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_cell__timer_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_cell__timer& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.cell_timer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_cell__timer_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_cell__id_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_cell__id_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_cell__id_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_cell__id_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_repeat__time_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_repeat__time_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_repeat__time_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_repeat__time_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_repeat__count_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_repeat__count_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_repeat__count_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_repeat__count_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_bvci_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_bvci_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_bvci_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_bvci_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3142_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3142_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3142_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3142_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3169_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3169_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3169_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3169_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3191_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3191_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3191_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3191_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3193__10ms_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3193__10ms_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3193__10ms_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3193__10ms_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3195_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3195_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3195_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3195_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3101_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3101_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3101_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3101_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3103_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3103_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3103_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3103_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_t3105_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_t3105_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_t3105_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_t3105_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_cv__countdown_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_cv__countdown_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_cv__countdown_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_cv__countdown_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_dl__tbf__ext_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_dl__tbf__ext_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_dl__tbf__ext_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_dl__tbf__ext_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_ul__tbf__ext_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_ul__tbf__ext_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_ul__tbf__ext_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_ul__tbf__ext_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_initial__cs_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_initial__cs_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_initial__cs_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_initial__cs_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_initial__mcs_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_initial__mcs_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_initial__mcs_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_initial__mcs_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_nsvci_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_nsvci_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_nsvci_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_nsvci_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_nsvci_encoder(const PCUIF__info__ind_nsvci& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.nsvci' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_nsvci_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_nsvci_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_nsvci& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.nsvci' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_nsvci_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_local__pprt_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_local__pprt_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_local__pprt_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_local__pprt_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_local__pprt_encoder(const PCUIF__info__ind_local__pprt& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.local_pprt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_local__pprt_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_local__pprt_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_local__pprt& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.local_pprt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_local__pprt_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_remote__port_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_remote__port_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_remote__port_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_remote__port_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_remote__port_encoder(const PCUIF__info__ind_remote__port& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.remote_port' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_remote__port_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_remote__port_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_remote__port& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.remote_port' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_remote__port_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_remote__ip_0_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_remote__ip_0_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_remote__ip_0_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_remote__ip_0_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_remote__ip_encoder(const PCUIF__info__ind_remote__ip& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.remote_ip' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_remote__ip_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_remote__ip_decoder(OCTETSTRING& input_stream, PCUIF__info__ind_remote__ip& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind.remote_ip' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_remote__ip_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__info__ind_encoder(const PCUIF__info__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__info__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__info__ind_decoder(OCTETSTRING& input_stream, PCUIF__info__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__info__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__act__req_is__activate_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__act__req_is__activate_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__act__req_is__activate_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__act__req_is__activate_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__act__req_trx__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__act__req_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__act__req_trx__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__act__req_trx__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__act__req_ts__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__act__req_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__act__req_ts__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__act__req_ts__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__act__req_spare_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__act__req_spare_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__act__req_spare_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__act__req_spare_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__act__req_encoder(const PCUIF__act__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_act_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__act__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__act__req_decoder(OCTETSTRING& input_stream, PCUIF__act__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_act_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__act__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__time__ind_fn_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__time__ind_fn_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__time__ind_fn_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__time__ind_fn_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__time__ind_encoder(const PCUIF__time__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_time_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__time__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__time__ind_decoder(OCTETSTRING& input_stream, PCUIF__time__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_time_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__time__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__pag__req_sapi_encoder(const PCUIF__Sapi& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__pag__req_sapi_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__pag__req_sapi_decoder(OCTETSTRING& input_stream, PCUIF__Sapi& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Sapi' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__pag__req_sapi_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__pag__req_chan__needed_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__pag__req_chan__needed_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__pag__req_chan__needed_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__pag__req_chan__needed_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__pag__req_identity__lv_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__pag__req_identity__lv_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__pag__req_identity__lv_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__pag__req_identity__lv_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__pag__req_encoder(const PCUIF__pag__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_pag_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__pag__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__pag__req_decoder(OCTETSTRING& input_stream, PCUIF__pag__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_pag_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__pag__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__susp__req_tlli_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__susp__req_tlli_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__susp__req_tlli_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__susp__req_tlli_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__susp__req_ra__id_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__susp__req_ra__id_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__susp__req_ra__id_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__susp__req_ra__id_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__susp__req_cause_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__susp__req_cause_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__susp__req_cause_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__susp__req_cause_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__susp__req_encoder(const PCUIF__susp__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_susp_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__susp__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__susp__req_decoder(OCTETSTRING& input_stream, PCUIF__susp__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_susp_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__susp__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_data__req_encoder(const PCUIF__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_data__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_data__req_decoder(OCTETSTRING& input_stream, PCUIF__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_data__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_data__cnf_encoder(const PCUIF__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_data__cnf_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_data__cnf_decoder(OCTETSTRING& input_stream, PCUIF__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_data__cnf_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_data__cnf__dt_encoder(const PCUIF__data__cnf__dt& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data_cnf_dt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_data__cnf__dt_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_data__cnf__dt_decoder(OCTETSTRING& input_stream, PCUIF__data__cnf__dt& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data_cnf_dt' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_data__cnf__dt_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_data__ind_encoder(const PCUIF__data& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_data__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_data__ind_decoder(OCTETSTRING& input_stream, PCUIF__data& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_data' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_data__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_susp__req_encoder(const PCUIF__susp__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_susp_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_susp__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_susp__req_decoder(OCTETSTRING& input_stream, PCUIF__susp__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_susp_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_susp__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_rts__req_encoder(const PCUIF__rts__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rts_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_rts__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_rts__req_decoder(OCTETSTRING& input_stream, PCUIF__rts__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rts_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_rts__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_rach__ind_encoder(const PCUIF__rach__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rach_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_rach__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_rach__ind_decoder(OCTETSTRING& input_stream, PCUIF__rach__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_rach_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_rach__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_txt__ind_encoder(const PCUIF__txt__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_txt_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_txt__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_txt__ind_decoder(OCTETSTRING& input_stream, PCUIF__txt__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_txt_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_txt__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_info__ind_encoder(const PCUIF__info__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_info__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_info__ind_decoder(OCTETSTRING& input_stream, PCUIF__info__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_info_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_info__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_act__req_encoder(const PCUIF__act__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_act_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_act__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_act__req_decoder(OCTETSTRING& input_stream, PCUIF__act__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_act_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_act__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_time__ind_encoder(const PCUIF__time__ind& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_time_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_time__ind_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_time__ind_decoder(OCTETSTRING& input_stream, PCUIF__time__ind& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_time_ind' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_time__ind_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_pag__req_encoder(const PCUIF__pag__req& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_pag_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_pag__req_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_pag__req_decoder(OCTETSTRING& input_stream, PCUIF__pag__req& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_pag_req' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_pag__req_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__MsgUnion_encoder(const PCUIF__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__MsgUnion_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__MsgUnion_decoder(OCTETSTRING& input_stream, PCUIF__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__MsgUnion_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Message_msg__type_encoder(const PCUIF__MsgType& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Message_msg__type_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Message_msg__type_decoder(OCTETSTRING& input_stream, PCUIF__MsgType& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgType' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Message_msg__type_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Message_bts__nr_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Message_bts__nr_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Message_bts__nr_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Message_bts__nr_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Message_spare_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Message_spare_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Message_spare_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Message_spare_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Message_u_encoder(const PCUIF__MsgUnion& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Message_u_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Message_u_decoder(OCTETSTRING& input_stream, PCUIF__MsgUnion& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_MsgUnion' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Message_u_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void PCUIF__Message_encoder(const PCUIF__Message& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Message' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(PCUIF__Message_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER PCUIF__Message_decoder(OCTETSTRING& input_stream, PCUIF__Message& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_RAW) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@PCUIF_Types.PCUIF_Message' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(PCUIF__Message_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

OCTETSTRING enc__PCUIF__Message(const PCUIF__Message& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("enc_PCUIF_Message(): Encoding @PCUIF_Types.PCUIF_Message: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(PCUIF__Message_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW, 0);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("enc_PCUIF_Message(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

PCUIF__Message dec__PCUIF__Message(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("dec_PCUIF_Message(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
PCUIF__Message ret_val;
ret_val.decode(PCUIF__Message_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("dec_PCUIF_Message(): Decoded @PCUIF_Types.PCUIF_Message: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len() && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("dec_PCUIF_Message(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__RTS__REQ(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const PCUIF__Sapi_template& sapi, const INTEGER_template& fn, const INTEGER_template& arfcn, const INTEGER_template& block__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 243, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_RTS_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__RTS__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__rts__req_template& tmp_0 = ret_val.u().rts__req();
tmp_0.sapi() = sapi;
tmp_0.spare() = os_1;
tmp_0.fn() = fn;
tmp_0.arfcn() = arfcn;
tmp_0.trx__nr() = trx__nr;
tmp_0.ts__nr() = ts__nr;
tmp_0.block__nr() = block__nr;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__RTS__REQ(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const PCUIF__Sapi_template& sapi, const INTEGER_template& fn, const INTEGER_template& block__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 266, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_RTS_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__RTS__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__rts__req_template& tmp_1 = ret_val.u().rts__req();
tmp_1.sapi() = sapi;
tmp_1.spare() = ANY_VALUE;
tmp_1.fn() = fn;
tmp_1.arfcn() = ANY_VALUE;
tmp_1.trx__nr() = trx__nr;
tmp_1.ts__nr() = ts__nr;
tmp_1.block__nr() = block__nr;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__TXT__IND(const INTEGER& bts__nr, const PCUIF__TextType& tt, const CHARSTRING& text)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 289, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_TXT_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__TXT__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__txt__ind_template& tmp_2 = ret_val.u().txt__ind();
tmp_2.txt__type() = tt;
tmp_2.text() = text;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__TXT__IND(const INTEGER_template& bts__nr, const PCUIF__TextType_template& tt, const CHARSTRING_template& text)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 300, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_TXT_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__TXT__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__txt__ind_template& tmp_3 = ret_val.u().txt__ind();
tmp_3.txt__type() = tt;
tmp_3.text() = text;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__ACT__REQ(const INTEGER& bts__nr, const INTEGER& trx__nr, const INTEGER& ts__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 315, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_ACT_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__ACT__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__act__req_template& tmp_4 = ret_val.u().act__req();
tmp_4.is__activate() = 1;
tmp_4.trx__nr() = trx__nr;
tmp_4.ts__nr() = ts__nr;
tmp_4.spare() = os_2;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__ACT__REQ(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 328, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_ACT_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__ACT__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__act__req_template& tmp_5 = ret_val.u().act__req();
tmp_5.is__activate() = 1;
tmp_5.trx__nr() = trx__nr;
tmp_5.ts__nr() = ts__nr;
tmp_5.spare() = os_2;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__DEACT__REQ(const INTEGER& bts__nr, const INTEGER& trx__nr, const INTEGER& ts__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 343, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_DEACT_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__ACT__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__act__req_template& tmp_6 = ret_val.u().act__req();
tmp_6.is__activate() = 0;
tmp_6.trx__nr() = trx__nr;
tmp_6.ts__nr() = ts__nr;
tmp_6.spare() = os_2;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__DEACT__REQ(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 356, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_DEACT_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__ACT__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__act__req_template& tmp_7 = ret_val.u().act__req();
tmp_7.is__activate() = 0;
tmp_7.trx__nr() = trx__nr;
tmp_7.ts__nr() = ts__nr;
tmp_7.spare() = os_2;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__DATA__IND(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const INTEGER_template& block__nr, const PCUIF__Sapi_template& sapi, const OCTETSTRING_template& data, const INTEGER_template& fn, const INTEGER_template& arfcn, const INTEGER_template& rssi, const INTEGER_template& ber10k, const INTEGER_template& ta__offs__qbits, const INTEGER_template& lqual__cb)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 371, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_DATA_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__data_template& tmp_8 = ret_val.u().data__ind();
tmp_8.sapi() = sapi;
tmp_8.len() = data.valueof().lengthof();
tmp_8.data() = data;
tmp_8.fn() = fn;
tmp_8.arfcn() = arfcn;
tmp_8.trx__nr() = trx__nr;
tmp_8.ts__nr() = ts__nr;
tmp_8.block__nr() = block__nr;
tmp_8.rssi() = rssi;
tmp_8.ber10k() = ber10k;
tmp_8.ta__offs__qbits() = ta__offs__qbits;
tmp_8.lqual__cb() = lqual__cb;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__DATA__IND(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const INTEGER_template& block__nr, const PCUIF__Sapi_template& sapi, const OCTETSTRING_template& data)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 403, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_DATA_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__data_template& tmp_9 = ret_val.u().data__ind();
tmp_9.sapi() = sapi;
tmp_9.len() = ANY_VALUE;
tmp_9.data() = data;
tmp_9.fn() = ANY_VALUE;
tmp_9.arfcn() = ANY_VALUE;
tmp_9.trx__nr() = trx__nr;
tmp_9.ts__nr() = ts__nr;
tmp_9.block__nr() = block__nr;
tmp_9.rssi() = ANY_VALUE;
tmp_9.ber10k() = ANY_VALUE;
tmp_9.ta__offs__qbits() = ANY_VALUE;
tmp_9.lqual__cb() = ANY_VALUE;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__DATA__REQ(const INTEGER& bts__nr, const INTEGER& trx__nr, const INTEGER& ts__nr, const INTEGER& block__nr, const INTEGER& fn, const PCUIF__Sapi& sapi, const OCTETSTRING& data)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 430, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_DATA_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__data_template& tmp_10 = ret_val.u().data__req();
tmp_10.sapi() = sapi;
tmp_10.len() = data.lengthof();
tmp_10.data() = data;
tmp_10.fn() = fn;
tmp_10.arfcn() = 0;
tmp_10.trx__nr() = trx__nr;
tmp_10.ts__nr() = ts__nr;
tmp_10.block__nr() = block__nr;
tmp_10.rssi() = 0;
tmp_10.ber10k() = 0;
tmp_10.ta__offs__qbits() = 0;
tmp_10.lqual__cb() = 0;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__DATA__REQ(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const INTEGER_template& block__nr, const INTEGER_template& fn, const PCUIF__Sapi_template& sapi, const OCTETSTRING_template& data)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 455, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_DATA_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__data_template& tmp_11 = ret_val.u().data__req();
tmp_11.sapi() = sapi;
tmp_11.len() = ANY_VALUE;
tmp_11.data() = data;
tmp_11.fn() = fn;
tmp_11.arfcn() = ANY_VALUE;
tmp_11.trx__nr() = trx__nr;
tmp_11.ts__nr() = ts__nr;
tmp_11.block__nr() = block__nr;
tmp_11.rssi() = 0;
tmp_11.ber10k() = 0;
tmp_11.ta__offs__qbits() = 0;
tmp_11.lqual__cb() = 0;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__DATA__CNF(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const INTEGER_template& block__nr, const INTEGER_template& fn, const INTEGER_template& arfcn, const PCUIF__Sapi_template& sapi, const OCTETSTRING_template& data)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 484, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_DATA_CNF");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__CNF;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__data_template& tmp_12 = ret_val.u().data__cnf();
tmp_12.sapi() = sapi;
tmp_12.len() = 0;
tmp_12.data() = data;
tmp_12.fn() = fn;
tmp_12.arfcn() = arfcn;
tmp_12.trx__nr() = trx__nr;
tmp_12.ts__nr() = ts__nr;
tmp_12.block__nr() = block__nr;
tmp_12.rssi() = 0;
tmp_12.ber10k() = 0;
tmp_12.ta__offs__qbits() = 0;
tmp_12.lqual__cb() = 0;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__DATA__CNF(const INTEGER_template& bts__nr, const INTEGER_template& trx__nr, const INTEGER_template& ts__nr, const PCUIF__Sapi_template& sapi, const OCTETSTRING_template& data)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 512, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_DATA_CNF");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__DATA__CNF;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__data_template& tmp_13 = ret_val.u().data__cnf();
tmp_13.sapi() = sapi;
tmp_13.len() = ANY_VALUE;
tmp_13.data() = data;
tmp_13.fn() = ANY_VALUE;
tmp_13.arfcn() = ANY_VALUE;
tmp_13.trx__nr() = trx__nr;
tmp_13.ts__nr() = ts__nr;
tmp_13.block__nr() = ANY_VALUE;
tmp_13.rssi() = ANY_VALUE;
tmp_13.ber10k() = ANY_VALUE;
tmp_13.ta__offs__qbits() = ANY_VALUE;
tmp_13.lqual__cb() = ANY_VALUE;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__RACH__IND(const INTEGER_template& bts__nr, const INTEGER_template& ra, const INTEGER_template& is__11bit, const PCUIF__BurstType_template& burst__type, const INTEGER_template& fn, const INTEGER_template& arfcn, const INTEGER_template& qta)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 538, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_RACH_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__RACH__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__rach__ind_template& tmp_14 = ret_val.u().rach__ind();
tmp_14.sapi() = PCUIF__Sapi::PCU__IF__SAPI__RACH;
tmp_14.ra() = ra;
tmp_14.qta() = qta;
tmp_14.fn() = fn;
tmp_14.arfcn() = arfcn;
tmp_14.is__11bit() = is__11bit;
tmp_14.burst__type() = burst__type;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__RACH__IND(const INTEGER_template& bts__nr, const INTEGER_template& ra, const INTEGER_template& is__11bit, const PCUIF__BurstType_template& burst__type, const INTEGER_template& fn)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 561, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_RACH_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__RACH__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__rach__ind_template& tmp_15 = ret_val.u().rach__ind();
tmp_15.sapi() = PCUIF__Sapi::PCU__IF__SAPI__RACH;
tmp_15.ra() = ra;
tmp_15.qta() = ANY_VALUE;
tmp_15.fn() = fn;
tmp_15.arfcn() = ANY_VALUE;
tmp_15.is__11bit() = is__11bit;
tmp_15.burst__type() = burst__type;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__PAG__REQ(const INTEGER_template& bts__nr, const OCTETSTRING_template& id__lv, const INTEGER_template& chan__needed, const PCUIF__Sapi_template& sapi)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 582, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_PAG_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__PAG__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__pag__req_template& tmp_16 = ret_val.u().pag__req();
tmp_16.sapi() = sapi;
tmp_16.chan__needed() = chan__needed;
tmp_16.identity__lv() = id__lv;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__PAG__REQ(const INTEGER_template& bts__nr, const OCTETSTRING_template& id__lv, const INTEGER_template& chan__needed, const PCUIF__Sapi_template& )
{
TTCN_Location current_location("PCUIF_Types.ttcn", 597, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_PAG_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__PAG__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__pag__req_template& tmp_17 = ret_val.u().pag__req();
tmp_17.sapi() = ANY_VALUE;
tmp_17.chan__needed() = chan__needed;
tmp_17.identity__lv() = id__lv;
}
return ret_val;
}

PCUIF__InfoTrx_template ts__PCUIF__InfoTrx(const INTEGER_template& arfcn, const BITSTRING_template& pdch__mask, const OCTETSTRING& tsc)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 633, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_InfoTrx");
PCUIF__InfoTrx_template ret_val;
ret_val.arfcn() = arfcn;
ret_val.pdch__mask() = pdch__mask;
ret_val.spare() = os_2;
ret_val.tsc() = (((((((tsc + tsc) + tsc) + tsc) + tsc) + tsc) + tsc) + tsc);
ret_val.hLayer1() = 0;
return ret_val;
}

PCUIF__Message_template ts__PCUIF__INFO__IND(const INTEGER_template& bts__nr, const INTEGER_template& nsei, const INTEGER_template& nsvci, const INTEGER_template& bvci, const INTEGER_template& local__port, const INTEGER_template& remote__port, const OCTETSTRING_template& remote__ip, const PCUIF__Flags_template& flags, const INTEGER_template& mcc, const INTEGER_template& mnc, const INTEGER_template& lac, const INTEGER_template& rac, const INTEGER_template& cell__id, const INTEGER_template& bsic, const PCUIF__InfoTrxs_template& trx, const INTEGER_template& version)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 650, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_INFO_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__INFO__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__info__ind_template& tmp_18 = ret_val.u().info__ind();
tmp_18.version() = version;
tmp_18.flags() = flags;
tmp_18.trx() = trx;
tmp_18.bsic() = bsic;
tmp_18.mcc() = mcc;
tmp_18.mnc() = mnc;
tmp_18.mnc__3__digits() = 0;
tmp_18.lac() = lac;
tmp_18.rac() = rac;
tmp_18.nsei() = nsei;
{
PCUIF__info__ind_nse__timer_template& tmp_19 = tmp_18.nse__timer();
tmp_19.set_size(7);
tmp_19[0] = 3;
tmp_19[1] = 3;
tmp_19[2] = 3;
tmp_19[3] = 3;
tmp_19[4] = 30;
tmp_19[5] = 3;
tmp_19[6] = 10;
}
{
PCUIF__info__ind_cell__timer_template& tmp_20 = tmp_18.cell__timer();
tmp_20.set_size(11);
tmp_20[0] = 3;
tmp_20[1] = 3;
tmp_20[2] = 3;
tmp_20[3] = 3;
tmp_20[4] = 3;
tmp_20[5] = 10;
tmp_20[6] = 3;
tmp_20[7] = 10;
tmp_20[8] = 3;
tmp_20[9] = 10;
tmp_20[10] = 3;
}
tmp_18.cell__id() = cell__id;
tmp_18.repeat__time() = 250;
tmp_18.repeat__count() = 3;
tmp_18.bvci() = bvci;
tmp_18.t3142() = 20;
tmp_18.t3169() = 5;
tmp_18.t3191() = 5;
tmp_18.t3193__10ms() = 160;
tmp_18.t3195() = 5;
tmp_18.t3101() = 10;
tmp_18.t3103() = 4;
tmp_18.t3105() = 8;
tmp_18.cv__countdown() = 15;
tmp_18.dl__tbf__ext() = 2500;
tmp_18.ul__tbf__ext() = 2500;
tmp_18.initial__cs() = 2;
tmp_18.initial__mcs() = 6;
{
PCUIF__info__ind_nsvci_template& tmp_21 = tmp_18.nsvci();
tmp_21.set_size(2);
tmp_21[0] = nsvci;
tmp_21[1] = 0;
}
{
PCUIF__info__ind_local__pprt_template& tmp_22 = tmp_18.local__pprt();
tmp_22.set_size(2);
tmp_22[0] = local__port;
tmp_22[1] = 0;
}
{
PCUIF__info__ind_remote__port_template& tmp_23 = tmp_18.remote__port();
tmp_23.set_size(2);
tmp_23[0] = remote__port;
tmp_23[1] = 0;
}
{
PCUIF__info__ind_remote__ip_template& tmp_24 = tmp_18.remote__ip();
tmp_24.set_size(2);
tmp_24[0] = remote__ip;
tmp_24[1] = os_4;
}
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__INFO__IND(const INTEGER_template& bts__nr, const PCUIF__Flags_template& flags, const INTEGER_template& version)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 707, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_INFO_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__INFO__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
{
PCUIF__info__ind_template& tmp_25 = ret_val.u().info__ind();
tmp_25.version() = version;
tmp_25.flags() = flags;
tmp_25.trx() = ANY_VALUE;
tmp_25.bsic() = ANY_VALUE;
tmp_25.mcc() = ANY_VALUE;
tmp_25.mnc() = ANY_VALUE;
tmp_25.mnc__3__digits() = ANY_VALUE;
tmp_25.lac() = ANY_VALUE;
tmp_25.rac() = ANY_VALUE;
tmp_25.nsei() = ANY_VALUE;
tmp_25.nse__timer() = ANY_VALUE;
tmp_25.cell__timer() = ANY_VALUE;
tmp_25.cell__id() = ANY_VALUE;
tmp_25.repeat__time() = ANY_VALUE;
tmp_25.repeat__count() = ANY_VALUE;
tmp_25.bvci() = ANY_VALUE;
tmp_25.t3142() = ANY_VALUE;
tmp_25.t3169() = ANY_VALUE;
tmp_25.t3191() = ANY_VALUE;
tmp_25.t3193__10ms() = ANY_VALUE;
tmp_25.t3195() = ANY_VALUE;
tmp_25.t3101() = ANY_VALUE;
tmp_25.t3103() = ANY_VALUE;
tmp_25.t3105() = ANY_VALUE;
tmp_25.cv__countdown() = ANY_VALUE;
tmp_25.dl__tbf__ext() = ANY_VALUE;
tmp_25.ul__tbf__ext() = ANY_VALUE;
tmp_25.initial__cs() = ANY_VALUE;
tmp_25.initial__mcs() = ANY_VALUE;
tmp_25.nsvci() = ANY_VALUE;
tmp_25.local__pprt() = ANY_VALUE;
tmp_25.remote__port() = ANY_VALUE;
tmp_25.remote__ip() = ANY_VALUE;
}
return ret_val;
}

PCUIF__Message_template ts__PCUIF__TIME__IND(const INTEGER_template& bts__nr, const INTEGER_template& fn)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 752, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_TIME_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__TIME__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
ret_val.u().time__ind().fn() = fn;
return ret_val;
}

PCUIF__Message_template tr__PCUIF__TIME__IND(const INTEGER_template& bts__nr, const INTEGER_template& fn)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 763, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_TIME_IND");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__TIME__IND;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = ANY_VALUE;
ret_val.u().time__ind().fn() = fn;
return ret_val;
}

PCUIF__Message_template ts__PCUIF__SUSP__REQ(const INTEGER_template& bts__nr, const OCTETSTRING_template& tlli, const OCTETSTRING_template& ra__id, const INTEGER_template& cause)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 775, TTCN_Location::LOCATION_TEMPLATE, "ts_PCUIF_SUSP_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__SUSP__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__susp__req_template& tmp_26 = ret_val.u().susp__req();
tmp_26.tlli() = tlli;
tmp_26.ra__id() = ra__id;
tmp_26.cause() = cause;
}
return ret_val;
}

PCUIF__Message_template tr__PCUIF__SUSP__REQ(const INTEGER_template& bts__nr, const OCTETSTRING_template& tlli, const OCTETSTRING_template& ra__id, const INTEGER_template& cause)
{
TTCN_Location current_location("PCUIF_Types.ttcn", 790, TTCN_Location::LOCATION_TEMPLATE, "tr_PCUIF_SUSP_REQ");
PCUIF__Message_template ret_val;
ret_val.msg__type() = PCUIF__MsgType::PCU__IF__MSG__SUSP__REQ;
ret_val.bts__nr() = bts__nr;
ret_val.spare() = os_0;
{
PCUIF__susp__req_template& tmp_27 = ret_val.u().susp__req();
tmp_27.tlli() = tlli;
tmp_27.ra__id() = ra__id;
tmp_27.cause() = cause;
}
return ret_val;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("PCUIF_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "PCUIF_Types");
Osmocom__Types::module_object.pre_init_module();
current_location.update_lineno(8);
/* PCUIF_Types.ttcn, line 8 */
const_PCU__SOCK__DEFAULT = cs_0;
current_location.update_lineno(9);
/* PCUIF_Types.ttcn, line 9 */
const_PCU__IF__VERSION = 9;
module_object.add_function("enc_PCUIF_Message", (genericfunc_t)&enc__PCUIF__Message, NULL);
module_object.add_function("dec_PCUIF_Message", (genericfunc_t)&dec__PCUIF__Message, NULL);
current_location.update_lineno(613);
/* PCUIF_Types.ttcn, line 613 */
const_c__PCUIF__Flags__default.bts__active() = TRUE;
const_c__PCUIF__Flags__default.sysmo__direct__dsp() = FALSE;
const_c__PCUIF__Flags__default.spare() = bs_0;
const_c__PCUIF__Flags__default.cs1() = TRUE;
const_c__PCUIF__Flags__default.cs2() = TRUE;
const_c__PCUIF__Flags__default.cs3() = TRUE;
const_c__PCUIF__Flags__default.cs4() = TRUE;
const_c__PCUIF__Flags__default.mcs1() = TRUE;
const_c__PCUIF__Flags__default.mcs2() = TRUE;
const_c__PCUIF__Flags__default.mcs3() = TRUE;
const_c__PCUIF__Flags__default.mcs4() = TRUE;
const_c__PCUIF__Flags__default.mcs5() = TRUE;
const_c__PCUIF__Flags__default.mcs6() = TRUE;
const_c__PCUIF__Flags__default.mcs7() = TRUE;
const_c__PCUIF__Flags__default.mcs8() = TRUE;
const_c__PCUIF__Flags__default.mcs9() = TRUE;
const_c__PCUIF__Flags__default.spare2() = bs_1;
}

static void post_init_module()
{
TTCN_Location current_location("PCUIF_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "PCUIF_Types");
Osmocom__Types::module_object.post_init_module();
template_tr__PCUIF__RTS__REQ_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__RTS__REQ_trx__nr_defval = ANY_VALUE;
template_tr__PCUIF__RTS__REQ_ts__nr_defval = ANY_VALUE;
template_tr__PCUIF__RTS__REQ_sapi_defval = ANY_VALUE;
template_tr__PCUIF__RTS__REQ_fn_defval = ANY_VALUE;
template_tr__PCUIF__RTS__REQ_block__nr_defval = ANY_VALUE;
template_tr__PCUIF__TXT__IND_text_defval = ANY_VALUE;
template_ts__PCUIF__DATA__IND_rssi_defval = -80;
template_ts__PCUIF__DATA__IND_ber10k_defval = 0;
template_ts__PCUIF__DATA__IND_ta__offs__qbits_defval = 0;
template_ts__PCUIF__DATA__IND_lqual__cb_defval = 10;
template_tr__PCUIF__DATA__IND_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__IND_trx__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__IND_ts__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__IND_block__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__IND_sapi_defval = ANY_VALUE;
template_tr__PCUIF__DATA__IND_data_defval = ANY_VALUE;
template_tr__PCUIF__DATA__REQ_block__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__REQ_fn_defval = ANY_VALUE;
template_tr__PCUIF__DATA__REQ_sapi_defval = ANY_VALUE;
template_tr__PCUIF__DATA__REQ_data_defval = ANY_VALUE;
template_tr__PCUIF__DATA__CNF_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__CNF_trx__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__CNF_ts__nr_defval = ANY_VALUE;
template_tr__PCUIF__DATA__CNF_sapi_defval = ANY_VALUE;
template_tr__PCUIF__DATA__CNF_data_defval = ANY_VALUE;
template_ts__PCUIF__RACH__IND_qta_defval = 0;
template_tr__PCUIF__RACH__IND_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__RACH__IND_ra_defval = ANY_VALUE;
template_tr__PCUIF__RACH__IND_is__11bit_defval = ANY_VALUE;
template_tr__PCUIF__RACH__IND_burst__type_defval = ANY_VALUE;
template_tr__PCUIF__RACH__IND_fn_defval = ANY_VALUE;
template_tr__PCUIF__PAG__REQ_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__PAG__REQ_id__lv_defval = ANY_VALUE;
template_tr__PCUIF__PAG__REQ_chan__needed_defval = ANY_VALUE;
template_tr__PCUIF__PAG__REQ_sapi_defval = ANY_VALUE;
template_ts__PCUIF__InfoTrx_arfcn_defval = 871;
template_ts__PCUIF__InfoTrx_pdch__mask_defval = bs_2;
const_ts__PCUIF__InfoTrx_tsc_defval = os_3;
current_location.update_lineno(643);
/* PCUIF_Types.ttcn, line 643 */
template_ts__PCUIF__InfoTrxNULL = ts__PCUIF__InfoTrx(INTEGER_template(0), BITSTRING_template(bs_3), os_2);
current_location.update_lineno(645);
/* PCUIF_Types.ttcn, line 645 */
template_ts__PCUIF__InfoTrxs__def.set_size(8);
template_ts__PCUIF__InfoTrxs__def[0] = ts__PCUIF__InfoTrx(ts__PCUIF__InfoTrx_arfcn_defval, ts__PCUIF__InfoTrx_pdch__mask_defval, ts__PCUIF__InfoTrx_tsc_defval);
template_ts__PCUIF__InfoTrxs__def[1] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[2] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[3] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[4] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[5] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[6] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__InfoTrxs__def[7] = ts__PCUIF__InfoTrxNULL;
template_ts__PCUIF__INFO__IND_flags_defval = c__PCUIF__Flags__default;
template_ts__PCUIF__INFO__IND_mcc_defval = 262;
template_ts__PCUIF__INFO__IND_mnc_defval = 42;
template_ts__PCUIF__INFO__IND_lac_defval = 13135;
template_ts__PCUIF__INFO__IND_rac_defval = 0;
template_ts__PCUIF__INFO__IND_cell__id_defval = 20960;
template_ts__PCUIF__INFO__IND_bsic_defval = 7;
template_ts__PCUIF__INFO__IND_trx_defval = ts__PCUIF__InfoTrxs__def;
template_ts__PCUIF__INFO__IND_version_defval = 9;
template_tr__PCUIF__INFO__IND_bts__nr_defval = ANY_VALUE;
template_tr__PCUIF__INFO__IND_flags_defval = ANY_VALUE;
template_tr__PCUIF__INFO__IND_version_defval = 9;
}


} /* end of namespace */
